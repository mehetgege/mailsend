<!DOCTYPE html>
<html lang="tr" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ULTIMATE TRADING WAR ROOM v3.0 | SAVA≈û √úSS√ú</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@300;400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
    <!-- TSParticles for visual effects -->
    <script src="https://cdn.jsdelivr.net/npm/tsparticles-slim@2.12.0/tsparticles.slim.bundle.min.js"></script>
    <!-- TensorFlow.js for Machine Learning -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <!-- ML.js for additional ML algorithms -->
    <script src="https://cdn.jsdelivr.net/npm/ml-matrix@6.10.4/lib/ml-matrix.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ml-regression@6.0.1/lib/ml-regression.min.js"></script>
    <style>
    /* Yeni Tasarƒ±m Deƒüi≈ükenleri */
    :root {
        /* Temel Renkler */
        --metatron-color: #64B5F6;  /* Mavi - Bilgelik */
        --uriel-color: #FFA726;     /* Turuncu - Cesaret */
        --raphael-color: #81C784;   /* Ye≈üil - ≈ûifa */
        --gabriel-color: #BA68C8;   /* Mor - ƒ∞leti≈üim */
        --michael-color: #EF5350;   /* Kƒ±rmƒ±zƒ± - Sava≈ü */
        
        /* UI Ana Deƒüi≈ükenler */
        --header-height: 50px;      /* √úst men√º y√ºksekliƒüi */
        --menu-width: 60px;         /* Yan men√º geni≈üliƒüi */
        --menu-expanded-width: 250px; /* Geni≈ületilmi≈ü yan men√º */
        --chart-padding: 10px;      /* Grafik etrafƒ±ndaki bo≈üluk */
        --animation-speed: 0.3s;    /* Standart animasyon hƒ±zƒ± */
        
        /* Tema Deƒüi≈ükenleri - Dark Theme */
        --background: #131722;
        --panel-bg: #1c2230;
        --text-main: #e1e2e6;
        --text-secondary: #9ca3af;
        --border-color: #2a2e39;
        --input-bg: #171b26;
        --hover-bg: #22283a;
        --primary: #3b82f6;
        --primary-rgb: 59, 130, 246;
        --primary-light: #60a5fa;
        --primary-dark: #2563eb;
        
        /* Durum Renkleri */
        --success: #10b981;
        --success-rgb: 16, 185, 129;
        --danger: #ef4444;
        --danger-rgb: 239, 68, 68;
        --warning: #f59e0b;
        --warning-rgb: 245, 158, 11;
        --info: #3b82f6;
        --info-rgb: 59, 130, 246;
        
        /* √ñzel UI Renkleri */
        --card-gradient: linear-gradient(145deg, #1c2230, #181e2a);
        --shadow-small: 0 2px 5px rgba(0,0,0,0.2);
        --shadow-medium: 0 4px 10px rgba(0,0,0,0.3);
        --shadow-large: 0 10px 25px rgba(0,0,0,0.4);
    }
    
    /* A√ßƒ±k Tema */
    [data-theme="light"] {
        --background: #f1f5f9;
        --panel-bg: #ffffff;
        --text-main: #1e293b;
        --text-secondary: #64748b;
        --border-color: #e2e8f0;
        --input-bg: #f8fafc;
        --hover-bg: #e2e8f0;
        --primary: #3b82f6;
        --primary-rgb: 59, 130, 246;
        --primary-light: #60a5fa;
        --primary-dark: #2563eb;
        
        --success: #10b981;
        --success-rgb: 16, 185, 129;
        --danger: #ef4444;
        --danger-rgb: 239, 68, 68;
        --warning: #f59e0b;
        --warning-rgb: 245, 158, 11;
        --info: #3b82f6;
        --info-rgb: 59, 130, 246;
        
        --card-gradient: linear-gradient(145deg, #ffffff, #f8fafc);
        --shadow-small: 0 2px 5px rgba(0,0,0,0.05);
        --shadow-medium: 0 4px 10px rgba(0,0,0,0.1);
        --shadow-large: 0 10px 25px rgba(0,0,0,0.15);
    }
    
    /* Sava≈ü Modu */
    [data-theme="war"] {
        --background: #1a0a0a;
        --panel-bg: #240d0d;
        --text-main: #ffd700;
        --text-secondary: #ff9e45;
        --border-color: #4d1a1a;
        --input-bg: #2d1010;
        --hover-bg: #3a1515;
        --primary: #ff4500;
        --primary-rgb: 255, 69, 0;
        --primary-light: #ff6a33;
        --primary-dark: #cc3700;
        
        --success: #ffd700;
        --success-rgb: 255, 215, 0;
        --danger: #ff0000;
        --danger-rgb: 255, 0, 0;
        --warning: #ff8c00;
        --warning-rgb: 255, 140, 0;
        --info: #ff4500;
        --info-rgb: 255, 69, 0;
        
        --card-gradient: linear-gradient(145deg, #240d0d, #1d0808);
        --shadow-small: 0 2px 5px rgba(255,0,0,0.2);
        --shadow-medium: 0 4px 10px rgba(255,0,0,0.3);
        --shadow-large: 0 10px 25px rgba(255,0,0,0.4);
    }
    
    /* YENƒ∞ EMOJƒ∞ STICKER BAR STƒ∞LLERƒ∞ */
    .emoji-sticker-bar {
        display: flex;
        align-items: center;
        gap: 8px;
        flex: 1;
        justify-content: center;
        max-width: 600px;
        margin: 0 auto;
    }
    
    .sticker-item {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 48px;
        height: 24px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 20px;
        cursor: pointer;
        transition: all 0.3s ease;
        padding: 2px 8px;
        user-select: none;
    }
    
    .sticker-item:hover {
        background: rgba(255, 255, 255, 0.15);
        border-color: var(--primary);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
    }
    
    .sticker-item.active {
        background: rgba(59, 130, 246, 0.2);
        border-color: var(--primary);
        box-shadow: 0 0 8px rgba(59, 130, 246, 0.3);
    }
    
    .sticker-emoji {
        font-size: 16px;
        filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));
    }
    
    /* Mini G√∂stergeler */
    .notification-badge, .signal-badge {
        position: absolute;
        top: -4px;
        right: -4px;
        background: var(--danger);
        color: white;
        font-size: 9px;
        font-weight: bold;
        min-width: 14px;
        height: 14px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        animation: pulse-badge 2s infinite;
    }
    
    @keyframes pulse-badge {
        0% { transform: scale(1); }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); }
    }
    
    .mini-energy-bar {
        position: absolute;
        bottom: -8px;
        left: 50%;
        transform: translateX(-50%);
        width: 30px;
        height: 2px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 1px;
        overflow: hidden;
    }
    
    .mini-energy-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--warning), var(--success));
        border-radius: 1px;
        transition: width 0.5s ease;
    }
    
    .mini-power-indicator {
        position: absolute;
        bottom: -6px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 2px;
    }
    
    .power-dot {
        width: 4px;
        height: 4px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.3);
        transition: background 0.3s ease;
    }
    
    .power-dot.active {
        background: var(--primary);
        box-shadow: 0 0 4px var(--primary);
    }
    
    .mini-confidence-circle {
        position: absolute;
        bottom: -8px;
        left: 50%;
        transform: translateX(-50%);
        width: 16px;
        height: 16px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.3);
    }
    
    .confidence-text {
        font-size: 8px;
        font-weight: bold;
        color: var(--text-primary);
    }
    
    /* Ana Men√º Sistemi */
    .main-menu-container {
        position: fixed;
        top: 0;
        left: 0;
        z-index: 2000;
    }
    
    .menu-toggle-btn {
        position: fixed;
        top: 15px;
        left: 15px;
        z-index: 2001;
        width: 40px;
        height: 40px;
        background: var(--panel-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        backdrop-filter: blur(4px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }
    
    .menu-toggle-btn:hover {
        background: var(--hover-bg);
        border-color: var(--primary);
        transform: translateY(-1px);
    }
    
    .menu-icon {
        font-size: 18px;
        transition: transform 0.3s ease;
    }
    
    .menu-toggle-btn.active .menu-icon {
        transform: rotate(90deg);
    }
    
    .main-menu {
        position: fixed;
        top: 0;
        left: -350px;
        width: 340px;
        height: 100vh;
        background: var(--panel-bg);
        border-right: 1px solid var(--border-color);
        box-shadow: 2px 0 15px rgba(0, 0, 0, 0.3);
        transition: left 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 2000;
        overflow-y: auto;
        backdrop-filter: blur(8px);
    }
    
    .main-menu.open {
        left: 0;
    }
    
    #panteon-panel{
        position: fixed;
        top: 20px;
        left: 20px; /* Sol √ºste ta≈üƒ± */
        z-index: 1200;
        width: 320px; /* Biraz k√º√ß√ºlt */
        background: rgba(22,27,34,0.95);
        backdrop-filter: blur(6px);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        font-family: 'Roboto Mono', monospace;
        color: var(--text-main);
        box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        transition: all 0.3s ease;
        overflow: hidden;
    }
    #panteon-panel .pp-title{
        display: flex; 
        align-items: center; 
        justify-content: space-between; 
        padding: 10px 15px; 
        font-size: 15px; 
        font-weight: 600; 
        border-bottom: 1px solid var(--border-color);
        background: rgba(0,0,0,0.2);
        color: var(--yellow);
    }
    #panteon-panel .pp-body{
        padding: 0;
        max-height: 70vh;
        overflow-y: auto;
    }
    
    /* Panteon ƒ∞statistikleri */
    .panteon-stats {
        display: flex;
        justify-content: space-between;
        padding: 8px 12px;
        background: rgba(0,0,0,0.15);
        border-bottom: 1px solid var(--border-color);
        font-size: 13px;
    }
    
    .regime-indicator, .state-indicator {
        display: flex;
        gap: 8px;
    }
    
    .current-regime {
        color: var(--uriel-color);
        font-weight: 600;
    }
    
    .collective-state {
        color: var(--metatron-color);
        font-weight: 600;
    }
    
    /* Panteon Panel ƒ∞yile≈ütirmeler */
    .panteon-panel {
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 10px;
    }
    
    /* El√ßi Kartlarƒ± */
    .ambassador {
        background: rgba(0,0,0,0.2);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        padding: 10px;
        transition: all 0.3s ease;
        position: relative;
    }
    
    .ambassador.active {
        border-color: var(--accent-color);
    }
    
    .ambassador.inactive {
        opacity: 0.6;
        filter: grayscale(0.7);
    }
    
    /* El√ßi Mod Renklendirmeleri */
    .ambassador[data-mode="ƒ∞NAN√áLI"] {
        border-left: 4px solid var(--green);
    }
    
    .ambassador[data-mode="≈û√úPHECƒ∞"] {
        border-left: 4px solid var(--yellow);
    }
    
    .ambassador[data-mode="KIYAMET"] {
        border-left: 4px solid var(--red);
    }
    
    /* El√ßi Rol Renklendirmeleri */
    .ambassador[data-role="wisdom"] .ambassador-name {
        color: var(--metatron-color);
    }
    
    .ambassador[data-role="courage"] .ambassador-name {
        color: var(--uriel-color);
    }
    
    .ambassador[data-role="healing"] .ambassador-name {
        color: var(--raphael-color);
    }
    
    .ambassador[data-role="communication"] .ambassador-name {
        color: var(--gabriel-color);
    }
    
    .ambassador[data-role="warfare"] .ambassador-name {
        color: var(--michael-color);
    }
    
    /* El√ßi Ba≈ülƒ±k */
    .ambassador-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 6px;
    }
    
    .ambassador-name {
        font-weight: 600;
        font-size: 15px;
    }
    
    .ambassador-toggle {
        width: 22px;
        height: 22px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(255,255,255,0.1);
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .ambassador-toggle:hover {
        background: rgba(255,255,255,0.2);
    }
    
    /* El√ßi Bilgileri */
    .ambassador-info {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        margin-bottom: 8px;
    }
    
    .ambassador-role {
        opacity: 0.7;
    }
    
    .ambassador-status {
        display: flex;
        gap: 10px;
    }
    
    .ambassador-mode {
        font-weight: 600;
    }
    
    .ambassador[data-mode="ƒ∞NAN√áLI"] .ambassador-mode {
        color: var(--green);
    }
    
    .ambassador[data-mode="≈û√úPHECƒ∞"] .ambassador-mode {
        color: var(--yellow);
    }
    
    .ambassador[data-mode="KIYAMET"] .ambassador-mode {
        color: var(--red);
    }
    
    .reputation {
        opacity: 0.8;
    }
    
    .reputation-score {
        font-weight: 600;
    }
    
    /* ƒ∞lerleme √áubuklarƒ± */
    .progress-container {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-bottom: 8px;
    }
    
    .confidence, .power {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 12px;
    }
    
    .confidence span, .power span {
        width: 45px;
        opacity: 0.7;
    }
    
    .confidence-bar, .power-bar {
        flex: 1;
        height: 6px;
        background: rgba(255,255,255,0.1);
        border-radius: 3px;
        overflow: hidden;
        position: relative;
    }
    
    .confidence-level {
        height: 100%;
        background: linear-gradient(90deg, var(--yellow), var(--green));
        border-radius: 3px;
        font-size: 9px;
        display: flex;
        align-items: center;
        justify-content: flex-end;
        padding-right: 4px;
        color: rgba(0,0,0,0.7);
        transition: width 0.5s ease;
    }
    
    .power-level {
        height: 100%;
        background: linear-gradient(90deg, var(--accent-color), var(--accent-color-bright));
        border-radius: 3px;
        transition: width 0.5s ease;
    }
    
    /* Strateji Se√ßim Butonlarƒ± */
    .strategy-select {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
        margin-top: 5px;
    }
    
    .strategy-select button {
        background: rgba(0,0,0,0.3);
        border: 1px solid var(--border-color);
        color: var(--text-secondary);
        font-size: 11px;
        padding: 3px 8px;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .strategy-select button:hover {
        background: rgba(255,255,255,0.1);
    }
    
    .strategy-select button.active {
        background: rgba(var(--accent-color-rgb), 0.3);
        border-color: var(--accent-color);
        color: var(--accent-color-bright);
    }
    
    /* Yetenek D√ºƒümeleri */
    .pantheon-abilities {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-top: 10px;
        padding: 10px;
        border-top: 1px solid var(--border-color);
    }
    
    .pantheon-ability {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        cursor: pointer;
        transition: all 0.2s ease;
        padding: 8px;
        border-radius: 6px;
        width: 90px;
    }
    
    .pantheon-ability:hover {
        background: rgba(255,255,255,0.05);
    }
    
    .pantheon-ability.ready {
        border: 1px solid rgba(var(--accent-color-rgb), 0.5);
    }
    
    .pantheon-ability.cooldown {
        opacity: 0.6;
        border: 1px solid rgba(255,255,255,0.1);
    }
    
    .ability-icon {
        font-size: 18px;
    }
    
    .ability-name {
        font-size: 12px;
        font-weight: 600;
    }
    
    .cooldown-indicator {
        font-size: 10px;
        opacity: 0.7;
    }
    
    /* Aktif Konsey Efektleri */
    .pp-power-fill {
        height: 100%;
        border-radius: 2px;
        transition: width 0.5s ease;
    }
    #amb-metatron .pp-power-fill { background: var(--metatron-color, #3b82f6); }
    #amb-uriel .pp-power-fill { background: var(--uriel-color, #ef4444); }
    #amb-raphael .pp-power-fill { background: var(--raphael-color, #10b981); }
    #amb-gabriel .pp-power-fill { background: var(--gabriel-color, #a855f7); }
    #amb-michael .pp-power-fill { background: var(--michael-color, #f97316); }
    
    .pp-expand-btn {
        background: transparent;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        padding: 0;
        font-size: 12px;
        opacity: 0.7;
        transition: all 0.2s ease;
    }
    .pp-expand-btn:hover {
        opacity: 1;
        color: var(--primary);
    }
    
    .pp-collective-state {
        font-size: 11px;
        display: flex;
        align-items: center;
    }
    .pp-state-label {
        color: var(--text-secondary);
        margin-right: 5px;
    }
    .pp-state-value {
        font-weight: bold;
    }
    
    .pp-actions {
        display: flex;
        gap: 5px;
    }
    .pp-action-btn {
        background: transparent;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        padding: 4px;
        font-size: 12px;
        opacity: 0.7;
        transition: all 0.2s ease;
        border-radius: 3px;
    }
    .pp-action-btn:hover {
        opacity: 1;
        color: var(--primary);
        background: var(--bg-tertiary);
    }
    
    /* Renk deƒüi≈ükenleri - El√ßi renkleri */
    :root {
        --metatron-color: #3b82f6; /* Mavi - Bilgelik */
        --uriel-color: #ef4444;    /* Kƒ±rmƒ±zƒ± - Cesaret */
        --raphael-color: #10b981;  /* Ye≈üil - ≈ûifa */
        --gabriel-color: #a855f7;  /* Mor - ƒ∞leti≈üim */
        --michael-color: #f97316;  /* Turuncu - Sava≈ü */
    }
    
    /* Kehanet Paneli (saƒü alt) */
    #kehanet-panel{ 
        position: fixed; 
        right: 10px; 
        bottom: 12px; 
        z-index: 1200; 
        width: 260px; 
        background: rgba(22,27,34,0.9); 
        backdrop-filter: blur(4px); 
        border: 1px solid var(--border-color); 
        border-radius: 6px; 
        font-family: 'Roboto Mono', monospace; 
        color: var(--text-main); 
        box-shadow: 0 2px 10px rgba(0,0,0,0.35);
        transition: all 0.3s ease;
    }
    #kehanet-panel .kp-title{ 
        display: flex; 
        align-items: center; 
        justify-content: space-between; 
        padding: 8px 10px; 
        border-bottom: 1px solid var(--border-color); 
        font-weight: 700; 
        font-size: 12px; 
        color: var(--primary); 
        user-select: none; 
    }
    #kehanet-panel .kp-body{ 
        padding: 8px 10px; 
        display: grid; 
        gap: 6px; 
        font-size: 12px; 
    }
    #kehanet-panel .kp-footer {
        border-top: 1px solid var(--border-color);
        padding: 8px 10px;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    .kp-row{ 
        display: flex; 
        align-items: center; 
        justify-content: space-between;
        padding: 2px 0;
    }
    .kp-key{ 
        color: var(--text-secondary); 
    }
    .kp-val{ 
        font-weight: 700; 
    }
    .kp-divider {
        height: 1px;
        background: var(--border-color);
        margin: 4px 0;
        opacity: 0.6;
    }
    .kp-advanced {
        display: none;
        opacity: 0;
        transform: translateY(-10px);
        transition: all 0.3s ease;
    }
    .kp-panel-expanded .kp-advanced {
        display: grid;
        gap: 6px;
        opacity: 1;
        transform: translateY(0);
    }
    .kp-panel-expanded {
        width: 320px;
        height: auto;
    }
    .kp-expand-btn {
        background: transparent;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        padding: 0;
        font-size: 12px;
        opacity: 0.7;
        transition: all 0.2s ease;
    }
    .kp-expand-btn:hover {
        opacity: 1;
        color: var(--primary);
    }
    .kp-chart-container {
        margin-top: 6px;
        height: 70px;
        background: var(--bg-tertiary);
        border-radius: 4px;
        overflow: hidden;
        border: 1px solid var(--border-color);
    }
    .kp-mini-chart {
        width: 100%;
        height: 100%;
    }
    .kp-confidence-bar {
        flex: 1;
        height: 6px;
        background: var(--bg-tertiary);
        border-radius: 3px;
        overflow: hidden;
        position: relative;
        margin-right: 10px;
    }
    .kp-confidence-fill {
        height: 100%;
        width: 75%;
        background: linear-gradient(90deg, var(--warning) 0%, var(--success) 100%);
        border-radius: 3px;
        transition: width 0.5s ease;
    }
    .kp-confidence-label {
        position: absolute;
        top: -16px;
        right: 5px;
        font-size: 9px;
        color: var(--text-secondary);
    }
    .kp-refresh-btn {
        background: transparent;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        padding: 0;
        font-size: 14px;
        opacity: 0.7;
        transition: all 0.2s ease;
    }
    .kp-refresh-btn:hover {
        opacity: 1;
        color: var(--primary);
        transform: rotate(180deg);
    }
    .prediction-refresh {
        animation: prediction-pulse 0.8s ease-out;
    }
    @keyframes prediction-pulse {
        0% { box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.3); }
        70% { box-shadow: 0 0 0 15px rgba(139, 92, 246, 0); }
        100% { box-shadow: 0 0 0 0 rgba(139, 92, 246, 0); }
    }
    .trend-up { color: var(--success); }
    .trend-down { color: var(--danger); }
    .trend-neutral { color: var(--warning); }
    
    /* tsParticles katmanƒ± (ƒ∞lk I≈üƒ±k ve diƒüer efektler i√ßin) */
    #cosmic-effects-layer{
        position: fixed; 
        inset: 0; 
        z-index: 3000; 
        pointer-events: none;
    }
    
    /* Enerji Kutusu Stilleri */
    .energy-box {
        position: fixed;
        bottom: 70px;
        right: 10px;
        width: 250px;
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        box-shadow: 0 0 20px rgba(0, 170, 255, 0.3);
        z-index: 999;
        padding: 10px;
        color: var(--text-primary);
        transition: all 0.3s ease;
    }
    
    .energy-box-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 5px;
    }
    
    .energy-box-title {
        font-family: var(--primary-font);
        font-size: 14px;
        font-weight: bold;
        color: var(--info);
        margin: 0;
    }
    
    .energy-box-close {
        cursor: pointer;
        opacity: 0.7;
        transition: opacity 0.2s;
        color: var(--text-secondary);
    }
    
    .energy-box-close:hover {
        opacity: 1;
    }
    
    .energy-meter {
        width: 100%;
        height: 15px;
        background: var(--bg-tertiary);
        border-radius: 10px;
        overflow: hidden;
        margin: 5px 0;
        position: relative;
    }
    
    .energy-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--info) 0%, var(--success) 100%);
        border-radius: 10px;
        width: 75%;
        transition: width 1s ease;
        position: relative;
    }
    
    .energy-fill::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.2) 50%, rgba(255,255,255,0) 100%);
        animation: energy-pulse 2s infinite;
    }
    
    @keyframes energy-pulse {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(100%); }
    }
    
    .energy-info {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        color: var(--text-secondary);
        margin-bottom: 10px;
    }
    
    .energy-actions {
        display: flex;
        justify-content: space-between;
        margin-top: 5px;
        gap: 5px;
    }
    
    .energy-action-btn {
        flex: 1;
        background: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        color: var(--text-primary);
        padding: 5px;
        font-size: 11px;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
        text-align: center;
    }
    
    .energy-action-btn:hover {
        background: var(--hover-bg);
        border-color: var(--primary);
    }
    
    .energy-low {
        box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
    }
    
    .energy-low .energy-fill {
        background: linear-gradient(90deg, #ff3366 0%, #ffaa00 100%);
    }
    
    .energy-status {
        text-align: center;
        font-size: 11px;
        color: var(--text-secondary);
        margin: 5px 0;
        padding: 2px;
        border-radius: 3px;
        background: var(--bg-tertiary);
    }

    /* Mobil uyumluluk */
    @media screen and (max-width: 768px){
        #panteon-panel{ 
            width: 90vw !important;
            left: 5vw !important;
            top: 10px !important;
        }
        #kehanet-panel{
            width: 90vw !important;
            right: 5vw !important;
            bottom: 10px !important;
        }
        #osiris-main-panel{
            width: 90vw !important;
            right: 5vw !important;
            top: 70px !important;
        }
    }
        }
        .energy-box {
            bottom: 120px;
            width: 200px;
        }
    }
    </style>
    <script>
    // Emoji G√ºvenlik Sistemi - √áekirdek Sƒ±nƒ±f
    class EmojiSecuritySystem {
        constructor() {
            this.securityLevel = 'normal';
            this.activeThreats = [];
            this.notifications = [];
            this.confidence = 75;
            this.energy = 80;
            this.signalStrength = 65;
            this.powerLevel = 70;
            this.analyticsData = {
                risk: 'medium',
                signals: 15,
                accuracy: 78
            };
            this.init();
        }

        init() {
            this.createEmojiBar();
            this.bindEmojiEvents();
            this.startSecurityMonitoring();
            this.updateAllStickers();
        }

        createEmojiBar() {
            const existingBar = document.querySelector('.emoji-sticker-bar');
            if (existingBar) {
                existingBar.innerHTML = this.generateEmojiBarHTML();
            }
        }

        generateEmojiBarHTML() {
            return `
                <div class="sticker-item" data-type="notifications" title="Bildirimler">
                    <span class="sticker-emoji">üì¢</span>
                    <div class="notification-badge" id="notif-badge">3</div>
                    <div class="mini-energy-bar">
                        <div class="mini-energy-fill" style="width: 60%"></div>
                    </div>
                </div>
                
                <div class="sticker-item" data-type="security" title="G√ºvenlik Seviyesi">
                    <span class="sticker-emoji">üõ°Ô∏è</span>
                    <div class="signal-badge" id="security-badge">‚ö†Ô∏è</div>
                    <div class="mini-power-indicator">
                        <div class="power-dot active"></div>
                        <div class="power-dot active"></div>
                        <div class="power-dot active"></div>
                        <div class="power-dot"></div>
                        <div class="power-dot"></div>
                    </div>
                </div>
                
                <div class="sticker-item" data-type="signals" title="Sinyal G√ºc√º">
                    <span class="sticker-emoji">üì°</span>
                    <div class="mini-confidence-circle">
                        <span class="confidence-text">78</span>
                    </div>
                </div>
                
                <div class="sticker-item" data-type="analytics" title="Analitik">
                    <span class="sticker-emoji">üìä</span>
                    <div class="mini-energy-bar">
                        <div class="mini-energy-fill" style="width: 85%"></div>
                    </div>
                </div>
                
                <div class="sticker-item" data-type="energy" title="Enerji Seviyesi">
                    <span class="sticker-emoji">‚ö°</span>
                    <div class="mini-power-indicator">
                        <div class="power-dot active"></div>
                        <div class="power-dot active"></div>
                        <div class="power-dot active"></div>
                        <div class="power-dot active"></div>
                        <div class="power-dot"></div>
                    </div>
                </div>
                
                <div class="sticker-item" data-type="ai" title="AI Durumu">
                    <span class="sticker-emoji">ü§ñ</span>
                    <div class="signal-badge" id="ai-badge">ON</div>
                </div>
                
                <div class="sticker-item" data-type="market" title="Piyasa Durumu">
                    <span class="sticker-emoji">üìà</span>
                    <div class="mini-confidence-circle">
                        <span class="confidence-text">‚Üó</span>
                    </div>
                </div>
            `;
        }

        bindEmojiEvents() {
            document.querySelectorAll('.sticker-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    const type = item.dataset.type;
                    this.handleEmojiClick(type, item);
                });
                
                item.addEventListener('mouseenter', (e) => {
                    this.showQuickInfo(item);
                });
            });
        }

        handleEmojiClick(type, element) {
            element.classList.add('active');
            setTimeout(() => element.classList.remove('active'), 300);

            switch(type) {
                case 'notifications':
                    this.toggleNotificationDetails();
                    break;
                case 'security':
                    this.showSecurityReport();
                    break;
                case 'signals':
                    this.showSignalAnalysis();
                    break;
                case 'analytics':
                    this.openAnalyticsDashboard();
                    break;
                case 'energy':
                    this.showEnergyManagement();
                    break;
                case 'ai':
                    this.toggleAISystem();
                    break;
                case 'market':
                    this.showMarketOverview();
                    break;
            }
        }

        updateAllStickers() {
            this.updateNotificationSticker();
            this.updateSecuritySticker();
            this.updateSignalSticker();
            this.updateEnergySticker();
            this.updateAISticker();
            this.updateMarketSticker();
        }

        updateNotificationSticker() {
            const badge = document.getElementById('notif-badge');
            if (badge) {
                badge.textContent = this.notifications.length;
                badge.style.display = this.notifications.length > 0 ? 'flex' : 'none';
            }
        }

        updateSecuritySticker() {
            const badge = document.getElementById('security-badge');
            const powerDots = document.querySelectorAll('[data-type="security"] .power-dot');
            
            if (badge) {
                const level = this.getSecurityLevel();
                badge.textContent = level === 'high' ? 'üü¢' : level === 'medium' ? 'üü°' : 'üî¥';
            }
            
            const activeCount = Math.floor((this.confidence / 100) * 5);
            powerDots.forEach((dot, index) => {
                dot.classList.toggle('active', index < activeCount);
            });
        }

        updateEnergySticker() {
            const powerDots = document.querySelectorAll('[data-type="energy"] .power-dot');
            const activeCount = Math.floor((this.energy / 100) * 5);
            
            powerDots.forEach((dot, index) => {
                dot.classList.toggle('active', index < activeCount);
            });
        }

        showQuickInfo(element) {
            const type = element.dataset.type;
            const tooltip = document.createElement('div');
            tooltip.className = 'sticker-tooltip';
            tooltip.style.cssText = `
                position: absolute;
                bottom: 100%;
                left: 50%;
                transform: translateX(-50%);
                background: var(--panel-bg);
                border: 1px solid var(--border-color);
                border-radius: 4px;
                padding: 4px 8px;
                font-size: 10px;
                white-space: nowrap;
                z-index: 1000;
                margin-bottom: 5px;
            `;
            
            const info = this.getQuickInfo(type);
            tooltip.textContent = info;
            
            element.style.position = 'relative';
            element.appendChild(tooltip);
            
            setTimeout(() => {
                if (tooltip.parentNode) {
                    tooltip.parentNode.removeChild(tooltip);
                }
            }, 2000);
        }

        getQuickInfo(type) {
            const infos = {
                notifications: `${this.notifications.length} yeni bildirim`,
                security: `G√ºvenlik: ${this.getSecurityLevel()}`,
                signals: `Sinyal g√ºc√º: ${this.signalStrength}%`,
                analytics: `Risk seviyesi: ${this.analyticsData.risk}`,
                energy: `Enerji: ${this.energy}%`,
                ai: 'AI sistemi aktif',
                market: 'Piyasa: Y√ºkseli≈ü eƒüilimi'
            };
            return infos[type] || 'Bilgi yok';
        }

        getSecurityLevel() {
            if (this.confidence > 80) return 'high';
            if (this.confidence > 50) return 'medium';
            return 'low';
        }

        startSecurityMonitoring() {
            setInterval(() => {
                this.updateSecurityMetrics();
                this.updateAllStickers();
            }, 3000);
        }

        updateSecurityMetrics() {
            // Rastgele deƒüi≈üimler sim√ºle et
            this.confidence += (Math.random() - 0.5) * 5;
            this.energy += (Math.random() - 0.5) * 3;
            this.signalStrength += (Math.random() - 0.5) * 4;
            
            // Sƒ±nƒ±rlarƒ± koru
            this.confidence = Math.max(0, Math.min(100, this.confidence));
            this.energy = Math.max(0, Math.min(100, this.energy));
            this.signalStrength = Math.max(0, Math.min(100, this.signalStrength));
        }

        toggleNotificationDetails() {
            console.log('Bildirim detaylarƒ± a√ßƒ±lƒ±yor...');
            if (window.app && window.app.showNotification) {
                window.app.showNotification('Bildirim sistemi a√ßƒ±ldƒ±', 'info');
            }
        }

        showSecurityReport() {
            console.log('G√ºvenlik raporu g√∂steriliyor...');
            if (window.app && window.app.showNotification) {
                window.app.showNotification(`G√ºvenlik seviyesi: ${this.getSecurityLevel()}`, 'info');
            }
        }

        showSignalAnalysis() {
            console.log('Sinyal analizi a√ßƒ±lƒ±yor...');
            if (window.app && window.app.showNotification) {
                window.app.showNotification(`Sinyal g√ºc√º: ${this.signalStrength.toFixed(0)}%`, 'info');
            }
        }

        openAnalyticsDashboard() {
            console.log('Analytics dashboard a√ßƒ±lƒ±yor...');
        }

        showEnergyManagement() {
            console.log('Enerji y√∂netimi a√ßƒ±lƒ±yor...');
            if (window.app && window.app.showNotification) {
                window.app.showNotification(`Enerji seviyesi: ${this.energy.toFixed(0)}%`, 'info');
            }
        }

        toggleAISystem() {
            console.log('AI sistemi toggle edildi');
            if (window.app && window.app.showNotification) {
                window.app.showNotification('AI sistemi yeniden ba≈ülatƒ±ldƒ±', 'success');
            }
        }

        showMarketOverview() {
            console.log('Piyasa genel durumu g√∂steriliyor...');
        }
    }

    // IndexedDB Yardƒ±mcƒ± Sƒ±nƒ±flarƒ±
    class IDBUtil {
        static promisifyRequest(req) {
            return new Promise((resolve, reject) => {
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }
    }
    
    // IndexedDB Y√∂netici Sƒ±nƒ±fƒ± - Panteon i√ßin
    class PanteonDBManager {
        constructor() {
            this.db = null;
            this.DB_NAME = 'UTC_PANTHEON_DB';
            this.DB_VERSION = 1;
        }
        
        static get instance() {
            if(!window.__panteonDbMan) {
                window.__panteonDbMan = new PanteonDBManager();
            }
            return window.__panteonDbMan;
        }
        
        async open() {
            if(this.db) return this.db;
            const req = indexedDB.open(this.DB_NAME, this.DB_VERSION);
            
            req.onupgradeneeded = (ev) => {
                const db = ev.target.result;
                if(!db.objectStoreNames.contains('settings')) db.createObjectStore('settings', { keyPath: 'id' });
                if(!db.objectStoreNames.contains('panteon')) db.createObjectStore('panteon', { keyPath: 'id' });
                if(!db.objectStoreNames.contains('strategyStats')) db.createObjectStore('strategyStats', { keyPath: 'strategyKey' });
                if(!db.objectStoreNames.contains('signals')) {
                    const s = db.createObjectStore('signals', { keyPath: 'id', autoIncrement: true });
                    s.createIndex('byTimestamp','timestamp',{unique:false});
                    s.createIndex('bySymbol','symbol',{unique:false});
                    s.createIndex('byStatus','status',{unique:false});
                    s.createIndex('byDirection','direction',{unique:false});
                }
                if(!db.objectStoreNames.contains('notifications')) {
                    const n = db.createObjectStore('notifications', { keyPath: 'id', autoIncrement: true });
                    n.createIndex('byTimestamp','timestamp',{unique:false});
                    n.createIndex('byType','type',{unique:false});
                }
                if(!db.objectStoreNames.contains('kv')) db.createObjectStore('kv', { keyPath: 'key' });
                if(!db.objectStoreNames.contains('meta')) db.createObjectStore('meta', { keyPath: 'key' });
            };
            
            this.db = await IDBUtil.promisifyRequest(req);
            return this.db;
        }
        
        store(name, mode='readonly') {
            const tx = this.db.transaction(name, mode);
            return tx.objectStore(name);
        }
        
        async getPanteonState() {
            await this.open();
            const res = await IDBUtil.promisifyRequest(this.store('panteon').get('state'));
            return res?.data || this._panteonDefaults();
        }
        
        async setPanteonState(data) {
            await this.open();
            await IDBUtil.promisifyRequest(this.store('panteon','readwrite').put({
                id: 'state',
                data,
                updatedAt: Date.now()
            }));
            return true;
        }
        
        _panteonDefaults() {
            return {
                zeus: { role: 'creator' },
                env: { createdAt: Date.now(), version: '3.2' },
                ambassadors: {
                    Metatron: { reputation: 0, mode: 'ƒ∞nan√ßlƒ±' },
                    Uriel: { reputation: 0, mode: 'ƒ∞nan√ßlƒ±' },
                    Raphael: { reputation: 0, mode: 'ƒ∞nan√ßlƒ±' }
                },
                lastDormancyPenaltyAt: null
            };
        }
    }
    
    // G√∂rsel Efektler Y√∂neticisi
    class EffectsManager {
        constructor() {
            this.layerId = 'cosmic-effects-layer';
            this.ensureLayer();
            this.effects = {
                firstLight: { cooldown: 5000, lastUsed: 0 },
                prediction: { cooldown: 3000, lastUsed: 0 },
                horseman: { cooldown: 10000, lastUsed: 0 },
                confluence: { cooldown: 2000, lastUsed: 0 }
            };
        }
        
        ensureLayer() {
            if(!document.getElementById(this.layerId)) {
                const d = document.createElement('div');
                d.id = this.layerId;
                d.style.position = 'fixed';
                d.style.inset = '0';
                d.style.zIndex = '3000';
                d.style.pointerEvents = 'none';
                document.body.appendChild(d);
            }
        }
        
        async ensureTsParticles() {
            if(window.tsParticles) return;
            await new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = 'https://cdn.jsdelivr.net/npm/tsparticles@3/tsparticles.bundle.min.js';
                s.async = true;
                s.onload = () => resolve(true);
                s.onerror = () => reject(new Error('tsParticles y√ºklenemedi'));
                document.head.appendChild(s);
            });
        }
        
        checkCooldown(effectName) {
            const effect = this.effects[effectName];
            if (!effect) return true;
            
            const now = Date.now();
            if (now - effect.lastUsed < effect.cooldown) {
                return false;
            }
            
            effect.lastUsed = now;
            return true;
        }
        
        async firstLight(duration=2200) {
            try {
                if (!this.checkCooldown('firstLight')) return null;
                
                await this.ensureTsParticles();
                const config = {
                    background: { color: 'transparent' },
                    fullScreen: { enable: false },
                    particles: { number: { value: 0 } },
                    emitters: {
                        position: { x: 50, y: 50 },
                        rate: { delay: 0.01, quantity: 60 },
                        life: { duration: duration/1000, count: 1 },
                        particles: {
                            move: { enable: true, speed: {min: 10, max: 40}, outModes: 'destroy' },
                            color: { value: ['#ffffff','#7dd3fc','#60a5fa'] },
                            shape: { type: 'circle' },
                            size: { value: {min: 1, max: 3} },
                            opacity: { value: {min: 0.2, max: 0.8} },
                            wobble: { enable: true, distance: 5, speed: 20 },
                            shadow: { enable: true, blur: 6, color: '#a5f3fc' }
                        }
                    }
                };
                
                const container = await window.tsParticles.load('cosmic-effects-layer', config);
                setTimeout(() => {
                    try { container?.destroy(); } catch {}
                }, duration + 250);
                
                return container;
            } catch(e) {
                const el = document.createElement('div');
                el.style.position = 'absolute';
                el.style.inset = '0';
                el.style.background = 'radial-gradient(circle at center, rgba(255,255,255,0.9), rgba(96,165,250,0.5), rgba(2,6,23,0))';
                el.style.animation = 'firstLightPulse 1.8s ease-out forwards';
                
                const st = document.createElement('style');
                st.textContent = `
                    @keyframes firstLightPulse {
                        0% { opacity: 0; transform: scale(0.6); filter: blur(4px); }
                        25% { opacity: 1; transform: scale(1.0); filter: blur(2px); }
                        100% { opacity: 0; transform: scale(1.8); filter: blur(8px); }
                    }
                `;
                
                document.head.appendChild(st);
                document.getElementById(this.layerId).appendChild(el);
                
                setTimeout(() => {
                    try { el.remove(); } catch {}
                }, 2000);
                
                console.error('firstLight effect error:', e);
                return null;
            }
        }
        
        async showPredictionEffect(duration=2000) {
            try {
                if (!this.checkCooldown('prediction')) return null;
                
                await this.ensureTsParticles();
                
                // Kehanet Paneli elemanƒ±nƒ± bul
                const kehanetPanel = document.getElementById('kehanet-panel');
                if (!kehanetPanel) return null;
                
                // Panel koordinatlarƒ±nƒ± al
                const rect = kehanetPanel.getBoundingClientRect();
                const x = (rect.left + rect.right) / 2;
                const y = (rect.top + rect.bottom) / 2;
                
                // Efekt ayarlarƒ±
                const config = {
                    background: { color: 'transparent' },
                    fullScreen: { enable: false },
                    particles: { number: { value: 0 } },
                    emitters: {
                        position: { x: (x / window.innerWidth) * 100, y: (y / window.innerHeight) * 100 },
                        rate: { delay: 0.01, quantity: 30 },
                        life: { duration: duration/1000, count: 1 },
                        particles: {
                            move: { 
                                enable: true, 
                                speed: {min: 1, max: 3},
                                outModes: 'destroy',
                                direction: 'out',
                                straight: false,
                                bounce: false
                            },
                            color: { value: ['#a855f7','#3b82f6','#06b6d4'] },
                            shape: { type: 'circle' },
                            size: { value: {min: 1, max: 4} },
                            opacity: { value: {min: 0.3, max: 0.8} },
                            life: { duration: {min: 1, max: 3} },
                            roll: { 
                                enable: true,
                                speed: 3
                            },
                            wobble: { 
                                enable: true, 
                                distance: 3,
                                speed: 10
                            },
                            tilt: {
                                enable: true,
                                direction: 'random',
                                value: {
                                    min: 0,
                                    max: 360
                                },
                                animation: {
                                    enable: true,
                                    speed: 10
                                }
                            },
                            shadow: { 
                                enable: true, 
                                blur: 3,
                                color: '#a5f3fc' 
                            }
                        }
                    }
                };
                
                const container = await window.tsParticles.load('cosmic-effects-layer', config);
                setTimeout(() => {
                    try { container?.destroy(); } catch {}
                }, duration);
                
                return container;
            } catch(e) {
                console.error('prediction effect error:', e);
                return null;
            }
        }
        
        async showHorsemanEffect(horseman, duration=3500) {
            try {
                if (!this.checkCooldown('horseman')) return null;
                
                await this.ensureTsParticles();
                
                // Atlƒ± tipine g√∂re renkleri ve efekt tipini belirle
                let colors, emitterShape, speed, particleShape;
                
                switch(horseman) {
                    case 'KITLIK':
                        colors = ['#fbbf24', '#f59e0b', '#d97706']; // Sarƒ±/Turuncu
                        emitterShape = 'square';
                        speed = {min: 1, max: 3};
                        particleShape = 'square';
                        break;
                    case 'SALGIN':
                        colors = ['#10b981', '#059669', '#047857']; // Ye≈üil
                        emitterShape = 'circle';
                        speed = {min: 2, max: 5};
                        particleShape = 'circle';
                        break;
                    case 'SAVA≈û':
                        colors = ['#ef4444', '#dc2626', '#b91c1c']; // Kƒ±rmƒ±zƒ±
                        emitterShape = 'triangle';
                        speed = {min: 5, max: 15};
                        particleShape = 'triangle';
                        break;
                    case '√ñL√úM':
                        colors = ['#8b5cf6', '#7c3aed', '#6d28d9']; // Mor
                        emitterShape = 'star';
                        speed = {min: 10, max: 25};
                        particleShape = 'polygon';
                        break;
                    default:
                        colors = ['#ffffff', '#e2e8f0', '#cbd5e1']; // Beyaz/Gri
                        emitterShape = 'circle';
                        speed = {min: 3, max: 8};
                        particleShape = 'circle';
                }
                
                // Efekt konfig√ºrasyonu
                const config = {
                    background: { color: 'transparent' },
                    fullScreen: { enable: true },
                    particles: { 
                        number: { value: 0 },
                        move: {
                            enable: true,
                            speed: speed,
                            direction: 'random',
                            outModes: 'out'
                        },
                        opacity: {
                            value: {min: 0.3, max: 0.7}
                        },
                        size: {
                            value: {min: 1, max: 5}
                        },
                        color: {
                            value: colors
                        },
                        shape: {
                            type: particleShape
                        },
                        life: {
                            duration: {min: 1, max: duration/1000}
                        }
                    },
                    emitters: {
                        direction: 'random',
                        position: {
                            x: 50,
                            y: 50
                        },
                        rate: {
                            delay: 0.1,
                            quantity: 5
                        },
                        size: {
                            width: 100,
                            height: 100
                        },
                        life: {
                            duration: duration/1000 - 0.5,
                            count: 1
                        }
                    }
                };
                
                const container = await window.tsParticles.load('cosmic-effects-layer', config);
                setTimeout(() => {
                    try { container?.destroy(); } catch {}
                }, duration);
                
                return container;
            } catch(e) {
                console.error('horseman effect error:', e);
                return null;
            }
        }
        
        async showConfluenceEffect(position, signalType, duration=1500) {
            try {
                if (!this.checkCooldown('confluence')) return null;
                
                await this.ensureTsParticles();
                
                // Sinyal tipine g√∂re renkleri belirle
                let colors;
                if (signalType === 'BUY') {
                    colors = ['#22c55e', '#16a34a', '#15803d']; // Ye≈üil tonlarƒ±
                } else if (signalType === 'SELL') {
                    colors = ['#ef4444', '#dc2626', '#b91c1c']; // Kƒ±rmƒ±zƒ± tonlarƒ±
                } else {
                    colors = ['#3b82f6', '#2563eb', '#1d4ed8']; // Mavi tonlarƒ± (n√∂tr/bilgi)
                }
                
                // Pozisyon bilgisi
                const x = position?.x || 50;
                const y = position?.y || 50;
                
                // Efekt konfig√ºrasyonu
                const config = {
                    background: { color: 'transparent' },
                    fullScreen: { enable: false },
                    particles: { number: { value: 0 } },
                    emitters: {
                        position: { x, y },
                        rate: { delay: 0.01, quantity: 20 },
                        life: { duration: duration/1000, count: 1 },
                        particles: {
                            move: { 
                                enable: true, 
                                speed: {min: 3, max: 7},
                                outModes: 'destroy',
                                direction: 'none',
                                gravity: { 
                                    enable: true,
                                    acceleration: 0.2
                                },
                                trail: {
                                    enable: true,
                                    fillColor: '#000',
                                    length: 4
                                }
                            },
                            color: { value: colors },
                            shape: { type: 'circle' },
                            size: { value: {min: 2, max: 5} },
                            opacity: { 
                                value: {min: 0.4, max: 0.8},
                                animation: {
                                    enable: true,
                                    speed: 1,
                                    minimumValue: 0,
                                    destroy: 'min'
                                }
                            },
                            life: { duration: {min: 0.5, max: 1.5} },
                            rotate: {
                                enable: true,
                                value: {
                                    min: 0,
                                    max: 360
                                },
                                animation: {
                                    enable: true,
                                    speed: 5
                                }
                            },
                            shadow: { 
                                enable: true, 
                                blur: 5,
                                color: colors[0]
                            }
                        }
                    }
                };
                
                const container = await window.tsParticles.load('cosmic-effects-layer', config);
                setTimeout(() => {
                    try { container?.destroy(); } catch {}
                }, duration);
                
                return container;
            } catch(e) {
                console.error('confluence effect error:', e);
                return null;
            }
        }
    }
    
    // IndexedDB yardƒ±mcƒ±larƒ± - Panteon i√ßin
    async function openDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open('coinank_data', 2);
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                
                // Panteon durumu i√ßin object store
                if (!db.objectStoreNames.contains('panteon_state')) {
                    db.createObjectStore('panteon_state');
                }
                
                // Diƒüer store'lar burada eklenebilir
            };
            
            request.onsuccess = (event) => {
                resolve({
                    db: event.target.result,
                    get: async (store, key) => {
                        return new Promise((resolve, reject) => {
                            const transaction = event.target.result.transaction(store, 'readonly');
                            const objectStore = transaction.objectStore(store);
                            const getRequest = objectStore.get(key);
                            
                            getRequest.onsuccess = () => {
                                resolve(getRequest.result);
                            };
                            
                            getRequest.onerror = (error) => {
                                reject(error);
                            };
                        });
                    },
                    put: async (store, value, key) => {
                        return new Promise((resolve, reject) => {
                            const transaction = event.target.result.transaction(store, 'readwrite');
                            const objectStore = transaction.objectStore(store);
                            const putRequest = objectStore.put(value, key);
                            
                            putRequest.onsuccess = () => {
                                resolve(putRequest.result);
                            };
                            
                            putRequest.onerror = (error) => {
                                reject(error);
                            };
                        });
                    },
                    delete: async (store, key) => {
                        return new Promise((resolve, reject) => {
                            const transaction = event.target.result.transaction(store, 'readwrite');
                            const objectStore = transaction.objectStore(store);
                            const deleteRequest = objectStore.delete(key);
                            
                            deleteRequest.onsuccess = () => {
                                resolve();
                            };
                            
                            deleteRequest.onerror = (error) => {
                                reject(error);
                            };
                        });
                    }
                });
            };
            
            request.onerror = (event) => {
                reject(event.target.error);
            };
        });
    }
    
    // Panteon Bootstrap
    async function bootstrapPantheon() {
        if(!('indexedDB' in window)) {
            console.error('IndexedDB desteklenmiyor. Ge√ßici bellek modu.');
        }
        
        const db = DBManager.instance;
        await db.open();
        
        // ƒ∞lk I≈üƒ±k Efekti
        const fx = new EffectsManager();
        await fx.firstLight(2200);
        
        // UI mitolojik isimlendirme (buton/metin g√ºncellemeleri)
        const renameUI = () => {
            const honorBtn = document.getElementById('honor-board-btn'); 
            if(honorBtn) honorBtn.textContent = 'Panteon';
            
            const bannedBtn = document.getElementById('banned-board-btn'); 
            if(bannedBtn) bannedBtn.textContent = 'Zindan';
            
            const saveBtn = document.getElementById('save-settings-btn'); 
            if(saveBtn) saveBtn.textContent = 'Kaderi M√ºh√ºrle';
            
            const resetBtn = document.getElementById('reset-all-settings-btn'); 
            if(resetBtn) resetBtn.textContent = 'Evreni Sƒ±fƒ±rla';
            
            const mobileHonor = document.getElementById('mobile-honor-board-btn'); 
            if(mobileHonor) mobileHonor.textContent = 'üèõÔ∏è';
            
            const mobileBanned = document.getElementById('mobile-banned-board-btn'); 
            if(mobileBanned) mobileBanned.textContent = 'ZDN';
            
            const settingsTitle = document.querySelector('.settings-modal-header span'); 
            if(settingsTitle) settingsTitle.textContent = 'AMELƒ∞YATHANE & OPTƒ∞Mƒ∞ZASYON';
            
            const clearSignals = document.getElementById('modal-clear-signals-btn'); 
            if(clearSignals) clearSignals.textContent = 'Kurban Et';
        };
        
        // Panteon panelini persist edilen deƒüerlerle ba≈ülat
        const initPanteonPanel = async () => {
            const state = await db.getPanteonState();
            const envEl = document.getElementById('pp-env'); 
            if(envEl) envEl.textContent = state.env?.version || 'v3.2';
            
            const setAmb = (id, data) => {
                const root = document.getElementById(id);
                if(!root) return;
                
                const rep = root.querySelector('.pp-rep'); 
                if(rep) {
                    rep.textContent = String(data.reputation ?? 0);
                    rep.dataset.rep = String(data.reputation ?? 0);
                }
                
                const mode = root.querySelector('.pp-mode'); 
                if(mode) {
                    mode.textContent = data.mode || 'ƒ∞nan√ßlƒ±';
                    mode.dataset.mode = data.mode || 'ƒ∞nan√ßlƒ±';
                }
            };
            
            setAmb('amb-metatron', state.ambassadors?.Metatron || { reputation: 0, mode: 'ƒ∞nan√ßlƒ±' });
            setAmb('amb-uriel', state.ambassadors?.Uriel || { reputation: 0, mode: 'ƒ∞nan√ßlƒ±' });
            setAmb('amb-raphael', state.ambassadors?.Raphael || { reputation: 0, mode: 'ƒ∞nan√ßlƒ±' });
        };
        
        initPanteonPanel();
        renameUI();
        
        // Global export
        window.Pantheon = {
            db,
            effects: new EffectsManager()
        };
    }
    
    // Kehanet Paneli Sƒ±nƒ±fƒ± - Piyasa Tahmini ve Analizi
    class KehanetPanel {
        constructor() {
            this.panel = document.getElementById('kehanet-panel');
            this.expandBtn = document.getElementById('kp-expand-btn');
            this.refreshBtn = document.getElementById('kp-refresh-btn');
            this.confidenceFill = document.getElementById('kp-confidence-fill');
            this.confidenceLabel = document.getElementById('kp-confidence-label');
            this.miniChart = document.getElementById('kp-mini-chart');
            
            this.elements = {
                regime: document.getElementById('kp-regime'),
                session: document.getElementById('kp-session'),
                guardian: document.getElementById('kp-guardian'),
                pulse: document.getElementById('kp-pulse'),
                trend: document.getElementById('kp-trend'),
                prediction: document.getElementById('kp-prediction'),
                probability: document.getElementById('kp-probability'),
                timeframe: document.getElementById('kp-timeframe'),
                liquidity: document.getElementById('kp-liquidity'),
                pressure: document.getElementById('kp-pressure')
            };
            
            this.predictions = {
                trend: null,
                direction: null,
                probability: 0,
                timeTarget: null,
                confidence: 0,
                lastUpdate: null,
                supportLevels: [],
                resistanceLevels: []
            };
            
            this.marketData = {
                price: 0,
                volume: 0,
                atr: 0,
                regime: '‚Äî',
                liquidityImbalance: 0
            };
            
            this.isExpanded = false;
            this.chart = null;
            
            this.init();
        }
        
        init() {
            this.bindEvents();
            this.initMiniChart();
            this.loadPanelState();
            
            // ƒ∞lk senkronizasyonu ba≈ülat
            this.sync();
            
            // D√ºzenli g√ºncelleme aralƒ±ƒüƒ±
            setInterval(() => this.sync(), 1500);
            
            // Her 5 dakikada bir yeni tahmin olu≈ütur
            setInterval(() => this.generatePrediction(), 5 * 60 * 1000);
            
            // ƒ∞lk tahmini olu≈ütur
            this.generatePrediction();
            
            console.log('Kehanet Paneli ba≈ülatƒ±ldƒ±');
        }
        
        bindEvents() {
            // Panel geni≈ületme/daraltma d√ºƒümesi
            if (this.expandBtn) {
                this.expandBtn.addEventListener('click', () => {
                    this.togglePanelExpand();
                });
            }
            
            // Tahmin yenileme d√ºƒümesi
            if (this.refreshBtn) {
                this.refreshBtn.addEventListener('click', () => {
                    this.generatePrediction(true);
                });
            }
            
            // Piyasa olaylarƒ±na abone ol
            if (window.app) {
                // Piyasa rejimi deƒüi≈ütiƒüinde
                window.app.on('marketRegimeChanged', (regime) => {
                    this.marketData.regime = regime;
                    this.generatePrediction();
                });
                
                // Yeni mum olu≈ütuƒüunda
                window.app.on('newCandle', (candle) => {
                    this.updateMiniChart(candle);
                });
            }
        }
        
        sync() {
            if (!window.app) return;
            
            // Temel veriler
            const regime = window.app.marketRegime || '‚Äî';
            const session = window.app.sessionState || '‚Äî';
            const guardian = (window.app.settings?.features?.enableRiskGuardian) ? 'Aktif' : 'Pasif';
            
            // ATR (Average True Range) hesaplama
            const atr = window.app.indicators?.atr || 0;
            const price = window.app.marketData?.price || 0;
            const atrPct = (atr && price) ? (atr / price) : 0;
            const pulse = atrPct ? `${(atrPct*100).toFixed(2)}%` : '‚Äî';
            
            // T√ºm piyasa verilerini g√ºncelle
            this.marketData = {
                price: price,
                volume: window.app.marketData?.volume || 0,
                atr: atr,
                regime: regime,
                liquidityImbalance: this.calculateLiquidityImbalance()
            };
            
            // Temel bilgileri g√ºncelle
            this.updateElement('regime', regime);
            this.updateElement('session', session);
            this.updateElement('guardian', guardian);
            this.updateElement('pulse', pulse);
            
            // Eƒüilim bilgisini g√ºncelle
            const trend = this.determineTrend();
            this.updateElement('trend', trend);
            
            // Geli≈ümi≈ü panel deƒüerlerini g√ºncelle (tahminlere dayalƒ±)
            this.updateAdvancedPanelValues();
        }
        
        updateElement(key, value) {
            const element = this.elements[key];
            if (element) {
                element.textContent = value;
                
                // Bazƒ± deƒüerler i√ßin renk sƒ±nƒ±flarƒ±nƒ± g√ºncelle
                if (key === 'trend') {
                    element.className = 'kp-val'; // Reset
                    if (value.includes('Y√ºkseli≈ü')) {
                        element.classList.add('trend-up');
                    } else if (value.includes('D√º≈ü√º≈ü')) {
                        element.classList.add('trend-down');
                    } else if (value.includes('Yatay')) {
                        element.classList.add('trend-neutral');
                    }
                }
            }
        }
        
        togglePanelExpand() {
            this.isExpanded = !this.isExpanded;
            
            if (this.isExpanded) {
                this.panel.classList.add('kp-panel-expanded');
                // Mini grafiƒüi yeniden boyutlandƒ±r
                if (this.chart) {
                    this.chart.resize(280, 70);
                }
            } else {
                this.panel.classList.remove('kp-panel-expanded');
            }
            
            // Panel durumunu kaydet
            localStorage.setItem('kehanet_panel_expanded', this.isExpanded);
        }
        
        loadPanelState() {
            const savedState = localStorage.getItem('kehanet_panel_expanded');
            if (savedState === 'true') {
                this.isExpanded = true;
                this.panel.classList.add('kp-panel-expanded');
            }
        }
        
        determineTrend() {
            if (!window.app || !window.app.indicators) {
                return 'Belirsiz';
            }
            
            // Trend belirlemek i√ßin kullanƒ±labilecek g√∂stergeler
            const macd = window.app.indicators.macd;
            const rsi = window.app.indicators.rsi;
            const ema200 = window.app.indicators.ema200;
            const price = window.app.marketData?.price || 0;
            
            if (!macd || !rsi || !ema200 || !price) {
                return 'Veri Yok';
            }
            
            // MACD ve RSI'ye dayalƒ± trend belirleme
            let trendStrength = 0;
            
            // MACD trendi
            if (macd.histogram > 0 && macd.signal < macd.macd) {
                trendStrength += 1; // Y√ºkseli≈ü sinyali
            } else if (macd.histogram < 0 && macd.signal > macd.macd) {
                trendStrength -= 1; // D√º≈ü√º≈ü sinyali
            }
            
            // RSI trendi
            if (rsi > 60) {
                trendStrength += 1; // Y√ºkseli≈ü
            } else if (rsi < 40) {
                trendStrength -= 1; // D√º≈ü√º≈ü
            }
            
            // Fiyat ve EMA200 ili≈ükisi
            if (price > ema200) {
                trendStrength += 1; // Uzun vadeli y√ºkseli≈ü
            } else if (price < ema200) {
                trendStrength -= 1; // Uzun vadeli d√º≈ü√º≈ü
            }
            
            // Son trendi belirle
            if (trendStrength >= 2) {
                return '‚ÜóÔ∏è Y√ºkseli≈ü';
            } else if (trendStrength <= -2) {
                return '‚ÜòÔ∏è D√º≈ü√º≈ü';
            } else {
                return '‚ÜîÔ∏è Yatay';
            }
        }
        
        calculateLiquidityImbalance() {
            // Emir defteri verilerini al (eƒüer mevcutsa)
            if (!window.app || !window.app.orderbook) {
                return 0;
            }
            
            const asks = window.app.orderbook.asks || [];
            const bids = window.app.orderbook.bids || [];
            
            if (asks.length === 0 || bids.length === 0) {
                return 0;
            }
            
            // En iyi 5 seviyenin toplam likidite hacmini hesapla
            let totalAskVolume = 0;
            let totalBidVolume = 0;
            
            for (let i = 0; i < Math.min(5, asks.length); i++) {
                totalAskVolume += asks[i].quantity;
            }
            
            for (let i = 0; i < Math.min(5, bids.length); i++) {
                totalBidVolume += bids[i].quantity;
            }
            
            // Likidite dengesizliƒüi hesapla (-1 ile 1 arasƒ±nda)
            const totalVolume = totalAskVolume + totalBidVolume;
            if (totalVolume === 0) return 0;
            
            return (totalBidVolume - totalAskVolume) / totalVolume;
        }
        
        initMiniChart() {
            if (!this.miniChart) return;
            
            try {
                // LightweightCharts'ƒ± kullanarak mini grafik olu≈ütur
                this.chart = LightweightCharts.createChart(this.miniChart, {
                    width: 280,
                    height: 70,
                    layout: {
                        background: { type: 'solid', color: 'transparent' },
                        textColor: 'rgba(255, 255, 255, 0.5)',
                    },
                    grid: {
                        vertLines: { color: 'rgba(42, 46, 57, 0)' },
                        horzLines: { color: 'rgba(42, 46, 57, 0.2)' },
                    },
                    timeScale: {
                        visible: false
                    },
                    rightPriceScale: {
                        visible: false
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal,
                        vertLine: { visible: false },
                        horzLine: { visible: false }
                    },
                    handleScale: false,
                    handleScroll: false
                });
                
                // Fiyat serisini olu≈ütur
                this.priceSeries = this.chart.addAreaSeries({
                    topColor: 'rgba(33, 150, 243, 0.56)',
                    bottomColor: 'rgba(33, 150, 243, 0.04)',
                    lineColor: 'rgba(33, 150, 243, 1)',
                    lineWidth: 2
                });
                
                // Ba≈ülangƒ±√ß verileri (son 10 mum)
                const initialData = this.getInitialChartData();
                this.priceSeries.setData(initialData);
                
            } catch (error) {
                console.error('Mini grafik olu≈üturma hatasƒ±:', error);
            }
        }
        
        getInitialChartData() {
            // App'den ge√ßmi≈ü verileri al veya varsayƒ±lan olu≈ütur
            if (window.app && window.app.candles && window.app.candles.length > 0) {
                return window.app.candles.slice(-10).map(candle => ({
                    time: candle.time / 1000, // Unix zaman damgasƒ±
                    value: candle.close
                }));
            }
            
            // Varsayƒ±lan veriler
            const data = [];
            const now = Math.floor(Date.now() / 1000);
            const price = 20000; // Varsayƒ±lan fiyat
            
            for (let i = 9; i >= 0; i--) {
                data.push({
                    time: now - i * 60,
                    value: price + Math.random() * 500 - 250
                });
            }
            
            return data;
        }
        
        updateMiniChart(candle) {
            if (!this.priceSeries || !candle) return;
            
            // Yeni mumu grafiƒüe ekle
            this.priceSeries.update({
                time: candle.time / 1000,
                value: candle.close
            });
        }
        
        generatePrediction(userTriggered = false) {
            if (!window.app) return;
            
            // Tahmin i√ßin gerekli verileri topla
            const price = window.app.marketData?.price || 0;
            const volume = window.app.marketData?.volume || 0;
            const regime = window.app.marketRegime || 'NORMAL';
            const indicators = window.app.indicators || {};
            
            // Eƒüer kullanƒ±cƒ± tetiklediyse, √∂zel efekt g√∂ster
            if (userTriggered) {
                this.showPredictionEffect();
            }
            
            // Tahmin algoritmasƒ±
            let direction = null;
            let probability = 0;
            let confidence = 0;
            
            // Trend belirle
            const trend = this.determineTrend();
            
            // Farklƒ± stratejilerin sinyallerini aƒüƒ±rlƒ±klandƒ±rarak topla
            const signals = this.aggregateSignals();
            
            // Y√∂n ve olasƒ±lƒ±k hesapla
            if (signals.bullish > signals.bearish) {
                direction = 'YUKARI';
                probability = Math.min(90, 50 + (signals.bullish - signals.bearish) * 5);
            } else if (signals.bearish > signals.bullish) {
                direction = 'A≈ûAƒûI';
                probability = Math.min(90, 50 + (signals.bearish - signals.bullish) * 5);
            } else {
                direction = 'YATAY';
                probability = 50;
            }
            
            // G√ºven seviyesi hesaplama
            confidence = this.calculateConfidence(signals, regime);
            
            // Destek/diren√ß seviyeleri hesaplama
            const levels = this.calculateSupportResistanceLevels(price);
            
            // Zaman hedefi (dakika cinsinden)
            const timeTarget = this.calculateTimeTarget(regime, signals.volatility);
            
            // Tahmin sonu√ßlarƒ±nƒ± g√ºncelle
            this.predictions = {
                trend: trend,
                direction: direction,
                probability: probability,
                timeTarget: timeTarget,
                confidence: confidence,
                lastUpdate: new Date(),
                supportLevels: levels.support,
                resistanceLevels: levels.resistance,
                liquidityImbalance: this.marketData.liquidityImbalance
            };
            
            // UI'ƒ± g√ºncelle
            this.updateAdvancedPanelValues();
            this.updateConfidenceBar(confidence);
            
            return this.predictions;
        }
        
        aggregateSignals() {
            if (!window.app || !window.app.indicators) {
                return { bullish: 0, bearish: 0, neutral: 0, volatility: 0 };
            }
            
            const ind = window.app.indicators;
            let bullish = 0;
            let bearish = 0;
            let neutral = 0;
            let volatility = 0;
            
            // MACD sinyalleri
            if (ind.macd) {
                if (ind.macd.histogram > 0 && ind.macd.histogram > ind.macd.histogramPrev) {
                    bullish += 2;
                } else if (ind.macd.histogram < 0 && ind.macd.histogram < ind.macd.histogramPrev) {
                    bearish += 2;
                } else {
                    neutral += 1;
                }
            }
            
            // RSI sinyalleri
            if (ind.rsi) {
                if (ind.rsi > 70) {
                    bearish += 1; // A≈üƒ±rƒ± alƒ±m
                } else if (ind.rsi < 30) {
                    bullish += 1; // A≈üƒ±rƒ± satƒ±m
                } else if (ind.rsi > 55) {
                    bullish += 0.5;
                } else if (ind.rsi < 45) {
                    bearish += 0.5;
                } else {
                    neutral += 1;
                }
            }
            
            // Bollinger Bandƒ± sinyalleri
            if (ind.bb && window.app.marketData?.price) {
                const price = window.app.marketData.price;
                if (price > ind.bb.upper) {
                    bearish += 1.5; // √úst banda dokunma
                } else if (price < ind.bb.lower) {
                    bullish += 1.5; // Alt banda dokunma
                } else if (price > ind.bb.middle) {
                    bullish += 0.5;
                } else if (price < ind.bb.middle) {
                    bearish += 0.5;
                }
                
                // Volatilite hesaplama (bant geni≈üliƒüi)
                volatility = (ind.bb.upper - ind.bb.lower) / ind.bb.middle;
            }
            
            // Hareketli ortalama sinyalleri
            if (ind.ema9 && ind.ema21 && ind.ema55) {
                if (ind.ema9 > ind.ema21 && ind.ema21 > ind.ema55) {
                    bullish += 2; // G√º√ßl√º y√ºkseli≈ü trendi
                } else if (ind.ema9 < ind.ema21 && ind.ema21 < ind.ema55) {
                    bearish += 2; // G√º√ßl√º d√º≈ü√º≈ü trendi
                } else if (ind.ema9 > ind.ema21) {
                    bullish += 0.5;
                } else if (ind.ema9 < ind.ema21) {
                    bearish += 0.5;
                }
            }
            
            // Hacim analizi
            if (window.app.marketData?.volume && window.app.marketData?.volumeAvg) {
                const volumeRatio = window.app.marketData.volume / window.app.marketData.volumeAvg;
                
                if (volumeRatio > 1.5 && bullish > bearish) {
                    bullish += volumeRatio - 1; // Hacim artƒ±≈üƒ± ile birlikte alƒ±m sinyali g√º√ßlenir
                } else if (volumeRatio > 1.5 && bearish > bullish) {
                    bearish += volumeRatio - 1; // Hacim artƒ±≈üƒ± ile birlikte satƒ±m sinyali g√º√ßlenir
                }
            }
            
            // ATR (volatilite g√∂stergesi)
            if (ind.atr && window.app.marketData?.price) {
                const atrPct = ind.atr / window.app.marketData.price;
                volatility += atrPct * 100; // Volatiliteyi y√ºzde olarak ekle
            }
            
            return { bullish, bearish, neutral, volatility };
        }
        
        calculateConfidence(signals, regime) {
            // G√ºven seviyesi hesaplama (0-100 arasƒ±nda)
            const totalSignals = signals.bullish + signals.bearish + signals.neutral;
            if (totalSignals === 0) return 50;
            
            // Dominant sinyalin g√ºc√º
            const dominantForce = Math.max(signals.bullish, signals.bearish);
            const dominantRatio = dominantForce / totalSignals;
            
            // Volatilite fakt√∂r√º
            const volatilityFactor = Math.max(0, Math.min(1, 2 - signals.volatility / 5));
            
            // Rejim fakt√∂r√º
            let regimeFactor = 1;
            if (regime === 'KITLIK') regimeFactor = 0.9; // D√º≈ü√ºk volatilite, tahminler daha zor
            if (regime === 'SALGIN') regimeFactor = 0.7; // Kaotik piyasa, tahminler √ßok zor
            if (regime === 'SAVA≈û') regimeFactor = 1.1; // Trendli piyasa, tahminler daha kolay
            if (regime === '√ñL√úM') regimeFactor = 0.5; // Ekstrem olaylar, tahminler √ßok zor
            
            // G√ºven seviyesi
            const confidence = dominantRatio * 100 * volatilityFactor * regimeFactor;
            
            return Math.min(95, Math.max(5, Math.round(confidence)));
        }
        
        calculateSupportResistanceLevels(currentPrice) {
            if (!currentPrice) return { support: [], resistance: [] };
            
            // Son fiyat hareketlerine dayalƒ± pivot noktalarƒ± hesaplama
            const candles = window.app?.candles || [];
            if (candles.length < 10) {
                // Varsayƒ±lan seviyeler (basitle≈ütirilmi≈ü)
                return {
                    support: [currentPrice * 0.99, currentPrice * 0.98, currentPrice * 0.97],
                    resistance: [currentPrice * 1.01, currentPrice * 1.02, currentPrice * 1.03]
                };
            }
            
            // Ge√ßmi≈ü fiyat verilerinden pivot noktalarƒ± bulma
            const pivots = this.findPivotPoints(candles);
            const atr = window.app.indicators?.atr || (currentPrice * 0.01);
            
            // Mevcut fiyata g√∂re destek ve diren√ß seviyelerini filtrele
            const support = pivots.filter(p => p < currentPrice).sort((a, b) => b - a).slice(0, 3);
            const resistance = pivots.filter(p => p > currentPrice).sort((a, b) => a - b).slice(0, 3);
            
            // Eƒüer yeterli seviye bulunamadƒ±ysa, ATR'ye dayalƒ± seviyeler ekle
            while (support.length < 3) {
                const lastSupport = support.length > 0 ? support[support.length - 1] : currentPrice;
                support.push(lastSupport - atr);
            }
            
            while (resistance.length < 3) {
                const lastResistance = resistance.length > 0 ? resistance[resistance.length - 1] : currentPrice;
                resistance.push(lastResistance + atr);
            }
            
            return { support, resistance };
        }
        
        findPivotPoints(candles) {
            const pivots = [];
            const lookback = Math.min(candles.length, 100); // Son 100 mum
            
            // Basit pivot noktalarƒ± (y√ºksek ve d√º≈ü√ºk noktalar)
            for (let i = 5; i < lookback - 5; i++) {
                const isHighPivot = candles[i].high > candles[i-1].high && 
                                   candles[i].high > candles[i-2].high &&
                                   candles[i].high > candles[i+1].high && 
                                   candles[i].high > candles[i+2].high;
                
                const isLowPivot = candles[i].low < candles[i-1].low && 
                                  candles[i].low < candles[i-2].low &&
                                  candles[i].low < candles[i+1].low && 
                                  candles[i].low < candles[i+2].low;
                
                if (isHighPivot) pivots.push(candles[i].high);
                if (isLowPivot) pivots.push(candles[i].low);
            }
            
            // Yakƒ±n pivot noktalarƒ±nƒ± birle≈ütir
            const uniquePivots = [];
            const tolerance = window.app.indicators?.atr || 0;
            
            pivots.forEach(pivot => {
                // Benzer bir pivot noktasƒ± var mƒ± kontrol et
                const similarPivot = uniquePivots.find(p => Math.abs(p - pivot) < tolerance);
                if (!similarPivot) {
                    uniquePivots.push(pivot);
                }
            });
            
            return uniquePivots;
        }
        
        calculateTimeTarget(regime, volatility) {
            // Zaman hedefi (dakika cinsinden) hesaplama
            let baseTime = 30; // Varsayƒ±lan 30 dakika
            
            // Rejime g√∂re ayarla
            if (regime === 'KITLIK') baseTime = 60; // Yatay piyasada daha uzun s√ºrer
            if (regime === 'SALGIN') baseTime = 15; // Dalgalƒ± piyasada daha hƒ±zlƒ± deƒüi≈üir
            if (regime === 'SAVA≈û') baseTime = 45; // Trend devam edecek
            if (regime === '√ñL√úM') baseTime = 10; // √áok hƒ±zlƒ± deƒüi≈üimler
            
            // Volatiliteye g√∂re ayarla
            const volatilityFactor = Math.max(0.5, Math.min(2, 1 + volatility / 10));
            const targetMinutes = Math.round(baseTime / volatilityFactor);
            
            return targetMinutes;
        }
        
        updateAdvancedPanelValues() {
            // Tahmin y√∂n√º
            this.updateElement('prediction', this.predictions.direction || '‚Äî');
            
            // Olasƒ±lƒ±k
            const probability = this.predictions.probability ? `%${this.predictions.probability}` : '‚Äî';
            this.updateElement('probability', probability);
            
            // Zaman hedefi
            const timeframe = this.predictions.timeTarget ? `${this.predictions.timeTarget} dk` : '‚Äî';
            this.updateElement('timeframe', timeframe);
            
            // Likidite
            const liquidityImbalance = this.marketData.liquidityImbalance;
            let liquidityText = '‚Äî';
            
            if (liquidityImbalance > 0.2) {
                liquidityText = 'üü¢ Alƒ±m Baskƒ±sƒ±';
            } else if (liquidityImbalance < -0.2) {
                liquidityText = 'üî¥ Satƒ±≈ü Baskƒ±sƒ±';
            } else if (liquidityImbalance !== 0) {
                liquidityText = '‚ö™ Dengeli';
            }
            
            this.updateElement('liquidity', liquidityText);
            
            // Baskƒ± g√∂stergesi
            let pressureText = '‚Äî';
            if (window.app && window.app.indicators && window.app.indicators.rsi) {
                const rsi = window.app.indicators.rsi;
                if (rsi > 75) {
                    pressureText = 'üî¥ A≈üƒ±rƒ± Alƒ±m';
                } else if (rsi > 60) {
                    pressureText = 'üü† Y√ºksek';
                } else if (rsi < 25) {
                    pressureText = 'üîµ A≈üƒ±rƒ± Satƒ±m';
                } else if (rsi < 40) {
                    pressureText = 'üî∑ D√º≈ü√ºk';
                } else {
                    pressureText = '‚ö™ Normal';
                }
            }
            
            this.updateElement('pressure', pressureText);
        }
        
        updateConfidenceBar(confidence) {
            if (this.confidenceFill && this.confidenceLabel) {
                this.confidenceFill.style.width = `${confidence}%`;
                this.confidenceLabel.textContent = `G√ºven: %${confidence}`;
                
                // Renk deƒüi≈üimi
                if (confidence < 30) {
                    this.confidenceFill.style.background = 'linear-gradient(90deg, var(--danger) 0%, var(--warning) 100%)';
                } else if (confidence < 60) {
                    this.confidenceFill.style.background = 'linear-gradient(90deg, var(--warning) 0%, var(--info) 100%)';
                } else {
                    this.confidenceFill.style.background = 'linear-gradient(90deg, var(--info) 0%, var(--success) 100%)';
                }
            }
        }
        
        showPredictionEffect() {
            // Tahmin yenileme efekti
            if (this.panel) {
                this.panel.classList.add('prediction-refresh');
                setTimeout(() => {
                    this.panel.classList.remove('prediction-refresh');
                }, 1000);
            }
            
            // √ñzel efekt (tsParticles kullanarak)
            if (window.Pantheon && window.Pantheon.effects) {
                window.Pantheon.effects.showPredictionEffect();
            }
        }
    }
    
    // Kehanet Paneli JS Fonksiyonu
    const initKehanetPanel = () => {
        // Kehanet Panelini olu≈ütur ve ba≈ülat
        window.kehanetPanel = new KehanetPanel();
    };
    
    // Sayfa y√ºklenince Panteon ve Kehanet Panelini ba≈ülat
    document.addEventListener('DOMContentLoaded', async () => {
        try {
            // Panteon sistemini ba≈ülat - ABM (Ajan Tabanlƒ± Modelleme) ile yeni versiyonu ba≈ülat
            window.pantheonSystem = new PantheonSystem();
            
            // Panteon olaylarƒ±nƒ± dinle
            document.addEventListener('pantheon:state_change', (event) => {
                console.log('Panteon Durum Deƒüi≈üikliƒüi:', event.detail);
                // Burada durum deƒüi≈üikliƒüini UI'da g√∂sterebilir veya ba≈üka i≈ülemler yapabilirsiniz
            });
            
            document.addEventListener('pantheon:decision', (event) => {
                console.log('Panteon Kararƒ±:', event.detail);
                
                // Karar UI'da g√∂sterme
                const decision = event.detail;
                showNotification(
                    `El√ßiler Konseyi: ${decision.recommendation}`,
                    `G√ºven: ${decision.confidence.toFixed(1)}% | Risk: ${(decision.riskLevel * 100).toFixed(1)}%`,
                    decision.recommendation === 'ATAK' ? 'success' : 
                    decision.recommendation === 'GERƒ∞√áEKƒ∞L' ? 'error' : 'info',
                    5000
                );
            });
            
            document.addEventListener('pantheon:revelation', (event) => {
                console.log('Metatron Vahiy:', event.detail);
                showNotification(
                    'Metatron\'un Vahyi',
                    `√ñng√∂r√º G√ºc√º: ${event.detail.power.toFixed(1)}%`,
                    'info',
                    4000
                );
            });
            
            document.addEventListener('pantheon:valor', (event) => {
                console.log('Uriel Cesaret:', event.detail);
                showNotification(
                    'Uriel\'in Cesareti',
                    `Cesaret G√ºc√º: ${event.detail.power.toFixed(1)}%`,
                    'warning',
                    4000
                );
            });
            
            // Kehanet panelini ba≈ülat
            initKehanetPanel();
            
            // App hazƒ±r olduƒüunda window.app'e veri eri≈üimini enjekte et
            const ensureInject = setInterval(() => {
                if(window.app && window.Pantheon) {
                    clearInterval(ensureInject);
                }
            }, 100);
        } catch(e) {
            console.error('Panteon bootstrap hatasƒ±:', e);
        }
    });
    
    // √ñnemli sƒ±nƒ±flarƒ± √∂nce tanƒ±mla (PantheonSystem)
    /**
     * PantheonSystem - Ajan Tabanlƒ± Modelleme yakla≈üƒ±mƒ±yla geli≈ütirilmi≈ü,
     * stratejileri kategorize eden ve kararlarƒ± etkileyen akƒ±llƒ± sistem
     */
    class PantheonSystem {
        constructor() {
            // El√ßi ajanlarƒ±nƒ± tanƒ±mla (her biri otonomdur ve kendi durumuna sahiptir)
            this.ambassadors = {
                metatron: {
                    name: 'Metatron',
                    role: 'wisdom',
                    displayName: 'Metatron',
                    archetype: 'Bilgelik, Analiz',
                    color: 'var(--metatron-color)',
                    
                    // ABM - Ajan Durumu (State)
                    state: {
                        reputation: 0,
                        mode: 'ƒ∞NAN√áLI', // ƒ∞NAN√áLI, ≈û√úPHECƒ∞, KIYAMET
                        confidence: 75,
                        power: 0, // Anlƒ±k g√º√ß/etki seviyesi (0-100)
                        active: true,
                        risk_appetite: 0.5, // 0-1 arasƒ± risk i≈ütahƒ±
                        confirmation_bias: 0.3, // Onaylama yanlƒ±lƒ±ƒüƒ±
                        mean_reversion_bias: 0, // Ortalamaya d√∂n√º≈ü yanlƒ±lƒ±ƒüƒ±
                        active_strategies: []
                    },
                    
                    // ABM - Ajan Davranƒ±≈üƒ± (Behavior Rules)
                    strategies: ['SupportResistanceStrategy', 'MeanReversionStrategy', 'OrderBookImbalanceStrategy'],
                    primaryDataSources: ['Price Levels', 'Order Book Depth', 'RSI'],
                    
                    // ABM - √áevresel Adaptasyon (Environmental Adaptation)
                    regimeAdaptation: {
                        'KITLIK': { risk_modifier: 1.2, weight_modifier: 1.3 }, // Yatay piyasada g√º√ßl√º
                        'SALGIN': { risk_modifier: 0.9, weight_modifier: 1.1 }, // Dalgalƒ± piyasada orta
                        'SAVA≈û': { risk_modifier: 0.7, weight_modifier: 0.8 },  // Trendli piyasada zayƒ±f
                        '√ñL√úM': { risk_modifier: 0.4, weight_modifier: 0.5 }    // √á√∂k√º≈üte √ßok zayƒ±f
                    }
                },
                
                uriel: {
                    name: 'Uriel',
                    role: 'courage',
                    displayName: 'Uriel',
                    archetype: 'Cesaret, Hƒ±z',
                    color: 'var(--uriel-color)',
                    
                    // ABM - Ajan Durumu (State)
                    state: {
                        reputation: 0,
                        mode: 'ƒ∞NAN√áLI',
                        confidence: 75,
                        power: 0,
                        active: true,
                        risk_appetite: 0.8,
                        trend_following_bias: 0.7,
                        aggression_level: 0.6,
                        active_strategies: []
                    },
                    
                    // ABM - Ajan Davranƒ±≈üƒ± (Behavior Rules)
                    strategies: ['BreakoutPatternStrategy', 'MomentumStrategy', 'TrendFollowingStrategy'],
                    primaryDataSources: ['Price Velocity', 'Volume Spikes', 'Volatility'],
                    
                    // ABM - √áevresel Adaptasyon (Environmental Adaptation)
                    regimeAdaptation: {
                        'KITLIK': { risk_modifier: 0.6, weight_modifier: 0.5 },  // Yatay piyasada zayƒ±f
                        'SALGIN': { risk_modifier: 0.8, weight_modifier: 0.7 },  // Dalgalƒ± piyasada orta
                        'SAVA≈û': { risk_modifier: 1.4, weight_modifier: 1.5 },   // Trendli piyasada √ßok g√º√ßl√º
                        '√ñL√úM': { risk_modifier: 1.2, weight_modifier: 1.1 }     // √á√∂k√º≈üte g√º√ßl√º
                    }
                },
                
                raphael: {
                    name: 'Raphael',
                    role: 'healing',
                    displayName: 'Raphael',
                    archetype: '≈ûifa, Denge',
                    color: 'var(--raphael-color)',
                    
                    // ABM - Ajan Durumu (State)
                    state: {
                        reputation: 0,
                        mode: 'ƒ∞NAN√áLI',
                        confidence: 75,
                        power: 0,
                        active: true,
                        risk_appetite: 0.4,
                        mean_reversion_bias: 0.8,
                        information_sensitivity: 0.5,
                        active_strategies: []
                    },
                    
                    // ABM - Ajan Davranƒ±≈üƒ± (Behavior Rules)
                    strategies: ['StatArbitrageStrategy', 'LiquidityGapStrategy', 'OverboughtOversoldStrategy'],
                    primaryDataSources: ['Correlations', 'Spreads', 'Order Flow'],
                    
                    // ABM - √áevresel Adaptasyon (Environmental Adaptation)
                    regimeAdaptation: {
                        'KITLIK': { risk_modifier: 0.9, weight_modifier: 1.0 },  // Yatay piyasada normal
                        'SALGIN': { risk_modifier: 1.3, weight_modifier: 1.4 },  // Dalgalƒ± piyasada √ßok g√º√ßl√º
                        'SAVA≈û': { risk_modifier: 0.5, weight_modifier: 0.4 },   // Trendli piyasada zayƒ±f
                        '√ñL√úM': { risk_modifier: 0.7, weight_modifier: 0.9 }     // √á√∂k√º≈üte orta
                    }
                },
                
                gabriel: {
                    name: 'Gabriel',
                    role: 'communication',
                    displayName: 'Gabriel',
                    archetype: 'ƒ∞leti≈üim, Bilgi',
                    color: 'var(--gabriel-color)',
                    
                    // ABM - Ajan Durumu (State)
                    state: {
                        reputation: 0,
                        mode: 'ƒ∞NAN√áLI',
                        confidence: 75,
                        power: 0,
                        active: true,
                        risk_appetite: 0.6,
                        information_sensitivity: 0.9,
                        social_influence: 0.7,
                        active_strategies: []
                    },
                    
                    // ABM - Ajan Davranƒ±≈üƒ± (Behavior Rules)
                    strategies: ['SmartMoneyStrategy', 'VolumeProfileStrategy', 'SentimentAnalysisStrategy'],
                    primaryDataSources: ['Volume', 'News Flow', 'Social Media Data'],
                    
                    // ABM - √áevresel Adaptasyon (Environmental Adaptation)
                    regimeAdaptation: {
                        'KITLIK': { risk_modifier: 0.8, weight_modifier: 0.7 },  // Yatay piyasada orta
                        'SALGIN': { risk_modifier: 0.7, weight_modifier: 0.8 },  // Dalgalƒ± piyasada orta
                        'SAVA≈û': { risk_modifier: 0.9, weight_modifier: 1.0 },   // Trendli piyasada normal
                        '√ñL√úM': { risk_modifier: 1.3, weight_modifier: 1.5 }     // √á√∂k√º≈üte √ßok g√º√ßl√º (haberler √∂nemli)
                    }
                },
                
                michael: {
                    name: 'Michael',
                    role: 'warfare',
                    displayName: 'Michael',
                    archetype: 'Sava≈ü, G√º√ß',
                    color: 'var(--michael-color)',
                    
                    // ABM - Ajan Durumu (State)
                    state: {
                        reputation: 0,
                        mode: 'ƒ∞NAN√áLI',
                        confidence: 75,
                        power: 0,
                        active: true,
                        risk_appetite: 0.9,
                        aggression_level: 0.8,
                        opportunistic_bias: 0.7,
                        active_strategies: []
                    },
                    
                    // ABM - Ajan Davranƒ±≈üƒ± (Behavior Rules)
                    strategies: ['AggressiveCandleStrategy', 'LiquidationCascadeStrategy', 'VolatilityBreakoutStrategy'],
                    primaryDataSources: ['Candle Patterns', 'Open Interest', 'Liquidation Data'],
                    
                    // ABM - √áevresel Adaptasyon (Environmental Adaptation)
                    regimeAdaptation: {
                        'KITLIK': { risk_modifier: 0.4, weight_modifier: 0.3 },  // Yatay piyasada √ßok zayƒ±f
                        'SALGIN': { risk_modifier: 0.6, weight_modifier: 0.7 },  // Dalgalƒ± piyasada orta
                        'SAVA≈û': { risk_modifier: 1.3, weight_modifier: 1.2 },   // Trendli piyasada g√º√ßl√º
                        '√ñL√úM': { risk_modifier: 1.5, weight_modifier: 1.6 }     // √á√∂k√º≈üte √ßok g√º√ßl√º
                    }
                }
            };
            
            // Yetenekler ve bekleme s√ºreleri
            this.abilities = {
                council: { cooldown: 60000, lastUsed: 0, description: 'T√ºm El√ßilerin bir araya gelerek kolektif karar almasƒ±' },
                reset: { cooldown: 300000, lastUsed: 0, description: 'ƒ∞tibar puanlarƒ±nƒ± sƒ±fƒ±rlama' },
                revelation: { cooldown: 45000, lastUsed: 0, description: 'Metatron\'un √∂ng√∂r√ºs√º' },
                valor: { cooldown: 30000, lastUsed: 0, description: 'Uriel\'in cesareti' },
                communication: { cooldown: 35000, lastUsed: 0, description: 'Gabriel\'in bilgi analizi ve sosyal medya taramasƒ±' },
                warfare: { cooldown: 25000, lastUsed: 0, description: 'Michael\'in agresif saldƒ±rƒ± analizi ve likidite avƒ±' }
            };
            
            // Sistem durum deƒüi≈ükenleri
            this.system = {
                initialized: false,
                currentRegime: 'NORMAL',
                collectiveState: 'Dengeli',
                confidenceThreshold: 65,
                lastUpdateTime: Date.now(),
                decayRate: 0.05, // Saniyede %0.05 g√º√ß azalmasƒ±
                usageHistory: [],
                version: '3.5'
            };
            
            // Sistemi ba≈ülat
            this.init();
        }
        
        async init() {
            if (this.system.initialized) return;
            
            try {
                // Kaydedilmi≈ü verileri y√ºkle
                await this.loadState();
                
                // UI elemanlarƒ±nƒ± bul ve olaylarƒ± baƒüla
                this.bindUI();
                
                // UI'ƒ± g√ºncelle
                this.updateUI();
                
                // D√ºzenli g√ºncelleme i√ßin zamanlayƒ±cƒ± ba≈ülat
                this.startUpdateLoop();
                
                this.system.initialized = true;
                console.log('Panteon Sistemi ba≈ülatƒ±ldƒ± (v' + this.system.version + ')');
            } catch (error) {
                console.error('Panteon Sistemi ba≈ülatƒ±lamadƒ±:', error);
            }
        }
        
        bindEvents() {
            // Kapatma butonu
            document.querySelector('.pantheon-close')?.addEventListener('click', (e) => {
                e.stopPropagation();
                const ui = document.getElementById('pantheon-ui');
                if (ui) {
                    ui.style.display = 'none';
                    localStorage.setItem('pantheonUIVisible', 'false');
                }
            });
            
            // Toggle butonu
            document.querySelector('.pantheon-toggle-btn')?.addEventListener('click', (e) => {
                e.stopPropagation();
                const content = document.querySelector('.pantheon-content');
                const btn = document.querySelector('.pantheon-toggle-btn');
                if (content && btn) {
                    const isVisible = content.style.display !== 'none';
                    content.style.display = isVisible ? 'none' : 'flex';
                    btn.textContent = isVisible ? '‚ñ≤' : '‚ñº';
                    localStorage.setItem('pantheonContentVisible', (!isVisible).toString());
                }
            });
            
            // Restore visibility state
            const shouldHideContent = localStorage.getItem('pantheonContentVisible') === 'false';
            if (shouldHideContent) {
                const content = document.querySelector('.pantheon-content');
                const btn = document.querySelector('.pantheon-toggle-btn');
                if (content && btn) {
                    content.style.display = 'none';
                    btn.textContent = '‚ñ≤';
                }
            }
            
            // Yetenek butonlarƒ±
            Object.keys(this.abilities).forEach(abilityId => {
                const abilityEl = document.querySelector(`.ability[data-ability="${abilityId}"]`);
                if (abilityEl) {
                    abilityEl.addEventListener('click', () => this.activateAbility(abilityId));
                }
            });
            
            // Tanrƒ± etkile≈üimleri
            document.querySelectorAll('.god').forEach(godEl => {
                const godName = godEl.dataset.god;
                if (godName && this.gods[godName]) {
                    godEl.addEventListener('click', () => this.onGodClick(godName));
                }
            });
        }
        
        loadPowers() {
            try {
                const savedPowers = JSON.parse(localStorage.getItem('pantheonPowers') || '{}');
                Object.keys(this.gods).forEach(godName => {
                    if (savedPowers[godName] !== undefined) {
                        this.gods[godName].power = Math.min(savedPowers[godName], this.gods[godName].maxPower);
                    }
                });
                this.updateUI();
            } catch (e) {
                console.error('G√º√ß deƒüerleri y√ºklenirken hata:', e);
            }
        }
        
        savePowers() {
            try {
                const powersToSave = {};
                Object.keys(this.gods).forEach(godName => {
                    powersToSave[godName] = this.gods[godName].power;
                });
                localStorage.setItem('pantheonPowers', JSON.stringify(powersToSave));
            } catch (e) {
                console.error('G√º√ß deƒüerleri kaydedilirken hata:', e);
            }
        }
        
        increasePantheonPower(godName, amount = 1) {
            if (!this.gods[godName]) return;
            
            const god = this.gods[godName];
            god.power = Math.min(god.power + amount, god.maxPower);
            
            // √ñzel efektler
            this.createPowerEffect(godName);
            
            // UI g√ºncelle
            this.updateUI();
            
            // Kaydet
            this.savePowers();
            
            // √ñzel yetenekler
            this.checkSpecialAbilities(godName);
            
            return god.power;
        }
        
        checkSpecialAbilities(godName) {
            const god = this.gods[godName];
            if (!god) return;
            
            // %100 g√º√ß √∂zel yeteneƒüi
            if (god.power >= god.maxPower) {
                this.triggerElciSpecialAbility(godName);
                god.power = 0; // G√ºc√º sƒ±fƒ±rla
                this.updateUI();
                this.savePowers();
            }
        }
        
        triggerElciSpecialAbility(godName) {
            const abilities = {
                metatron: () => this.activateRevelation(),
                uriel: () => this.activateValor(),
                raphael: () => this.activateRestoration(),
                gabriel: () => this.activateCommunication(),
                michael: () => this.activateJudgment()
            };
            
            if (abilities[godName]) {
                abilities[godName]();
                this.showNotification(`${this.getGodDisplayName(godName)} √∂zel yeteneƒüi aktive edildi!`, 'success');
            }
        }
        
        activateRevelation() {
            // Metatron - Vahiy: T√ºm stratejilerin doƒüruluk oranƒ±nƒ± ge√ßici olarak artƒ±r
            this.showNotification('Vahiy: Stratejilerin doƒüruluk oranƒ± arttƒ±!', 'divine');
            
            // I≈üƒ±k efekti olu≈ütur
            this.createFirstLightEffect();
            
            if (window.app) {
                // T√ºm aktif stratejiler i√ßin sinyal kalitesini ge√ßici olarak artƒ±r
                const strategies = window.app.strategies || {};
                const activeStrategies = window.app.settings?.activeStrategies || {};
                
                Object.keys(activeStrategies).forEach(key => {
                    if (activeStrategies[key] && strategies[key]) {
                        // Stratejilerin alfa deƒüerini artƒ±r (ge√ßici olarak)
                        if (window.app.strategyStats[key]?.overall) {
                            const originalAlpha = window.app.strategyStats[key].overall.alpha || 3;
                            window.app.strategyStats[key].overall.alpha = originalAlpha * 1.5;
                            
                            // 60 saniye sonra normale d√∂nd√ºr
                            setTimeout(() => {
                                window.app.strategyStats[key].overall.alpha = originalAlpha;
                            }, 60000);
                        }
                    }
                });
                
                // Metatron'a g√º√ß ekliyoruz
                this.increasePower('metatron', 20);
                
                window.app.speak("Vahiy g√ºc√º aktifle≈ütirildi. Stratejiler aydƒ±nlandƒ±.");
            }
        }
        
        activateValor() {
            // Uriel - Cesaret: Risk toleransƒ±nƒ± ge√ßici olarak artƒ±rƒ±r
            this.showNotification('Cesaret: Risk limitleri artƒ±rƒ±ldƒ±!', 'divine');
            
            if (window.app) {
                // Ge√ßici olarak daha agresif ticaret stratejisi
                const settings = window.app.settings || {};
                const originalRiskFactor = settings.riskFactor || 1.0;
                const originalLeverageLevel = settings.leverageLevel || 1.0;
                
                // Riski artƒ±r (ge√ßici olarak)
                window.app.settings.riskFactor = originalRiskFactor * 1.5;
                window.app.settings.leverageLevel = originalLeverageLevel * 1.2;
                
                // Sava≈ü modunu aktifle≈ütir
                if (!window.app.combatModeActive) {
                    window.app.activateCombatMode();
                }
                
                // 45 saniye sonra normale d√∂nd√ºr
                setTimeout(() => {
                    window.app.settings.riskFactor = originalRiskFactor;
                    window.app.settings.leverageLevel = originalLeverageLevel;
                }, 45000);
                
                // Uriel'e g√º√ß ekliyoruz
                this.increasePower('uriel', 15);
                
                window.app.speak("Cesaret g√ºc√º aktifle≈üti. Risk toleransƒ± arttƒ±!");
            }
        }
        
        activateRestoration() {
            // Raphael - ≈ûifa: Kayƒ±plarƒ± telafi etme ve iyile≈üme
            this.showNotification('≈ûifa: Kayƒ±plar telafi ediliyor ve stratejiler iyile≈ütiriliyor...', 'divine');
            
            if (window.app) {
                // T√ºm shadowbanned stratejileri yeniden rehabilite et
                const statusMaps = window.app.settings?.statusMaps || {};
                const shadowBanned = statusMaps.shadowBanned || {};
                
                Object.keys(shadowBanned).forEach(key => {
                    // Eƒüer g√∂lge yasaklƒ± ancak hard-banned deƒüilse
                    if (shadowBanned[key] && !statusMaps.hardBanned?.[key]) {
                        // ≈ûansa baƒülƒ± olarak rehabilite et
                        if (Math.random() < 0.5) {
                            window.app.toggleShadow(key); // G√∂lgeden √ßƒ±kar
                        }
                    }
                });
                
                // Sinyal ge√ßmi≈üinde son 3 kaybedilen sinyali siliyoruz
                let lossCount = 0;
                let signals = window.app.signals || [];
                
                // Sondan ba≈ülayarak en son kaybedilen 3 sinyali bul
                for (let i = signals.length - 1; i >= 0 && lossCount < 3; i--) {
                    if (signals[i].status === 'sl') {
                        signals[i].status = 'restored';
                        lossCount++;
                    }
                }
                
                // Raphael'e g√º√ß ekliyoruz
                this.increasePower('raphael', 10);
                
                window.app.speak("ƒ∞yile≈ütirme g√ºc√º aktif. Stratejiler rehabilite ediliyor!");
            }
        }
        
        activateCommunication() {
            // Gabriel - ƒ∞leti≈üim: Veri akƒ±≈üƒ±nƒ± ve sinyal iletimini iyile≈ütir
            this.showNotification('ƒ∞leti≈üim: Veri akƒ±≈üƒ± optimize edildi, sinyal kalitesi arttƒ±rƒ±ldƒ±!', 'divine');
            
            if (window.app) {
                // WebSocket baƒülantƒ±sƒ±nƒ± yeniden ba≈ülat (daha temiz veri akƒ±≈üƒ± i√ßin)
                if (window.app.socket && window.app.reconnect) {
                    window.app.reconnect();
                }
                
                // Sinyal filtreleme hassasiyetini ge√ßici olarak artƒ±r
                const originalNoiseThreshold = window.app.settings?.noiseThreshold || 0.5;
                window.app.settings.noiseThreshold = originalNoiseThreshold * 0.7; // Daha hassas filtreleme
                
                // 50 saniye sonra normale d√∂nd√ºr
                setTimeout(() => {
                    window.app.settings.noiseThreshold = originalNoiseThreshold;
                }, 50000);
                
                // Gabriel'e g√º√ß ekliyoruz
                this.increasePower('gabriel', 12);
                
                window.app.speak("ƒ∞leti≈üim g√ºc√º aktif. Sinyal g√ºr√ºlt√º filtreleme optimize edildi!");
            }
        }
        
        activateJudgment() {
            // Michael - Yargƒ±: D√º≈üman pozisyonlarƒ±nƒ± ortaya √ßƒ±kar ve piyasa adaletini saƒüla
            this.showNotification('Yargƒ±: D√º≈üman pozisyonlarƒ± tespit edildi! Kar≈üƒ± hamle yapƒ±lƒ±yor...', 'divine');
            
            if (window.app) {
                // En k√∂t√º performans g√∂steren stratejiyi tespit et ve cezalandƒ±r
                const strategyStats = window.app.strategyStats || {};
                let worstStrategy = null;
                let worstPerformance = Infinity;
                
                Object.keys(strategyStats).forEach(key => {
                    const stats = strategyStats[key]?.overall || {};
                    if (stats.contrib > 10) { // Yeterli veri varsa
                        const performance = stats.wins / (stats.wins + stats.losses || 1);
                        if (performance < worstPerformance) {
                            worstPerformance = performance;
                            worstStrategy = key;
                        }
                    }
                });
                
                if (worstStrategy) {
                    // En k√∂t√º stratejiyi g√∂lgeye al
                    window.app.toggleShadow(worstStrategy);
                    window.app.showNotification(`${window.app.strategies[worstStrategy].displayName} stratejisi adalete teslim edildi!`, 'warning');
                }
                
                // Piyasada d√º≈üman pozisyonlarƒ±nƒ± tespit et (fiyat hareketlerindeki anormallikleri bul)
                window.app.detectMarketManipulation();
                
                // Michael'a g√º√ß ekliyoruz
                this.increasePower('michael', 18);
                
                window.app.speak("Adalet g√ºc√º aktif. D√º≈üman pozisyonlarƒ± tespit edildi ve cezalandƒ±rƒ±ldƒ±!");
            }
        }
        
        // ƒ∞lk I≈üƒ±k efekti
        createFirstLightEffect() {
            // Ekrana parlak bir ƒ±≈üƒ±k efekti ekle
            const flash = document.createElement('div');
            flash.className = 'first-light-effect';
            flash.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: radial-gradient(circle at center, rgba(255,255,255,0.9), rgba(255,255,255,0) 70%);
                pointer-events: none;
                z-index: 9999;
                opacity: 0;
                animation: first-light-pulse 2s ease-out;
            `;
            
            const style = document.createElement('style');
            style.innerHTML = `
                @keyframes first-light-pulse {
                    0% { opacity: 0; }
                    10% { opacity: 0.9; }
                    100% { opacity: 0; }
                }
            `;
            
            document.head.appendChild(style);
            document.body.appendChild(flash);
            
            // Animasyon bitince kaldƒ±r
            flash.addEventListener('animationend', () => {
                flash.remove();
            });
        }
        
        // Tanrƒ± g√º√ß seviyesini artƒ±r
        increasePower(godName, amount) {
            if (!this.gods[godName]) return;
            
            // Mevcut g√ºc√º artƒ±r
            this.gods[godName].power = Math.min(100, this.gods[godName].power + amount);
            
            // UI g√ºncelle
            this.updateUI();
            
            // Efekt olu≈ütur
            for (let i = 0; i < 10; i++) {
                this.createPowerEffect(godName);
            }
            
            // G√º√ßleri kaydet
            this.savePowers();
        }
        
        activateAbility(abilityId) {
            const ability = this.abilities[abilityId];
            if (!ability) return;
            
            const now = Date.now();
            const cooldownLeft = (ability.lastUsed + ability.cooldown) - now;
            
            if (cooldownLeft > 0) {
                this.showNotification(`Bekleyin: ${(cooldownLeft/1000).toFixed(1)} saniye kaldƒ±`, 'warning');
                return;
            }
            
            // Yeteneƒüi etkinle≈ütir
            ability.lastUsed = now;
            this.startCooldown(abilityId, ability.cooldown);
            
            // Yeteneƒüe √∂zel i≈ülemler
            switch(abilityId) {
                case 'revelation':
                    this.activateRevelation();
                    break;
                case 'valor':
                    this.activateValor();
                    break;
                case 'restoration':
                    this.activateRestoration();
                    break;
            }
        }
        
        startCooldown(abilityId, duration) {
            const abilityEl = document.querySelector(`.ability[data-ability="${abilityId}"]`);
            if (!abilityEl) return;
            
            const cooldownEl = abilityEl.querySelector('.ability-cooldown');
            if (!cooldownEl) return;
            
            abilityEl.classList.add('on-cooldown');
            cooldownEl.style.transition = `transform ${duration}ms linear`;
            cooldownEl.style.transform = 'scaleX(0)';
            
            // Animasyon bittiƒüinde sƒ±nƒ±fƒ± kaldƒ±r
            setTimeout(() => {
                abilityEl.classList.remove('on-cooldown');
                cooldownEl.style.transition = 'none';
                cooldownEl.style.transform = 'scaleX(1)';
                // Tarayƒ±cƒ±ya stil deƒüi≈üikliƒüini i≈ülemesi i√ßin kƒ±sa bir gecikme
                setTimeout(() => {
                    cooldownEl.style.transition = '';
                }, 10);
            }, duration);
        }
        
        onGodClick(godName) {
            // Tanrƒ±ya tƒ±klandƒ±ƒüƒ±nda √∂zel bir ≈üeyler yap
            this.showNotification(`${this.getGodDisplayName(godName)} dinleniyor...`, 'info');
        }
        
        getGodDisplayName(godName) {
            const names = {
                metatron: 'Metatron',
                uriel: 'Uriel',
                raphael: 'Raphael',
                gabriel: 'Gabriel',
                michael: 'Michael'
            };
            return names[godName] || godName;
        }
        
        updateUI() {
            // G√º√ß √ßubuklarƒ±nƒ± g√ºncelle
            Object.entries(this.gods).forEach(([godName, god]) => {
                const powerEl = document.querySelector(`.god[data-god="${godName}"] .god-power`);
                const progressEl = document.querySelector(`.god[data-god="${godName}"] .god-progress-fill`);
                
                if (powerEl) {
                    powerEl.textContent = `${Math.round(god.power)}%`;
                }
                
                if (progressEl) {
                    const percentage = (god.power / god.maxPower) * 100;
                    progressEl.style.width = `${percentage}%`;
                    
                    // G√º√ß seviyesine g√∂re renk yoƒüunluƒüunu ayarla
                    const opacity = 0.3 + (percentage / 100 * 0.7);
                    progressEl.style.opacity = opacity;
                }
            });
            
            // √ñzel yetenek durumlarƒ±nƒ± g√ºncelle
            this.updateAbilityStates();
        }
        
        updateAbilityStates() {
            const now = Date.now();
            
            Object.entries(this.abilities).forEach(([abilityId, ability]) => {
                const abilityEl = document.querySelector(`.ability[data-ability="${abilityId}"]`);
                if (!abilityEl) return;
                
                const cooldownLeft = (ability.lastUsed + ability.cooldown) - now;
                if (cooldownLeft > 0) {
                    abilityEl.classList.add('on-cooldown');
                    abilityEl.querySelector('.ability-cooldown').style.transform = `scaleX(${1 - cooldownLeft / ability.cooldown})`;
                } else {
                    abilityEl.classList.remove('on-cooldown');
                    abilityEl.querySelector('.ability-cooldown').style.transform = 'scaleX(1)';
                }
            });
        }
        
        initEffects() {
            // TSParticles veya diƒüer g√∂rsel efektleri burada ba≈ülat
            // Gelecekte geni≈ületmek i√ßin bu fonksiyon kullanƒ±labilir
        }
        
        createPowerEffect(godName) {
            const godEl = document.querySelector(`.god[data-god="${godName}"]`);
            if (!godEl) return;
            
            // Parlama efekti
            const flash = document.createElement('div');
            flash.className = 'god-flash';
            flash.style.backgroundColor = this.gods[godName].color;
            godEl.appendChild(flash);
            
            // Kƒ±sa bir s√ºre sonra temizle
            setTimeout(() => {
                godEl.removeChild(flash);
            }, 500);
        }
        
        decayLoop() {
            setInterval(() => {
                const now = Date.now();
                const elapsed = (now - this.lastDecayTime) / 1000; // Saniye cinsinden ge√ßen s√ºre
                
                // Her tanrƒ± i√ßin g√º√ß azaltmasƒ± uygula
                Object.values(this.gods).forEach(god => {
                    const decayAmount = this.powerDecayRate * elapsed;
                    if (god.power > 0) {
                        god.power = Math.max(0, god.power - decayAmount);
                    }
                });
                
                // UI g√ºncelle (daha az sƒ±klƒ±kla)
                if (Math.random() < 0.2) {
                    this.updateUI();
                    this.savePowers();
                }
                
                this.lastDecayTime = now;
            }, 5000); // 5 saniyede bir kontrol et
        }
        
        showNotification(message, type = 'info') {
            // Bildirim g√∂sterme fonksiyonu - app nesnesinden geliyorsa kullan
            if (window.app && window.app.showNotification) {
                window.app.showNotification(message, type);
                return;
            }
            
            // Basit bildirim olu≈ütur
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            const container = document.getElementById('notifications-container') || document.body;
            container.appendChild(notification);
            
            // 3 saniye sonra kaldƒ±r
            setTimeout(() => {
                container.removeChild(notification);
            }, 3000);
        }
    }

    // Veritabanƒ± y√∂neticisi sƒ±nƒ±fƒ±
    class DBManager {
        constructor() {
            this.dbName = 'ultimateTrader';
            this.dbVersion = 1;
            this.db = null;
            this.ready = false;
            this.initPromise = null;
        }
        
        init() {
            if (this.initPromise) return this.initPromise;
            
            this.initPromise = new Promise((resolve, reject) => {
                // IndexedDB'yi desteklemiyor mu?
                if (!window.indexedDB) {
                    console.error('Bu tarayƒ±cƒ± IndexedDB desteklemiyor!');
                    reject(new Error('IndexedDB desteklenmiyor'));
                    return;
                }
                
                const request = indexedDB.open(this.dbName, this.dbVersion);
                
                request.onerror = (event) => {
                    console.error('Veritabanƒ± a√ßƒ±lƒ±rken hata olu≈ütu:', event);
                    reject(event.target.error);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // Depolanacak objeler i√ßin object stores olu≈ütur
                    if (!db.objectStoreNames.contains('settings')) {
                        db.createObjectStore('settings', { keyPath: 'id' });
                    }
                    
                    if (!db.objectStoreNames.contains('signals')) {
                        db.createObjectStore('signals', { keyPath: 'id', autoIncrement: true });
                    }
                    
                    if (!db.objectStoreNames.contains('stats')) {
                        db.createObjectStore('stats', { keyPath: 'id' });
                    }
                    
                    if (!db.objectStoreNames.contains('panteon')) {
                        db.createObjectStore('panteon', { keyPath: 'id' });
                    }
                    
                    console.log('Veritabanƒ± ≈üemasƒ± g√ºncellendi');
                };
                
                request.onsuccess = (event) => {
                    this.db = event.target.result;
                    this.ready = true;
                    console.log('Veritabanƒ± ba≈üarƒ±yla a√ßƒ±ldƒ±');
                    resolve(this.db);
                };
            });
            
            return this.initPromise;
        }
        
        async get(storeName, key) {
            await this.init();
            
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(key);
                
                request.onerror = (event) => {
                    console.error(`Veri getirme hatasƒ± (${storeName}):`, event);
                    reject(event.target.error);
                };
                
                request.onsuccess = (event) => {
                    resolve(request.result);
                };
            });
        }
        
        async put(storeName, data) {
            await this.init();
            
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(data);
                
                request.onerror = (event) => {
                    console.error(`Veri kaydetme hatasƒ± (${storeName}):`, event);
                    reject(event.target.error);
                };
                
                request.onsuccess = (event) => {
                    resolve(request.result);
                };
            });
        }
        
        async delete(storeName, key) {
            await this.init();
            
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(key);
                
                request.onerror = (event) => {
                    console.error(`Veri silme hatasƒ± (${storeName}):`, event);
                    reject(event.target.error);
                };
                
                request.onsuccess = (event) => {
                    resolve();
                };
            });
        }
        
        async getAll(storeName) {
            await this.init();
            
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.getAll();
                
                request.onerror = (event) => {
                    console.error(`T√ºm verileri getirme hatasƒ± (${storeName}):`, event);
                    reject(event.target.error);
                };
                
                request.onsuccess = (event) => {
                    resolve(request.result);
                };
            });
        }
        
        async clear(storeName) {
            await this.init();
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.clear();
                request.onerror = (event) => {
                    console.error(`Depo temizleme hatasƒ± (${storeName}):`, event);
                    reject(event.target.error);
                };
                request.onsuccess = (event) => {
                    resolve();
                };
            });
        }
    }
    
    // TheOracle sƒ±nƒ±fƒ± - Piyasadaki Mah≈üerin Atlƒ±larƒ± durumlarƒ±nƒ± analiz eder
    /**
     * TheOracle - Piyasa rejimi tespit motoru
     * Mah≈üerin D√∂rt Atlƒ±sƒ±nƒ± (KITLIK, SALGIN, SAVA≈û, √ñL√úM) metriklerle tespit eder
     * ve diƒüer sistem bile≈üenlerine piyasa ko≈üullarƒ±nƒ± bildirir
     */
    class TheOracle {
        constructor(app) {
            this.app = app;
            this.isInitialized = false;
            
            // Piyasa Rejimleri
            this.marketRegimes = {
                NORMAL: "NORMAL",   // Normal piyasa ko≈üullarƒ±
                KITLIK: "KITLIK",   // D√º≈ü√ºk volatilite, d√º≈ü√ºk hacim (Yatay/Konsolidasyon)
                SALGIN: "SALGIN",   // Y√ºksek volatilite, y√∂ns√ºz (Dalgalƒ±/Ortalamaya D√∂nen)
                SAVAS: "SAVA≈û",     // Y√ºksek volatilite, y√ºksek hacim, y√∂nl√º (G√º√ßl√º Trend)
                OLUM: "√ñL√úM"        // Ekstrem olay, yapƒ±sal kƒ±rƒ±lma (√á√∂k√º≈ü/Ani Y√ºkseli≈ü)
            };
            
            // Aktif piyasa rejimi (varsayƒ±lan: normal)
            this.currentRegime = this.marketRegimes.NORMAL;
            this.previousRegime = this.marketRegimes.NORMAL;
            
            // Legacy horsemen desteƒüi
            this.horsemen = {
                war: false,       // Sava≈ü (y√ºksek volatilite)
                famine: false,    // Kƒ±tlƒ±k (d√º≈ü√ºk likidite)
                pestilence: false, // Veba (ani trendler)
                death: false      // √ñl√ºm (ciddi d√º≈ü√º≈ü)
            };
            
            // Analiz pencereleri (periyot sayƒ±sƒ±)
            this.volatilityWindow = 14;     // ATR hesaplama penceresi
            this.volumeWindow = 20;         // Hacim normalizasyon penceresi
            this.adxWindow = 14;           // ADX hesaplama penceresi
            this.maWindow = 50;            // Trend analiz penceresi
            
            // Rejim e≈üikleri
            this.thresholds = {
                // KITLIK i√ßin e≈üikler
                lowVolatility: 0.7,        // ATR ortalamaya g√∂re % olarak (< %70 = d√º≈ü√ºk volatilite)
                lowVolume: 0.8,            // Hacim ortalamaya g√∂re % olarak (< %80 = d√º≈ü√ºk hacim)
                
                // SALGIN i√ßin e≈üikler
                highVolatility: 1.5,       // ATR ortalamaya g√∂re % olarak (> %150 = y√ºksek volatilite)
                lowAdx: 20,                // D√º≈ü√ºk ADX deƒüeri (< 20 = zayƒ±f trend)
                
                // SAVA≈û i√ßin e≈üikler
                warVolatility: 1.3,        // ATR ortalamaya g√∂re % olarak (> %130)
                highAdx: 25,               // Y√ºksek ADX deƒüeri (> 25 = g√º√ßl√º trend)
                highVolume: 1.3,           // Hacim ortalamaya g√∂re % olarak (> %130)
                
                // √ñL√úM i√ßin e≈üikler
                extremeVolatility: 2.5,    // ATR ortalamaya g√∂re % olarak (> %250 = ekstrem volatilite)
                crashThreshold: -5.0,      // Tek periyotta % d√º≈ü√º≈ü (< -%5 = √ß√∂k√º≈ü)
                spikeThreshold: 5.0        // Tek periyotta % y√ºkseli≈ü (> %5 = ani y√ºkseli≈ü)
            };
            
            // Metrik depolarƒ±
            this.metrics = {
                atr: [],              // ATR deƒüerleri
                atrAvg: 0,            // Ortalama ATR
                volume: [],           // Hacim deƒüerleri
                volumeAvg: 0,         // Ortalama hacim
                adx: 0,               // En son ADX deƒüeri
                priceChange: 0,       // Son periyottaki % fiyat deƒüi≈üimi
                maSlope: 0            // Hareketli ortalama eƒüimi
            };
            
            // Zaman i√ßinde takip i√ßin
            this.regimeHistory = [];  // Rejim deƒüi≈üikliklerini takip eder
            this.lastUpdate = Date.now();
            this.updateFrequency = 60000; // ms cinsinden g√ºncelleme sƒ±klƒ±ƒüƒ± (1 dakika)
            
            this.averageVolume = 0;
            this.averageRange = 0;
            this.trendStrength = 0;
            
            this.updateInterval = 60000; // 1 dakika
            this.lastUpdate = 0;
        }
        
        async init() {
            if (this.isInitialized) return;
            
            try {
                // ƒ∞lk metrikleri hesapla
                await this.calculateMetrics();
                
                // ƒ∞lk rejim analizi yap
                this.detectMarketRegime();
                
                // D√ºzenli g√ºncelleme ayarla
                this.updateTimer = setInterval(() => this.update(), this.updateFrequency);
                
                this.isInitialized = true;
                console.log('TheOracle initialized with market regime detection v2.0');
            } catch (error) {
                console.error('TheOracle initialization error:', error);
            }
        }
        
        async update() {
            try {
                const now = Date.now();
                const elapsed = now - this.lastUpdate;
                // Eƒüer son g√ºncellemeden sonra yeterli zaman ge√ßmediyse √ßƒ±k
                if (elapsed < this.updateFrequency * 0.9) return;
                this.lastUpdate = now;
                // Metrikleri g√ºncelle
                await this.calculateMetrics();
                // √ñnceki rejimi hatƒ±rla
                this.previousRegime = this.currentRegime;
                // Piyasa rejimini tespit et
                this.detectMarketRegime();
                // Eƒüer rejim deƒüi≈ütiyse bildir
                if (this.previousRegime !== this.currentRegime) {
                    this.notifyRegimeChange();
                }
                // Legacy horsemen'i g√ºncelle
                this.updateHorsemenFromRegime();
            } catch (error) {
                console.error('TheOracle update error:', error);
            }
        }
        
        // Four Horsemen Piyasa Rejim Tespiti
        detectMarketRegime() {
            if (!this.app || !this.app.candles || this.app.candles.length < 20) {
                this.currentRegime = 'NORMAL';
                return;
            }
            
            const candles = this.app.candles.slice(-20);
            const prices = candles.map(c => c.close);
            const volumes = candles.map(c => c.volume);
            
            // Volatilite analizi
            const volatility = this.calculateVolatility(prices);
            const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
            const recentVolume = volumes.slice(-5).reduce((a, b) => a + b, 0) / 5;
            
            // Trend analizi
            const trendStrength = this.calculateTrendStrength(prices);
            const priceChange = ((prices[prices.length - 1] - prices[0]) / prices[0]) * 100;
            
            // ATR ile volatilite √∂l√ß√ºm√º
            const atr = this.app.indicators?.atr || 0;
            const currentPrice = prices[prices.length - 1];
            const atrPercentage = atr / currentPrice * 100;
            
            // Four Horsemen Rejim Tespiti
            this.previousRegime = this.currentRegime;
            
            // √ñL√úM: B√ºy√ºk d√º≈ü√º≈ü ve y√ºksek volatilite
            if (priceChange < -5 && atrPercentage > 3) {
                this.currentRegime = '√ñL√úM';
            }
            // SAVA≈û: G√º√ßl√º trend ve artan volatilite
            else if (Math.abs(trendStrength) > 0.7 && atrPercentage > 2) {
                this.currentRegime = 'SAVA≈û';
            }
            // SALGIN: Y√ºksek volatilite ama zayƒ±f trend
            else if (atrPercentage > 2 && Math.abs(trendStrength) < 0.3) {
                this.currentRegime = 'SALGIN';
            }
            // KITLIK: D√º≈ü√ºk volatilite ve hacim
            else if (atrPercentage < 1 && recentVolume < avgVolume * 0.7) {
                this.currentRegime = 'KITLIK';
            }
            else {
                this.currentRegime = 'NORMAL';
            }
            
            // Panteon sistemine rejim g√ºncellemesi g√∂nder
            if (window.pantheon && window.pantheon.system) {
                window.pantheon.system.currentRegime = this.currentRegime;
            }
            
            console.log(`Market Regime: ${this.currentRegime} (Vol: ${atrPercentage.toFixed(2)}%, Trend: ${trendStrength.toFixed(2)}, Price Change: ${priceChange.toFixed(2)}%)`);
        }
        
        notifyRegimeChange() {
            if (this.previousRegime === this.currentRegime) return;
            
            const regimeNames = {
                'KITLIK': 'Kƒ±tlƒ±k Atlƒ±sƒ± - D√º≈ü√ºk likidite ve volatilite',
                'SALGIN': 'Salgƒ±n Atlƒ±sƒ± - Kaotik ve dalgalƒ± piyasa',
                'SAVA≈û': 'Sava≈ü Atlƒ±sƒ± - G√º√ßl√º trend ve y√ºksek volatilite',
                '√ñL√úM': '√ñl√ºm Atlƒ±sƒ± - B√ºy√ºk d√º≈ü√º≈ü ve ekstrem volatilite',
                'NORMAL': 'Normal Piyasa Durumu'
            };
            
            const message = `üèá Piyasa Rejimi Deƒüi≈üti: ${regimeNames[this.currentRegime]}`;
            
            if (this.app.showNotification) {
                this.app.showNotification(message, 'divine');
            }
            
            if (this.app.speak) {
                this.app.speak(`Piyasa rejimi deƒüi≈üti. ${regimeNames[this.currentRegime]}`);
            }
        }
        
        calculateBaseMetrics() {
            if (!this.app.candles || this.app.candles.length < 20) return;
            
            const candles = this.app.candles.slice(-20);
            
            // Ortalama hacim hesapla
            let totalVolume = 0;
            candles.forEach(candle => {
                totalVolume += candle.volume;
            });
            this.averageVolume = totalVolume / candles.length;
            
            // Ortalama fiyat aralƒ±ƒüƒ± hesapla
            let totalRange = 0;
            candles.forEach(candle => {
                const range = candle.high - candle.low;
                totalRange += range;
            });
            this.averageRange = totalRange / candles.length;
            
            // Trend g√ºc√º hesapla (basit lineer regresyon eƒüimi)
            const prices = candles.map(c => c.close);
            this.trendStrength = this.calculateTrendStrength(prices);
        }
        
        calculateTrendStrength(prices) {
            const n = prices.length;
            let sumX = 0;
            let sumY = 0;
            let sumXY = 0;
            let sumX2 = 0;
            
            for (let i = 0; i < n; i++) {
                sumX += i;
                sumY += prices[i];
                sumXY += i * prices[i];
                sumX2 += i * i;
            }
            
            // Lineer regresyon eƒüimi hesapla
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            
            // Normalize edilmi≈ü eƒüim (y√ºzde olarak)
            const normalizedSlope = (slope / prices[0]) * 100;
            
            return normalizedSlope;
        }
        
        updateHorsemen() {
            if (!this.app.candles || this.app.candles.length < 20) return;
            
            const candles = this.app.candles;
            const recent = candles.slice(-5);
            const current = candles[candles.length - 1];
            const previous = candles[candles.length - 2];
            
            this.calculateBaseMetrics();
            
            // Reset statuses
            Object.keys(this.horsemen).forEach(key => {
                this.horsemen[key] = false;
            });
            
            // Sava≈ü: Y√ºksek volatilite
            const recentVolatility = this.calculateVolatility(recent.map(c => c.close));
            if (recentVolatility > this.volatilityThreshold) {
                this.horsemen.war = true;
            }
            
            // Kƒ±tlƒ±k: D√º≈ü√ºk likidite
            const currentVolume = current.volume;
            if (currentVolume < this.averageVolume * this.liquidityThreshold) {
                this.horsemen.famine = true;
            }
            
            // Veba: Ani trendler
            const recentTrendStrength = this.calculateTrendStrength(recent.map(c => c.close));
            if (Math.abs(recentTrendStrength) > Math.abs(this.trendStrength) * this.trendThreshold) {
                this.horsemen.pestilence = true;
            }
            
            // √ñl√ºm: Ciddi d√º≈ü√º≈ü
            const priceChange = ((current.close - previous.close) / previous.close) * 100;
            if (priceChange < this.dropThreshold) {
                this.horsemen.death = true;
            }
            
            this.lastUpdate = Date.now();
            
            // UI g√ºncelle
            this.updateUI();
            
            // Eƒüer atlƒ±lardan biri aktifse, bildirim g√∂nder
            const activeHorsemen = Object.entries(this.horsemen).filter(([_, active]) => active);
            
            if (activeHorsemen.length > 0) {
                const names = {
                    war: "Sava≈ü",
                    famine: "Kƒ±tlƒ±k",
                    pestilence: "Veba",
                    death: "√ñl√ºm"
                };
                
                const message = `Mah≈üerin ${activeHorsemen.length > 1 ? "Atlƒ±larƒ±" : "Atlƒ±sƒ±"} g√∂r√ºld√º: ${activeHorsemen.map(([key, _]) => names[key]).join(", ")}`;
                
                if (this.app.notificationManager) {
                    this.app.notificationManager.notify(message, 'warning', 3);
                }
            }
        }
        
        calculateVolatility(prices) {
            const n = prices.length;
            if (n < 2) return 0;
            
            // Ortalama hesapla
            const avg = prices.reduce((sum, price) => sum + price, 0) / n;
            
            // Varyans hesapla
            const variance = prices.reduce((sum, price) => {
                return sum + Math.pow(price - avg, 2);
            }, 0) / (n - 1);
            
            // Standart sapma
            const stdDev = Math.sqrt(variance);
            
            // Fiyat y√ºzdesi olarak volatilite
            return (stdDev / avg) * 100;
        }
        
        updateUI() {
            const container = document.getElementById('mahser-atlilari');
            if (!container) return;
            
            // Her atlƒ± i√ßin durum g√ºncelle
            Object.entries(this.horsemen).forEach(([horseman, active]) => {
                const element = document.querySelector(`.atlƒ±[data-atli="${horseman}"]`);
                if (element) {
                    element.classList.toggle('active', active);
                }
            });
        }
        
        getHorsemanName(key) {
            const names = {
                war: "Sava≈ü",
                famine: "Kƒ±tlƒ±k",
                pestilence: "Veba",
                death: "√ñl√ºm"
            };
            return names[key] || key;
        }
        
        getActiveHorsemen() {
            return Object.entries(this.horsemen)
                .filter(([_, active]) => active)
                .map(([key, _]) => key);
        }
        
        isAnyHorsemanActive() {
            return Object.values(this.horsemen).some(active => active);
        }
    }

    // MultiTimeframeManager sƒ±nƒ±fƒ± - √áoklu zaman dilimi analizi
    class MultiTimeframeManager {
        constructor(app) {
            this.app = app;
            this.timeframes = ['1m', '5m', '15m', '1h', '4h', '1d'];
            this.data = {}; // Her zaman dilimi i√ßin ayrƒ± veri
            this.signals = {}; // Her zaman dilimi i√ßin ayrƒ± sinyal
            this.activeTimeframe = '15m'; // Varsayƒ±lan zaman dilimi
            this.isInitialized = false;
            this.updateIntervals = {
                '1m': 60000,
                '5m': 300000,
                '15m': 900000,
                '1h': 3600000,
                '4h': 14400000,
                '1d': 86400000
            };
            this.updateTimers = {};
        }
        
        async init() {
            if (this.isInitialized) return;
            
            try {
                // Aray√ºz elementlerini olu≈ütur
                this.createTimeframeTabs();
                
                // Her zaman dilimi i√ßin veri y√ºkle
                for (const tf of this.timeframes) {
                    await this.loadTimeframeData(tf);
                }
                
                // G√ºncelleme zamanlayƒ±cƒ±larƒ±nƒ± ayarla
                this.setupUpdateTimers();
                
                this.isInitialized = true;
                console.log('MultiTimeframeManager ba≈ülatƒ±ldƒ±');
            } catch (error) {
                console.error('MultiTimeframeManager ba≈ülatma hatasƒ±:', error);
            }
        }
        
        // initialize metodu i√ßin uyumluluk katmanƒ±
        async initialize(symbol, timeframes) {
            this.timeframes = timeframes || this.timeframes;
            // Sembol ayarƒ±nƒ± g√ºncelle
            if (symbol && this.app) {
                this.app.currentSymbol = symbol;
            }
            // init metodunu √ßaƒüƒ±r
            return this.init();
        }
        
        createTimeframeTabs() {
            const controlsContainer = document.querySelector('.controls');
            if (!controlsContainer) return;
            
            // Sekmeleri i√ßerecek konteyner
            const tabsContainer = document.createElement('div');
            tabsContainer.className = 'tabs-container';
            tabsContainer.style.marginLeft = '10px';
            
            // Zaman dilimlerini sƒ±rayla sekmelere ekle
            this.timeframes.forEach(tf => {
                const tab = document.createElement('div');
                tab.className = 'tab';
                tab.dataset.timeframe = tf;
                tab.textContent = tf;
                if (tf === this.activeTimeframe) {
                    tab.classList.add('active');
                }
                
                tab.addEventListener('click', () => this.switchTimeframe(tf));
                
                tabsContainer.appendChild(tab);
            });
            
            controlsContainer.appendChild(tabsContainer);
        }
        
        // Binance veya ba≈üka bir kaynaktan API endpoint olu≈üturur
        buildApiEndpoint(timeframe) {
            const symbol = this.app.symbol || 'BTCUSDT';
            const limit = 500;
            
            // Zaman dilimini Binance formatƒ±na √ßevir
            let interval;
            switch (timeframe) {
                case '1m': interval = '1m'; break;
                case '5m': interval = '5m'; break;
                case '15m': interval = '15m'; break;
                case '1h': interval = '1h'; break;
                case '4h': interval = '4h'; break;
                case '1d': interval = '1d'; break;
                default: interval = '15m';
            }
            
            // Demo veri kullanƒ±yoruz - ger√ßek API'ye baƒülanmak yerine statik veriyi kullan
            return `https://api.example.com/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
        }
        
        async loadTimeframeData(timeframe) {
            try {
                // Endpoint olu≈ütur - app'e baƒülƒ± olmadan kendi metodumuzu kullanƒ±yoruz
                const endpoint = this.buildApiEndpoint(timeframe);
                
                // Demo veri kullanƒ±yoruz - ger√ßek API'ye baƒülanmak yerine
                // Eƒüer app nesnesi i√ßinde candles verisi varsa onu kullanalƒ±m
                if (this.app && this.app.candles && this.app.candles.length > 0) {
                    this.data[timeframe] = [...this.app.candles]; // var olan verileri kullan
                    
                    // Sinyalleri hesapla
                    this.generateSignals(timeframe);
                    
                    console.log(`${timeframe} verileri y√ºklendi (yerel veri)`);
                    
                    // Aktif zaman dilimi ise, ana uygulamada kullan
                    if (timeframe === this.activeTimeframe) {
                        this.applyTimeframeData(timeframe);
                    }
                    
                    return this.data[timeframe];
                }
                
                // Ger√ßek API'ye baƒülanmayƒ± sim√ºle edelim
                console.log(`${timeframe} i√ßin demo veri kullanƒ±lƒ±yor`);
                
                // Demo veri olu≈ütur
                const demoData = this.generateDemoData(timeframe, 500);
                this.data[timeframe] = demoData;
                
                // Sinyalleri hesapla
                this.generateSignals(timeframe);
                
                console.log(`${timeframe} verileri y√ºklendi (demo veri)`);
                
                // Aktif zaman dilimi ise, ana uygulamada kullan
                if (timeframe === this.activeTimeframe) {
                    this.applyTimeframeData(timeframe);
                }
                
                return demoData;
            } catch (error) {
                console.log(`${timeframe} verileri y√ºklenirken hata:`, error);
                return [];
            }
        }
        
        // Demo veri olu≈üturma metodu
        generateDemoData(timeframe, count = 500) {
            const now = new Date().getTime();
            const data = [];
            
            // Zaman aralƒ±ƒüƒ±nƒ± belirle (milisaniye cinsinden)
            let interval;
            switch (timeframe) {
                case '1m': interval = 60 * 1000; break;
                case '5m': interval = 5 * 60 * 1000; break;
                case '15m': interval = 15 * 60 * 1000; break;
                case '1h': interval = 60 * 60 * 1000; break;
                case '4h': interval = 4 * 60 * 60 * 1000; break;
                case '1d': interval = 24 * 60 * 60 * 1000; break;
                default: interval = 15 * 60 * 1000;
            }
            
            // Son fiyat
            let lastPrice = 40000 + Math.random() * 10000;
            
            // Ge√ßmi≈ü verileri olu≈ütur
            for (let i = count - 1; i >= 0; i--) {
                const time = now - (i * interval);
                
                // Fiyat deƒüi≈üimi (y√ºzde -1 ile +1 arasƒ±)
                const change = (Math.random() * 2 - 1) * 0.01;
                lastPrice = lastPrice * (1 + change);
                
                // A√ßƒ±lƒ±≈ü, y√ºksek, d√º≈ü√ºk ve kapanƒ±≈ü fiyatlarƒ±
                const open = lastPrice;
                const high = open * (1 + Math.random() * 0.005);
                const low = open * (1 - Math.random() * 0.005);
                const close = (open + high + low) / 3; // Ortalama bir kapanƒ±≈ü
                
                // Hacim
                const volume = Math.random() * 100 + 50;
                
                data.push({
                    time: time,
                    open: open,
                    high: high,
                    low: low,
                    close: close,
                    volume: volume
                });
            }
            
            return data;
        }
        
        // Sinyal olu≈üturma metodu - zaman dilimine √∂zg√º sinyaller √ºretir
        generateSignals(timeframe) {
            if (!this.signals[timeframe]) {
                this.signals[timeframe] = [];
            }
            
            if (!this.data[timeframe] || this.data[timeframe].length === 0) {
                return; // Veri yoksa sinyal √ºretme
            }
            
            // ƒ∞lgili zaman dilimi i√ßin stratejileri kullanarak sinyal √ºret
            const candles = this.data[timeframe];
            if (this.app.strategies) {
                // Strateji sƒ±nƒ±flarƒ±nƒ± kullanarak sinyal √ºret
                for (const strategy of Object.values(this.app.strategies)) {
                    if (!strategy.isEnabled()) continue;
                    
                    const strategySignals = strategy.analyze(candles);
                    if (strategySignals && strategySignals.length > 0) {
                        this.signals[timeframe] = this.signals[timeframe].concat(strategySignals);
                    }
                }
            } else {
                // Basit √∂rnek: Her 10 mumda bir sinyal √ºret
                for (let i = 10; i < candles.length; i += 10) {
                    const candle = candles[i];
                    
                    if (candle.close > candle.open) {
                        // Y√ºkselen mum - alƒ±≈ü sinyali
                        this.signals[timeframe].push({
                            time: candle.time,
                            type: 'buy',
                            price: candle.close,
                            reason: `${timeframe} zaman diliminde y√ºkselen mum paterni`,
                            strength: 0.7
                        });
                    } else {
                        // D√º≈üen mum - satƒ±≈ü sinyali
                        this.signals[timeframe].push({
                            time: candle.time,
                            type: 'sell',
                            price: candle.close,
                            reason: `${timeframe} zaman diliminde d√º≈üen mum paterni`,
                            strength: 0.7
                        });
                    }
                }
            }
            
            // Sinyalleri sƒ±nƒ±rla
            if (this.signals[timeframe].length > 50) {
                this.signals[timeframe] = this.signals[timeframe].slice(-50);
            }
        }
        
        applyTimeframeData(timeframe) {
            if (!this.data[timeframe]) return;
            
            // Ana uygulama verilerini g√ºncelle
            this.app.candles = this.data[timeframe];
            this.app.signals = this.signals[timeframe] || [];
            
            // Grafik ve sinyal g√∂sterimini g√ºncelle
            if (this.app.updateChart) this.app.updateChart();
            if (this.app.updateSignals) this.app.updateSignals();
        }
        
        switchTimeframe(timeframe) {
            if (!this.timeframes.includes(timeframe) || timeframe === this.activeTimeframe) return;
            
            // Sekme aray√ºz√ºn√º g√ºncelle
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.timeframe === timeframe);
            });
            
            // Aktif zaman dilimini g√ºncelle
            this.activeTimeframe = timeframe;
            
            // Veriyi uygula
            this.applyTimeframeData(timeframe);
            
            // Kullanƒ±cƒ±yƒ± bilgilendir
            if (this.app.notificationManager) {
                this.app.notificationManager.notify(`Zaman dilimi ${timeframe} olarak deƒüi≈ütirildi`, 'info', 1);
            }
        }
        
        setupUpdateTimers() {
            // Her zaman dilimi i√ßin otomatik g√ºncelleme ayarla
            for (const tf of this.timeframes) {
                const interval = this.updateIntervals[tf];
                
                if (interval) {
                    // √ñnceki zamanlayƒ±cƒ±yƒ± temizle
                    if (this.updateTimers[tf]) {
                        clearInterval(this.updateTimers[tf]);
                    }
                    
                    // Yeni zamanlayƒ±cƒ± olu≈ütur
                    this.updateTimers[tf] = setInterval(async () => {
                        console.log(`${tf} verileri g√ºncelleniyor...`);
                        await this.loadTimeframeData(tf);
                        
                        if (tf === this.activeTimeframe) {
                            this.applyTimeframeData(tf);
                        }
                    }, interval);
                }
            }
        }
        
        destroy() {
            // Zamanlayƒ±cƒ±larƒ± temizle
            for (const timer of Object.values(this.updateTimers)) {
                clearInterval(timer);
            }
            
            // Veriyi temizle
            this.data = {};
            this.updateTimers = {};
            
            console.log('MultiTimeframeManager temizlendi');
        }
        
        // cleanup metodu destroy metodunun alias'ƒ± olarak tanƒ±mlanƒ±yor
        cleanup() {
            return this.destroy();
        }
    }

    // Confluence Engine - Farklƒ± sinyallerin birle≈üimi
    // Strateji birle≈ütirme motoru
    class ConfluenceEngine {
        constructor(app) {
            this.app = app;
            this.confluenceEnabled = true;
            this.minConfluenceScore = 3; // Minimum gerekli birle≈üim puanƒ±
            this.weightedStrategies = {
                'rsi': 1,
                'macd': 1.2,
                'supertrend': 1.5,
                'bollinger': 1.2,
                'ichimoku': 1.3,
                'fractals': 0.7
            };
        }
        
        validateSignal(signal) {
            if (!this.confluenceEnabled) return true;
            
            const confluenceScore = this.calculateConfluenceScore(signal);
            return confluenceScore >= this.minConfluenceScore;
        }
        
        calculateConfluenceScore(signal) {
            if (!signal || !signal.type || !this.app.strategies) return 0;
            
            let score = 0;
            const direction = signal.type === 'buy' ? 1 : -1;
            
            // T√ºm stratejilerden son sinyalleri al
            for (const [name, strategy] of Object.entries(this.app.strategies)) {
                if (!strategy.isEnabled()) continue;
                
                const latestSignal = strategy.getLastSignal();
                if (!latestSignal) continue;
                
                // Son sinyal ile aynƒ± y√∂nde mi?
                const signalDirection = latestSignal.type === 'buy' ? 1 : -1;
                
                // Aynƒ± y√∂nde ise, stratejinin aƒüƒ±rlƒ±ƒüƒ±nƒ± skora ekle
                if (signalDirection === direction) {
                    const weight = this.weightedStrategies[name] || 1;
                    score += weight;
                }
            }
            
            // Zaman √ßer√ßevesi kontrol√º (birden fazla zaman diliminde aynƒ± sinyal varsa bonus)
            if (this.app.multiTimeframeManager && this.app.multiTimeframeManager.signals) {
                const mtfSignals = this.app.multiTimeframeManager.signals;
                let timeframeConfluence = 0;
                
                for (const [tf, signals] of Object.entries(mtfSignals)) {
                    if (tf === this.app.multiTimeframeManager.activeTimeframe) continue;
                    
                    // Son 3 sinyale bak
                    const recentSignals = signals.slice(-3);
                    for (const tfSignal of recentSignals) {
                        if (tfSignal.type === signal.type) {
                            // Farklƒ± zaman diliminde aynƒ± y√∂nde sinyal
                            timeframeConfluence += 0.5;
                            break;
                        }
                    }
                }
                
                score += timeframeConfluence;
            }
            
            // TheOracle kontrol√º - Mah≈üerin Atlƒ±larƒ± durumlarƒ±
            if (this.app.oracle && this.app.oracle.isAnyHorsemanActive()) {
                const activeHorsemen = this.app.oracle.getActiveHorsemen();
                
                // √ñl√ºm atlƒ±sƒ± aktifse ve alƒ±≈ü sinyali ise, skoru d√º≈ü√ºr
                if (activeHorsemen.includes('death') && signal.type === 'buy') {
                    score -= 1;
                }
                
                // Sava≈ü atlƒ±sƒ± aktifse ve y√ºksek volatilite varsa, skoru d√º≈ü√ºr
                if (activeHorsemen.includes('war')) {
                    score -= 0.5;
                }
            }
            
            return Math.round(score * 10) / 10; // Bir ondalƒ±k basamaƒüa yuvarla
        }
        
        setMinConfluenceScore(score) {
            this.minConfluenceScore = score;
        }
        
        toggleConfluence(enabled) {
            this.confluenceEnabled = enabled;
        }
        
        setStrategyWeight(strategyName, weight) {
            if (this.weightedStrategies.hasOwnProperty(strategyName)) {
                this.weightedStrategies[strategyName] = weight;
            }
        }
        
        propose(strategy, direction, reason, score) {
            // Stratejilerden gelen sinyal √∂nerilerini i≈üle
            console.log(`[CONFLUENCE] ${strategy} stratejisinden ${direction} sinyali alƒ±ndƒ±: ${reason}`);
            
            // Burada sinyal i≈üleme ve birle≈ütirme mantƒ±ƒüƒ± eklenebilir
            // ≈ûimdilik sadece log'lama ve temel i≈üleme yapƒ±yoruz
            const normalizedScore = score || 1.0;
            
            if (this.app && this.app.recordSignal) {
                this.app.recordSignal({
                    type: direction,
                    strategy: strategy,
                    reason: reason,
                    score: normalizedScore,
                    time: Date.now()
                });
            }
        }
    }

    // Sayfa y√ºklendiƒüinde √ßalƒ±≈üacak ana fonksiyon
    function initApp() {
        console.log('initApp ba≈ülatƒ±lƒ±yor...');
        // Panteon UI i√ßin s√ºr√ºkleme √∂zelliƒüi ve mobil uyumluluƒüu
        const pantheonUI = document.getElementById('pantheon-ui');
        if (pantheonUI) {
            let isDragging = false;
            let offsetX, offsetY;
            
            function startDrag(e) {
                isDragging = true;
                offsetX = e.clientX - pantheonUI.getBoundingClientRect().left;
                offsetY = e.clientY - pantheonUI.getBoundingClientRect().top;
                pantheonUI.style.cursor = 'grabbing';
                e.preventDefault();
            }
            
            function onDrag(e) {
                if (!isDragging) return;
                pantheonUI.style.left = (e.clientX - offsetX) + 'px';
                pantheonUI.style.top = (e.clientY - offsetY) + 'px';
            }
            
            function stopDrag() {
                isDragging = false;
                pantheonUI.style.cursor = 'grab';
                
                // Pozisyonu kaydet
                const rect = pantheonUI.getBoundingClientRect();
                localStorage.setItem('pantheonUIPosition', JSON.stringify({
                    left: rect.left,
                    top: rect.top
                }));
            }
            
            // Event listener'larƒ± ekle
            pantheonUI.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('mouseleave', stopDrag);
            
            // Kayƒ±tlƒ± pozisyonu y√ºkle (sadece mobil deƒüilse)
            if (window.innerWidth > 768) {
                const savedPosition = localStorage.getItem('pantheonUIPosition');
                if (savedPosition) {
                    try {
                        const { left, top } = JSON.parse(savedPosition);
                        pantheonUI.style.left = `${left}px`;
                        pantheonUI.style.top = `${top}px`;
                    } catch (e) {
                        console.error('Pozisyon y√ºklenirken hata:', e);
                    }
                }
            }
        }
        
        // Dikey panel butonlarƒ± i√ßin olaylarƒ± ekle
        const notificationsBtn = document.getElementById('notifications-btn');
        const pantheonToggleBtn = document.getElementById('pantheon-toggle-btn');
        const energyToggleBtn = document.getElementById('energy-toggle-btn');
        const ritualToggleBtn = document.getElementById('ritual-toggle-btn');
        const quickSettingsBtn = document.getElementById('quick-settings-btn');
        const verticalStatsBtn = document.getElementById('vertical-stats-btn');
        const verticalLogBtn = document.getElementById('vertical-log-btn');
        
        // Bildirim paneli kontrol√º ve Bildirimler Men√ºs√º
        if(notificationsBtn) {
            const notificationsContainer = document.getElementById('notifications-container');
            
            // Bildirimler men√ºs√º olu≈ütur
            const notificationMenu = document.createElement('div');
            notificationMenu.className = 'notification-menu';
            notificationMenu.style.display = 'none';
            notificationMenu.style.position = 'fixed';
            notificationMenu.style.right = '75px';
            notificationMenu.style.top = '50%';
            notificationMenu.style.transform = 'translateY(-50%)';
            notificationMenu.style.background = 'var(--panel-bg)';
            notificationMenu.style.border = '1px solid var(--border-color)';
            notificationMenu.style.borderRadius = '8px';
            notificationMenu.style.zIndex = '2100';
            notificationMenu.style.padding = '10px';
            notificationMenu.style.boxShadow = '0 2px 10px rgba(0,0,0,0.3)';
            
            notificationMenu.innerHTML = `
                <div class="notification-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <span style="font-weight: bold; color: var(--primary);">Bƒ∞LDƒ∞Rƒ∞MLER</span>
                    <div style="display: flex; gap: 5px;">
                        <button id="notification-history-btn" class="btn btn-tiny" title="Bildirim Ge√ßmi≈üi">üìã</button>
                        <button id="clear-notifications" class="btn btn-tiny" title="Bildirimleri Temizle">üóëÔ∏è</button>
                        <button id="toggle-notification-sound" class="btn btn-tiny" title="Sesi A√ß/Kapat">üîä</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(notificationMenu);
            
            // Bildirim butonuna tƒ±klandƒ±ƒüƒ±nda men√ºy√º g√∂ster/gizle
            notificationsBtn.addEventListener('click', function() {
                const isMenuVisible = notificationMenu.style.display !== 'none';
                notificationMenu.style.display = isMenuVisible ? 'none' : 'block';
                notificationsBtn.classList.toggle('active', !isMenuVisible);
            });
            
            // Bildirimler konteynerinin g√∂ster/gizle mantƒ±ƒüƒ±
            const toggleNotifications = function() {
                const isVisible = notificationsContainer.style.display !== 'none';
                notificationsContainer.style.display = isVisible ? 'none' : 'block';
            };
            
            // Men√ºdeki butonlar i√ßin olay dinleyicileri
            document.getElementById('notification-history-btn')?.addEventListener('click', function() {
                if (window.app && window.app.notificationManager) {
                    window.app.notificationManager.showHistory();
                }
            });
            
            document.getElementById('clear-notifications')?.addEventListener('click', function() {
                if (window.app && window.app.notificationManager) {
                    window.app.notificationManager.clearAll();
                }
            });
            
            document.getElementById('toggle-notification-sound')?.addEventListener('click', function() {
                if (window.app && window.app.notificationManager) {
                    const notificationManager = window.app.notificationManager;
                    notificationManager.soundEnabled = !notificationManager.soundEnabled;
                    this.innerHTML = notificationManager.soundEnabled ? 'üîä' : 'üîá';
                    notificationManager.notify('Bildirim sesleri ' + (notificationManager.soundEnabled ? 'a√ßƒ±ldƒ±' : 'kapatƒ±ldƒ±'), 'system', 1);
                }
            });
            
            // Sayfa dƒ±≈üƒ±na tƒ±klandƒ±ƒüƒ±nda men√ºy√º kapat
            document.addEventListener('click', function(event) {
                if (!notificationsBtn.contains(event.target) && 
                    !notificationMenu.contains(event.target) && 
                    notificationMenu.style.display !== 'none') {
                    notificationMenu.style.display = 'none';
                    notificationsBtn.classList.remove('active');
                }
            });
        }
        
        // Pantheon paneli kontrol√º
        if(pantheonToggleBtn && pantheonUI) {
            pantheonToggleBtn.addEventListener('click', function() {
                // Mobil cihazlarda
                if(window.innerWidth <= 768) {
                    pantheonUI.classList.toggle('mobile-visible');
                } else {
                    // Masa√ºst√º cihazlarda
                    pantheonUI.style.display = pantheonUI.style.display === 'none' ? 'block' : 'none';
                }
                pantheonToggleBtn.classList.toggle('active');
            });
        }
        
        // Enerji Y√∂netimi butonu
        if(energyToggleBtn) {
            energyToggleBtn.addEventListener('click', function() {
                if (window.app && window.app.energyManager) {
                    window.app.energyManager.toggleEnergyBox();
                    energyToggleBtn.classList.add('active');
                    setTimeout(() => energyToggleBtn.classList.remove('active'), 500);
                    
                    // Sesli bildirim
                    if (window.app.speak) {
                        window.app.speak("Enerji y√∂netim sistemi etkinle≈ütirildi. Mevcut sistem enerjisi y√ºzde " + 
                            Math.round(window.app.energyManager.currentEnergy) + " seviyesinde.");
                    }
                }
            });
        }
        
        // Rit√ºel Sistemi butonu
        if(ritualToggleBtn) {
            ritualToggleBtn.addEventListener('click', function() {
                if (window.app && window.app.ritualManager) {
                    window.app.ritualManager.toggleRitualContainer();
                    ritualToggleBtn.classList.add('active');
                    setTimeout(() => ritualToggleBtn.classList.remove('active'), 500);
                    
                    // Sesli bildirim
                    if (window.app.speak) {
                        window.app.speak("Rit√ºel sistemi etkinle≈ütirildi. Gizli g√º√ßlere eri≈üim saƒülanƒ±yor.");
                    }
                }
            });
        }
        
        // Hƒ±zlƒ± ayarlar butonu
        if(quickSettingsBtn) {
            quickSettingsBtn.addEventListener('click', function() {
                document.getElementById('settings-modal-overlay').classList.add('visible');
                quickSettingsBtn.classList.add('active');
                setTimeout(() => quickSettingsBtn.classList.remove('active'), 500);
            });
        }
        
        // ƒ∞statistikler butonu
        if(verticalStatsBtn) {
            verticalStatsBtn.addEventListener('click', function() {
                document.getElementById('honor-modal-overlay').style.display = 'flex';
                verticalStatsBtn.classList.add('active');
                setTimeout(() => verticalStatsBtn.classList.remove('active'), 500);
            });
        }
        
        // Log butonu
        if(verticalLogBtn) {
            verticalLogBtn.addEventListener('click', function() {
                document.getElementById('log-modal-overlay').classList.add('visible');
                verticalLogBtn.classList.add('active');
                setTimeout(() => verticalLogBtn.classList.remove('active'), 500);
            });
        }
        
        // Pantheon kapatma butonu
        const pantheonCloseBtn = document.querySelector('.pantheon-close');
        if(pantheonCloseBtn && pantheonUI) {
            pantheonCloseBtn.addEventListener('click', function() {
                if(window.innerWidth <= 768) {
                    pantheonUI.classList.remove('mobile-visible');
                } else {
                    pantheonUI.style.display = 'none';
                }
                if(pantheonToggleBtn) pantheonToggleBtn.classList.remove('active');
            });
        }
        
        // Sistemleri g√ºvenli bir ≈üekilde ba≈ülatma
        try {
            // App nesnesini ba≈ülat
            if (!window.app) {
                console.log('Trading Command Center ba≈ülatƒ±lƒ±yor...');
                
                // UltimateTradingCommandCenter sƒ±nƒ±fƒ±nƒ± kontrol et ve ba≈ülat
                if (typeof UltimateTradingCommandCenter === 'function') {
                    window.app = new UltimateTradingCommandCenter();
                    
                    // ƒ∞leri d√ºzey √∂zellikleri ba≈ülat
                    if (typeof DBManager === 'function') {
                        window.app.dbManager = new DBManager();
                        window.app.dbManager.init();
                    }
                    
                    if (typeof EffectsManager === 'function') {
                        window.app.effectsManager = new EffectsManager();
                        window.app.effectsManager.init();
                    }
                    
                    // Panteon sistemini ba≈ülat
                    if (typeof PantheonSystem === 'function') {
                        window.app.panteonManager = new PantheonSystem();
                        if (window.app.panteonManager && typeof window.app.panteonManager.init === 'function') {
                            window.app.panteonManager.init();
                        }
                    }
                    
                    // Oracle (Mah≈üerin Atlƒ±larƒ±) sistemini ba≈ülat
                    if (typeof TheOracle === 'function') {
                        window.app.oracle = new TheOracle(window.app);
                        window.app.oracle.init();
                    }
                    
                    // √áoklu zaman dilimi y√∂neticisini ba≈ülat
                    if (typeof MultiTimeframeManager === 'function') {
                        window.app.multiTimeframeManager = new MultiTimeframeManager(window.app);
                        window.app.multiTimeframeManager.init();
                    }
                    
                    // Confluence motorunu ba≈ülat
                    if (typeof ConfluenceEngine === 'function') {
                        window.app.confluenceEngine = new ConfluenceEngine(window.app);
                    }
                } else {
                    console.error('UltimateTradingCommandCenter sƒ±nƒ±fƒ± tanƒ±mlƒ± deƒüil!');
                }
            }
        } catch (e) {
            console.error('Sistemleri ba≈ülatƒ±rken hata:', e);
        }
        
        // Panteon g√º√ß y√∂netimini ba≈ülat
        if (window.app && !window.app.pantheonPower) {
            window.app.pantheonPower = {
                buy: 0,
                sell: 0,
                lastUpdate: Date.now()
            };
        }
        
        // Panteon metodlarƒ±nƒ± app nesnesine g√ºvenli bir ≈üekilde baƒüla
        if (window.panteon && window.app) {
            if (window.panteon.increasePantheonPower) {
                window.app.increasePantheonPower = window.panteon.increasePantheonPower.bind(window.panteon);
            }
            if (window.panteon.updatePantheonUI) {
                window.app.updatePantheonUI = window.panteon.updatePantheonUI.bind(window.panteon);
            }
            if (window.panteon.triggerElciSpecialAbility) {
                window.app.triggerElciSpecialAbility = window.panteon.triggerElciSpecialAbility.bind(window.panteon);
            }
        } else {
            console.warn('Panteon veya App nesneleri hen√ºz hazƒ±r deƒüil.');
        }
        
        // Panteon aray√ºz√ºn√º g√ºncelle
        if (window.app && window.app.updatePantheonUI) {
            window.app.updatePantheonUI();
        }
    }
    
    // Sayfa y√ºklendiƒüinde ba≈ülatma i≈ülemlerini sƒ±raya koyuyoruz
    // T√ºm sƒ±nƒ±flarƒ±n y√ºklenmesinin ardƒ±ndan √ßalƒ±≈ümasƒ± i√ßin setTimeout kullanƒ±yoruz
    document.addEventListener('DOMContentLoaded', function() {
        // Sƒ±nƒ±flarƒ±n y√ºklenmesi i√ßin bir mikrosaniye bekle
        setTimeout(function() {
            // ƒ∞lk olarak ana uygulamayƒ± ba≈ülat
            initApp();
            
            // Ardƒ±ndan ek sistemleri g√ºvenli bir ≈üekilde ba≈ülat
            try {
                // √ñnce UltimateTradingCommandCenter'ƒ±n ba≈ülatƒ±lmƒ±≈ü olduƒüunu kontrol et
                if (!window.app && typeof UltimateTradingCommandCenter === 'function') {
                    window.app = new UltimateTradingCommandCenter();
                    console.log('UltimateTradingCommandCenter tekrar ba≈ülatƒ±ldƒ±');
                }
                
                // Panteon Sistemini ba≈ülat (eƒüer hen√ºz ba≈ülatƒ±lmadƒ±ysa)
                if (typeof PantheonSystem === 'function' && !window.panteon) {
                    window.panteon = new PantheonSystem();
                    console.log('Panteon Sistemi ba≈ülatƒ±ldƒ±');
                }
                
                // Advanced Trading Visualization Manager
                if (typeof AdvancedTradingVisualizer === 'function' && window.app) {
                    window.advancedVisualizer = new AdvancedTradingVisualizer(window.app);
                }
                
                // Enhanced Risk Management System
                if (typeof EnhancedRiskManagement === 'function' && window.app) {
                    window.riskManager = new EnhancedRiskManagement(window.app);
                }
                
                // Panteon metodlarƒ±nƒ± app nesnesine g√ºvenli bir ≈üekilde baƒüla (eƒüer hen√ºz baƒülanmadƒ±ysa)
                if (window.panteon && window.app) {
                    const pantheonMethods = [
                        'increasePantheonPower',
                        'updatePantheonUI',
                        'triggerElciSpecialAbility'
                    ];
                    
                    // Her metodu kontrol et ve baƒüla
                    pantheonMethods.forEach(methodName => {
                        if (typeof window.panteon[methodName] === 'function' && !window.app[methodName]) {
                            window.app[methodName] = function(...args) {
                                if (window.panteon && typeof window.panteon[methodName] === 'function') {
                                    return window.panteon[methodName].apply(window.panteon, args);
                                } else {
                                    console.warn(`Panteon metodu ${methodName} artƒ±k mevcut deƒüil.`);
                                    return null;
                                }
                            };
                        }
                    });
                    
                    console.log('Panteon metodlarƒ± ba≈üarƒ±yla baƒülandƒ±.');
                }
                
                console.log('T√ºm sistemler ba≈ülatƒ±ldƒ± ve hazƒ±r.');
            } catch (error) {
                console.error('Ek sistemler ba≈ülatƒ±lƒ±rken hata:', error);
            }
        }, 100); // 100ms bekleyerek t√ºm sƒ±nƒ±flarƒ±n y√ºklenmesini garanti edelim
    });
    </script>

    <style>
        :root {
            --primary-font: 'Orbitron', monospace;
            --secondary-font: 'Roboto Mono', monospace;
            
            /* Dark Theme - Default War Room */
            --bg-primary: #0a0a0f;
            --bg-secondary: #14141f;
            --bg-tertiary: #1a1a2e;
            --border-color: #2a2a3e;
            --text-primary: #e8e8ff;
            --text-secondary: #a8a8c8;
            --text-muted: #686888;
            
            /* Status Colors */
            --success: #00ff88;
            --danger: #ff3366;
            --warning: #ffaa00;
            --info: #00aaff;
            
            /* Special Effects */
            --glow-success: 0 0 20px rgba(0, 255, 136, 0.5);
            --glow-danger: 0 0 20px rgba(255, 51, 102, 0.5);
            --glow-warning: 0 0 20px rgba(255, 170, 0, 0.5);
            --glow-info: 0 0 20px rgba(0, 170, 255, 0.5);
            
            /* War Mode */
            --war-bg: linear-gradient(135deg, #1a0000 0%, #000000 50%, #1a0000 100%);
            --war-accent: #ff0040;
            --war-glow: 0 0 30px rgba(255, 0, 64, 0.8);

            /* Backward compatibility */
            --background-dark: var(--bg-primary); 
            --panel-bg-dark: var(--bg-secondary); 
            --text-main-dark: var(--text-primary);
            --text-secondary-dark: var(--text-secondary);
            --border-color-dark: var(--border-color);
            --input-bg-dark: #070711;
            --hover-bg-dark: #22223a;
            --primary-dark: var(--info);
            
            --background-light: #ffffff; 
            --panel-bg-light: #f6f8fa; 
            --text-main-light: #24292f; 
            --text-secondary-light: #57606a; 
            --border-color-light: #d0d7de; 
            --input-bg-light: #f0f2f5; 
            --hover-bg-light: #e8eaed; 
            --primary-light: #0969da;
            
            --war-mode-bg: var(--war-bg);
            --war-mode-panel-bg: rgba(255, 0, 0, 0.08); 
            --war-mode-border: #8B0000; 
            --war-mode-text: #ff5858; 
            --war-mode-primary: var(--war-accent);
            
            --positive: var(--success);
            --negative: var(--danger);
            --neutral: var(--warning);
            
            --ticker-height: 30px; 
            --signal-bar-height: 40px;
            --header-min-height: 40px;
            
            /* Panteon Renkleri - Geli≈ütirilmi≈ü */
            --metatron-color: #3b82f6; --metatron-glow: rgba(59, 130, 246, 0.3); --metatron-bg: rgba(59, 130, 246, 0.1);
            --uriel-color: #f59e0b; --uriel-glow: rgba(245, 158, 11, 0.3); --uriel-bg: rgba(245, 158, 11, 0.1);
            --raphael-color: #10b981; --raphael-glow: rgba(16, 185, 129, 0.3); --raphael-bg: rgba(16, 185, 129, 0.1);
            --gabriel-color: #8b5cf6; --gabriel-glow: rgba(139, 92, 246, 0.3); --gabriel-bg: rgba(139, 92, 246, 0.1);
            --michael-color: #ef4444; --michael-glow: rgba(239, 68, 68, 0.3); --michael-bg: rgba(239, 68, 68, 0.1);
        }
        /* Fullscreen modda gizlenecek elemanlar */
        body.fullscreen-chart #super-top-ticker,
        body.fullscreen-chart #signal-progress-bar-container,
        body.fullscreen-chart .header,
        body.fullscreen-chart .panel-title {
            display: none !important;
        }

        /* Fullscreen modda chart'ƒ± b√ºy√ºtme */
        body.fullscreen-chart .container { padding-top: 0 !important; height: 100vh !important; }
        body.fullscreen-chart .main-grid { height: 100vh !important; margin: 0 !important; }
        body.fullscreen-chart .center-panel { flex-grow: 1 !important; height: 100vh !important; border-radius: 0 !important; margin: 0 !important; }
        body.fullscreen-chart .data-container { height: 100% !important; }
        body.fullscreen-chart #chart-container-view,
        body.fullscreen-chart #live-chart { height: 100% !important; flex-grow: 1 !important; }
        body.fullscreen-chart .heatmap-container { display: none !important; }
        body.fullscreen-chart .chart-zoom-controls { background: rgba(0,0,0,0.7); }
        body.fullscreen-chart #exit-fullscreen-btn { display: block !important; }
        body.fullscreen-chart #chart-countdown-overlay { display: block !important; }

        [data-theme="light"] { --background: var(--background-light); --panel-bg: var(--panel-bg-light); --text-main: var(--text-main-light); --text-secondary: var(--text-secondary-light); --border-color: var(--border-color-light); --input-bg: var(--input-bg-light); --hover-bg: var(--hover-bg-light); --primary: var(--primary-light); }
        [data-theme="dark"] { --background: var(--background-dark); --panel-bg: var(--panel-bg-dark); --text-main: var(--text-main-dark); --text-secondary: var(--text-secondary-dark); --border-color: var(--border-color-dark); --input-bg: var(--input-bg-dark); --hover-bg: var(--hover-bg-dark); --primary: var(--primary-dark); }
        [data-theme="war"] {
            --bg-primary: #0d0000;
            --bg-secondary: #1a0505;
            --bg-tertiary: #2a0a0a;
            --border-color: #4a0a0a;
            --text-primary: #ff6666;
            --text-secondary: #cc4444;
            --success: #ffff00;
            --danger: #ff0000;
            --background: var(--war-mode-bg);
            --panel-bg: var(--war-mode-panel-bg);
            --text-main: var(--war-mode-text);
            --text-secondary: #ffaaaa;
            --border-color: var(--war-mode-border);
            --input-bg: rgba(255, 255, 255, 0.05);
            --hover-bg: rgba(255, 255, 255, 0.1);
            --primary: var(--war-mode-primary);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: var(--secondary-font);
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            position: relative;
            transition: background 0.5s, color 0.5s;
        }

        /* Animasyonlu Arka Plan Izgarasƒ± */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 136, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 136, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: grid-move 10s linear infinite;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes grid-move {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }
        
        #super-top-ticker { display: flex; position: fixed; top: 0; left: 0; width: 100%; background: var(--panel-bg); border-bottom: 1px solid var(--border-color); padding: 2px 10px; z-index: 1100; align-items: center; justify-content: space-between; font-size: 11px; font-weight: 700; height: var(--ticker-height); }
        .super-top-left { display: flex; align-items: center; gap: 10px; flex-shrink: 0;}
        #ticker-bar-symbol { color: var(--primary); }
        #ticker-bar-price { color: var(--text-main); font-size: 12px; }
        .super-top-right-buttons { display: flex; gap: 5px; }

        .container { display: flex; flex-direction: column; height: 100vh; padding-top: calc(var(--ticker-height) + var(--signal-bar-height)); }

        .header { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 6px; flex-shrink: 0; box-shadow: 0 2px 10px rgba(0,0,0,0.2); margin: 5px; position: relative; }
        .header-top-bar { display: flex; align-items: center; width: 100%; padding: 5px 15px; min-height: var(--header-min-height); justify-content: space-between; cursor: pointer; font-weight: 700; font-size: 16px; color: var(--primary); }
        .header-collapsible-content { transition: max-height 0.35s ease-in-out, opacity 0.3s ease, padding 0.35s ease, visibility 0.35s; max-height: 300px; opacity: 1; overflow: hidden; visibility: visible; padding: 0 15px 8px 15px; }
        body.header-collapsed .header-collapsible-content { max-height: 0; opacity: 0; visibility: hidden; padding-top: 0; padding-bottom: 0; }

        .main-controls { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; padding-bottom: 8px; }
        .form-control { background: var(--input-bg); color: var(--text-main); border: 1px solid var(--border-color); border-radius: 4px; padding: 4px 8px; font-family: 'Roboto Mono', monospace; }
        
        .status { display: flex; align-items: center; gap: 5px; font-size: 11px; padding: 4px 8px; border: 1px solid var(--border-color); border-radius: 4px; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--negative); transition: background-color 0.5s; }
        .status-dot.online { background: var(--positive); animation: pulse 2s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 #28a745b3; } 70% { box-shadow: 0 0 0 6px #28a74500; } 100% { box-shadow: 0 0 0 0 #28a74500; } }
        [data-theme="war"] .status-dot.online { background: var(--war-mode-primary); animation: war-pulse 1s infinite; }
        @keyframes war-pulse { 0% { box-shadow: 0 0 0 0 #ffc107b3; } 70% { box-shadow: 0 0 0 6px #ffc10700; } 100% { box-shadow: 0 0 0 0 #28a74500; } }
        .btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, var(--bg-tertiary), var(--bg-secondary));
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 6px;
            cursor: pointer;
            font-family: var(--secondary-font);
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            border-color: var(--primary);
        }

        .btn-success {
            background: linear-gradient(135deg, #00aa44, #00ff88);
            border-color: var(--success);
            color: #000;
            box-shadow: var(--glow-success);
        }

        .btn-danger {
            background: linear-gradient(135deg, #cc0033, #ff3366);
            border-color: var(--danger);
            box-shadow: var(--glow-danger);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #cc8800, #ffaa00);
            border-color: var(--warning);
            color: #000;
            box-shadow: var(--glow-warning);
        }

        .btn-tiny {
            padding: 2px 6px;
            font-size: 10px;
            line-height: 1;
            min-width: 0;
            white-space: nowrap;
            letter-spacing: 0.5px;
        }
        
        .main-grid { display: grid; grid-template-columns: 1fr; gap: 5px; flex-grow: 1; margin: 5px; overflow: hidden; height: calc(100% - var(--header-min-height) - 10px - var(--ticker-height) - var(--signal-bar-height)); }
        body.header-collapsed .main-grid { height: calc(100vh - var(--ticker-height) - var(--signal-bar-height) - 10px); margin-top: 0; } 
        
        .panel {
            background: var(--bg-secondary);
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .panel-title {
            padding: 12px 16px;
            background: linear-gradient(135deg, var(--bg-tertiary), var(--bg-secondary));
            border-bottom: 1px solid var(--border-color);
            font-family: var(--primary-font);
            font-size: 12px;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-content { padding: 10px; overflow-y: auto; flex-grow: 1; }
        .settings-group { margin-bottom: 15px; } .form-group { margin-bottom: 8px; } .form-label { display: block; font-size: 11px; color: var(--text-secondary); margin-bottom: 4px; }
        .checkbox-label { display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 12px; padding: 4px 0;}
        
        .price-display { display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px; width: 100%; border: 1px solid var(--border-color); border-radius: 4px; padding: 8px; font-size: 10px; margin-top: 8px; } 
        .price-item .price-label { color: var(--text-secondary); } 
        .price-item .price-value { font-size: 18px; font-weight: 700; }
        .price-item.countdown { grid-column: 1 / span 2; display: flex; justify-content: center; align-items: center; font-size: 14px; font-weight: 700; color: var(--primary); padding-top: 5px;}
        
        .center-panel { display: grid; grid-template-rows: 1fr; gap: 5px; padding: 0 !important; } 
        .data-container { display: grid; grid-template-rows: 1fr auto; overflow: hidden; height: 100%; } 
        .data-grid { position: relative; overflow: hidden; min-height: 0; } 

        #live-chart { width: 100%; height: 100%; } 
        .heatmap-container { display: grid; grid-template-rows: auto 1fr; border-top: 1px solid var(--border-color); }
        #orderbook-heatmap { width: 100%; height: 100%; display: block; }

        .chart-zoom-controls { position: absolute; top: 10px; right: 10px; display: flex; gap: 5px; z-index: 100; }
        .chart-zoom-controls .btn-tiny { background: rgba(1, 4, 9, 0.7); backdrop-filter: blur(2px); }

        #exit-fullscreen-btn {
            position: absolute; top: 10px; right: 10px; z-index: 101; 
            background: rgba(1, 4, 9, 0.7); color: white; border-radius: 4px; 
            padding: 2px 6px; font-size: 16px; cursor: pointer; border: 1px solid var(--border-color);
            line-height: 1;
        }
        #chart-countdown-overlay {
            position: absolute; top: 10px; left: 10px; z-index: 100; 
            background: rgba(1, 4, 9, 0.7); padding: 4px 8px; border-radius: 4px; 
            color: var(--primary); font-size: 14px; font-weight: bold;
        }

        .data-table-container { width: 100%; height: 100%; overflow: auto; }
        .data-table { width: 100%; border-collapse: collapse; font-size: 11px; }
        .data-table th, .data-table td { padding: 6px 8px; text-align: left; border-bottom: 1px solid var(--border-color); white-space: nowrap;}
        .data-table th { font-weight: 700; position: sticky; top: 0; background: var(--panel-bg); z-index: 10;}
        .data-table tr:hover { background: var(--hover-bg); }
        .signal-buy { background-color: #28a74514; } .signal-sell { background-color: #dc354514; }
        .signal-tp { background-color: #28a74533; } .signal-sl { background-color: #dc354533; }
        .signal-pending { background-color: #ffc1071a; } /* Neutral/warning color with transparency */

        .stat-item { display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid var(--border-color); font-size: 12px; }
        .stat-item:last-child { border-bottom: none; } .stat-label { color: var(--text-secondary); } .stat-value { font-weight: 700; }
        .btn-sm { padding: 1px 4px; font-size: 9px; margin-left: 4px; border-radius: 3px; cursor: pointer;}
        ::-webkit-scrollbar { width: 6px; height: 6px; } ::-webkit-scrollbar-track { background: transparent; } ::-webkit-scrollbar-thumb { background: var(--text-secondary); border-radius: 3px; }
        /* Bildirimlerin yeni stili ve konumu - sol dikey panel i√ßinde */
        .notifications { 
            position: fixed; 
            bottom: 15px; 
            left: 75px; /* Sol tarafta dikey ikonlarƒ±n yanƒ±nda */
            z-index: 2000; 
            width: 280px; /* Daha dar */
            max-height: 80vh;
            overflow-y: auto;
            pointer-events: none; /* Sadece bildirimler tƒ±klamalara ge√ßirgen olsun */
        }
        .notification { 
            background: rgba(22, 27, 34, 0.9); /* Hafif transparan */
            backdrop-filter: blur(4px);
            border: 1px solid var(--border-color); 
            border-right-width: 4px; /* Saƒü kenarda renkli bord√ºr */
            border-radius: 4px; 
            padding: 8px 12px; /* Daha k√º√ß√ºk padding */
            font-size: 12px; /* Daha k√º√ß√ºk font */
            box-shadow: 0 2px 8px rgba(0,0,0,0.3); 
            margin-top: 8px; 
            animation: slide-in-left 0.3s ease-out;
            pointer-events: auto; /* Bildirimler tƒ±klanabilir olsun */
        }
        @keyframes slide-in-left {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slide-in-right {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slide-in {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .notification.success { border-right-color: var(--positive); } 
        .notification.danger { border-right-color: var(--negative); } 
        .notification.warning { border-right-color: var(--neutral); }
        
        /* Bildirim Men√ºs√º Stilleri */
        .notification-menu {
            min-width: 200px;
        }
        
        .notification-menu .notification-header {
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
            margin-bottom: 8px;
        }
        
        aside#settings-panel, aside#analytics-panel { display: none !important; }
        .hidden-view { display: none !important; } 

        /* YENƒ∞ LOG PANELƒ∞ STƒ∞LLERƒ∞ */
        #log-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: none; justify-content: center; align-items: center; z-index: 2550; }
        #log-modal-overlay.visible { display: flex; }
        .log-modal-content { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 8px; width: 95%; max-width: 1000px; height: 90%; display: flex; flex-direction: column; box-shadow: 0 8px 30px rgba(0,0,0,0.4); }
        .log-modal-header { padding: 10px 15px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; font-weight: 700; font-size: 14px; color: var(--primary); }
        .log-modal-header .close-btn { background: none; border: none; font-size: 20px; color: var(--text-secondary); cursor: pointer; padding: 0 5px; line-height: 1; }
        .log-modal-body { padding: 0; overflow-y: auto; flex-grow: 1; }
        #log-output { font-family: 'Roboto Mono', monospace; font-size: 11px; color: var(--text-secondary); padding: 10px; margin: 0; white-space: pre-wrap; word-break: break-all; }
        #log-output .log-error { color: var(--negative); }
        #log-output .log-warn { color: var(--neutral); }
        #log-output .log-info { color: var(--positive); }

        
        aside#settings-panel, aside#analytics-panel { display: none !important; }
        .hidden-view { display: none !important; } 

        #settings-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 2500; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; }
        #settings-modal-overlay.visible { opacity: 1; visibility: visible; }
        .settings-modal-content { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 8px; width: 90%; max-width: 900px; max-height: 90%; display: flex; flex-direction: column; box-shadow: 0 8px 30px rgba(0,0,0,0.4); transform: translateY(20px); transition: transform 0.3s ease; }
        #settings-modal-overlay.visible .settings-modal-content { transform: translateY(0); }
        .settings-modal-header { padding: 12px 15px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; font-weight: 700; font-size: 15px; color: var(--primary); }
        .settings-modal-header .close-btn { background: none; border: none; font-size: 20px; color: var(--text-secondary); cursor: pointer; padding: 0 5px; line-height: 1; }
        .settings-modal-header .close-btn:hover { color: var(--negative); }
        .settings-modal-body { padding: 15px; overflow-y: auto; flex-grow: 1; display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .settings-modal-footer { padding: 12px 15px; border-top: 1px solid var(--border-color); display: flex; justify-content: flex-end; gap: 10px; }

        /* Yeni Sinyal Barƒ± */
        #signal-progress-bar-container {
            display: flex; gap: 5px; width: 100%; padding: 5px 10px; background: var(--panel-bg); 
            border-bottom: 1px solid var(--border-color); justify-content: space-around; align-items: center;
            position: fixed; top: var(--ticker-height); left: 0; z-index: 1099;
            height: var(--signal-bar-height);
        }
        .signal-bar-wrapper { flex: 1; text-align: center; }
        .signal-bar-label { font-size: 10px; color: var(--text-secondary); margin-bottom: 3px; }
        .signal-bar { width: 100%; height: 10px; background: var(--input-bg); border: 1px solid var(--border-color); border-radius: 5px; overflow: hidden; position: relative; }
        .signal-bar-fill { height: 100%; width: 0%; transition: width 0.2s ease-out; position: absolute; left: 0; top: 0; background: linear-gradient(90deg, transparent, var(--positive)); }
        .signal-bar-fill.buy { background: linear-gradient(90deg, transparent, var(--positive)); }
        .signal-bar-fill.sell { background: linear-gradient(90deg, transparent, var(--negative)); }
        .signal-score-text { font-size: 9px; margin-top: 2px; color: var(--primary); }

        /* Resizable Handle */
        .resize-handle { position: absolute; bottom: 0; left: 0; width: 100%; height: 8px; cursor: ns-resize; background: var(--border-color); z-index: 10; border-top: 1px solid var(--border-color); }
        .center-panel.resizing { user-select: none; }

        /* Dikey ƒ∞kon Paneli Stilleri - Sol tarafta konumlandƒ±rƒ±ldƒ± */
        .vertical-icon-panel {
            position: fixed;
            top: 50%;
            left: 0; /* Saƒü yerine sol tarafa konumlandƒ±rma */
            transform: translateY(-50%);
            z-index: 2000;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-left: none; /* Sol kenara yapƒ±≈üƒ±k olduƒüu i√ßin sol kenar yok */
            border-radius: 0 10px 10px 0; /* Saƒü k√∂≈üeler yuvarlatƒ±ldƒ± */
            padding: 10px 5px;
            z-index: 1001;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.2); /* G√∂lge saƒü tarafa */
            display: flex;
            flex-direction: column;
            gap: 10px;
            opacity: 0.85;
            transition: opacity 0.3s ease;
        }
        
        .vertical-icon-panel:hover {
            opacity: 1;
        }
        
        .vertical-icon-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: var(--input-bg);
            border: 1px solid var(--border-color);
            color: var(--text-main);
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .vertical-icon-btn:hover {
            background: var(--hover-bg);
            transform: translateX(-3px);
        }
        
        .vertical-icon-btn.active {
            background: var(--primary);
            color: #000;
        }
        
        /* Panteon UI Stilleri - Sade ve Zarif */
        /* Panteon UI Stilleri - Sade ve Zarif - Sabit Boyutlu */
        .pantheon-ui {
            position: fixed;
            top: 20px;
            left: 20px; /* Sol √ºste ta≈üƒ±ndƒ± */
            background: rgba(13, 17, 23, 0.9);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 10px;
            width: 200px; /* Daha k√º√ß√ºk */
            height: auto;
            max-height: 250px; /* Daha k√º√ß√ºk */
            z-index: 1200; /* D√º≈ü√ºk z-index */
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(8px);
            opacity: 0.95;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        /* Mobil cihazlar i√ßin Pantheon UI stilleri - Sabit Boyutlu */
        @media screen and (max-width: 768px) {
            .vertical-icon-panel {
                top: auto;
                bottom: 70px;
                right: 0;
                transform: none;
                border-radius: 10px 0 0 10px;
                padding: 10px 5px;
            }
            
            .pantheon-ui {
                opacity: 0;
                visibility: hidden;
                transform: translateY(20px);
                width: 180px;
                height: auto;
                max-height: 200px;
                left: 10px; /* Sol √ºstte mobilde */
                top: 10px;
                transition: opacity 0.3s ease, transform 0.3s ease, visibility 0.3s;
            }
            
            .pantheon-content {
                max-height: 350px;
            }
            
            .pantheon-ui.mobile-visible {
                opacity: 1;
                visibility: visible;
                transform: translateY(0);
            }
            
            .god {
                height: 55px;
            }
            
            .ability {
                height: 45px;
            }
        }
        
        .pantheon-ui:hover {
            opacity: 1;
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .pantheon-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .pantheon-title {
            font-weight: 700;
            color: var(--primary);
            font-size: 12px;
            letter-spacing: 1px;
            text-transform: uppercase;
            background: linear-gradient(90deg, var(--primary), #9ca3af);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .pantheon-controls {
            display: flex;
            gap: 8px;
        }
        
        .pantheon-toggle-btn,
        .pantheon-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 14px;
            cursor: pointer;
            line-height: 1;
            padding: 0;
            width: 22px;
            height: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }
        
        .pantheon-toggle-btn:hover,
        .pantheon-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-main);
        }
        
        .pantheon-close:hover {
            color: var(--negative);
        }
        
        .pantheon-content {
            display: flex;
            flex-direction: column;
            gap: 12px;
            height: auto;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
        }
        
        /* Custom scrollbar for webkit browsers */
        .pantheon-content::-webkit-scrollbar {
            width: 5px;
        }
        
        .pantheon-content::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .pantheon-content::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        
        .pantheon-content::-webkit-scrollbar-thumb:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }
        
        .pantheon-gods {
            display: flex;
            flex-direction: column;
            gap: 6px;
            width: 100%;
        }
        
        .god {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 8px;
            height: 60px;
            border-radius: 6px;
            background: rgba(22, 27, 34, 0.6);
            transition: all 0.2s ease;
            border: 1px solid rgba(255, 255, 255, 0.03);
            box-sizing: border-box;
        }
        
        .god:hover {
            background: rgba(33, 38, 45, 0.8);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
        }
        
        .god-info {
            display: flex;
            align-items: center;
            gap: 10px;
            height: 32px;
            width: 100%;
        }
        
        .god-icon {
            font-size: 18px;
            min-width: 30px;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .god-details {
            flex: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .god-name {
            font-weight: 500;
            font-size: 13px;
            color: var(--text-main);
        }
        
        .god-power {
            font-size: 12px;
            font-weight: 600;
            color: var(--primary);
        }
        
        .god-progress {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .god-progress-fill {
            height: 100%;
            width: 0%;
            border-radius: 2px;
            transition: width 0.3s ease, opacity 0.3s ease;
        }
        
        /* Enhanced god-specific gradients */
        .metatron .god-progress-fill { background: linear-gradient(90deg, var(--metatron-color), #7e6be8); }
        .uriel .god-progress-fill { background: linear-gradient(90deg, var(--uriel-color), #e06c75); }
        .raphael .god-progress-fill { background: linear-gradient(90deg, var(--raphael-color), #98c379); }
        .gabriel .god-progress-fill { background: linear-gradient(90deg, var(--gabriel-color), #61afef); }
        .michael .god-progress-fill { background: linear-gradient(90deg, var(--michael-color), #d19a66); }
        
        .pantheon-abilities {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-top: 4px;
            width: 100%;
        }
        
        .ability {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            height: 50px;
            border-radius: 6px;
            background: rgba(22, 27, 34, 0.6);
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.03);
            cursor: pointer;
            transition: all 0.2s ease;
            box-sizing: border-box;
        }
        
        .ability:hover {
            background: rgba(33, 38, 45, 0.8);
            transform: translateY(-1px);
        }
        
        .ability-icon {
            font-size: 16px;
            margin-right: 12px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 50%;
        }
        
        .ability-details {
            flex: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 100%;
            width: calc(100% - 40px);
        }
        
        .ability-name {
            font-weight: 500;
            font-size: 13px;
            color: var(--text-main);
        }
        
        .ability-status {
            font-size: 11px;
            font-weight: 500;
            color: #98c379;
        }
        
        .ability.on-cooldown .ability-status {
            color: #e06c75;
        }
        
        .ability-cooldown {
            position: absolute;
            left: 0;
            bottom: 0;
            height: 2px;
            width: 100%;
            background: linear-gradient(90deg, var(--primary), #56b6c2);
            transform-origin: left;
            transform: scaleX(1);
        }
        
        .ability.on-cooldown::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            pointer-events: none;
        }
        
        .god-icon {
            font-size: 13px;
            margin-bottom: 2px;
            text-align: center;
        }
        
        .god-name {
            font-weight: 600;
            font-size: 9px;
            text-align: center;
            margin-bottom: 2px;
        }
        
        .god-power {
            font-size: 8px;
            text-align: center;
            margin-bottom: 2px;
            font-family: 'Roboto Mono', monospace;
        }
        
        .god-progress {
            width: 100%;
            height: 4px; /* √áok daha ince √ßubuk */
            background: var(--border-color);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .god-progress-fill {
            height: 100%;
            width: 0%;
            transition: width 0.3s ease, background-color 0.3s ease;
        }
        
        /* Her tanrƒ± i√ßin √∂zel renkler */
        .metatron .god-progress-fill { background: var(--metatron-color); }
        .uriel .god-progress-fill { background: var(--uriel-color); }
        .raphael .god-progress-fill { background: var(--raphael-color); }
        .gabriel .god-progress-fill { background: var(--gabriel-color); }
        .michael .god-progress-fill { background: var(--michael-color); }
        
        .pantheon-abilities {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* 3 s√ºtunlu grid */
            gap: 4px;
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid var(--border-color);
        }
        
        .ability {
            background: var(--input-bg);
            border-radius: 5px;
            padding: 4px 2px; /* Minimum padding */
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
        .ability:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .ability-icon {
            font-size: 13px;
            margin-bottom: 1px;
        }
        
        .ability-name {
            font-size: 8px; /* Daha da k√º√ß√ºk font */
            font-weight: 600;
        }
        
        .ability-cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: var(--primary);
            width: 100%;
            transform-origin: left;
            transform: scaleX(0);
            transition: transform 0.1s linear;
        }
        
        /* Animasyonlar */
        @keyframes pulse {
            0% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.6; transform: scale(1); }
        }
        
        .ability.active {
            animation: pulse 1.5s infinite;
        }

                        /* D√úZELTME: Metinlerin yanlƒ±≈ülƒ±kla se√ßilmesini engelle */
        .btn, .panel-title, .header-top-bar, .signal-bar-label, .form-label {
            user-select: none; /* Standart */
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* Internet Explorer/Edge */
        }

                                /* Rit√ºel Sistemi Stilleri */
        .ritual-container {
            position: fixed;
            bottom: 75px;
            right: 75px;
            width: 320px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.7);
            color: var(--text-primary);
            z-index: 100;
            font-family: var(--primary-font);
            transform: translateY(0);
            transition: transform 0.5s ease-in-out, opacity 0.5s ease-in-out;
        }
        
        .ritual-container.hidden {
            transform: translateY(150%);
            opacity: 0;
        }
        
        .ritual-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: linear-gradient(90deg, var(--bg-tertiary), var(--panel-bg));
            border-bottom: 1px solid var(--border-color);
            border-radius: 8px 8px 0 0;
        }
        
        .ritual-title {
            font-weight: bold;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .ritual-icon {
            display: inline-block;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, var(--warning), var(--danger));
            border-radius: 50%;
            position: relative;
            overflow: hidden;
        }
        
        .ritual-icon::after {
            content: "‚úß";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .ritual-close {
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
            font-size: 16px;
        }
        
        .ritual-close:hover {
            opacity: 1;
            color: var(--danger);
        }
        
        .ritual-description {
            padding: 12px 15px;
            font-size: 12px;
            line-height: 1.4;
            color: var(--text-secondary);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .ritual-list {
            max-height: 280px;
            overflow-y: auto;
            padding: 5px;
        }
        
        .ritual-list::-webkit-scrollbar {
            width: 5px;
        }
        
        .ritual-list::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
        }
        
        .ritual-list::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 5px;
        }
        
        .ritual-item {
            padding: 10px;
            margin: 5px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .ritual-item:hover {
            background: rgba(255, 255, 255, 0.07);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .ritual-item.active {
            background: linear-gradient(135deg, rgba(255, 170, 0, 0.1), rgba(255, 51, 102, 0.1));
            border-color: rgba(255, 170, 0, 0.3);
        }
        
        .ritual-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .ritual-item-title {
            font-weight: 600;
            font-size: 12px;
            color: var(--text-primary);
        }
        
        .ritual-item-duration {
            font-size: 10px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 3px;
        }
        
        .ritual-item-description {
            font-size: 11px;
            color: var(--text-secondary);
            margin: 5px 0;
        }
        
        .ritual-item-effect {
            font-size: 10px;
            color: var(--success);
            margin-top: 5px;
        }
        
        .ritual-item-cost {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 10px;
            color: var(--warning);
        }
        
        .ritual-item-progress {
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin-top: 8px;
            overflow: hidden;
        }
        
        .ritual-item-progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--warning), var(--success));
            transition: width 0.5s ease;
        }
        
        .ritual-actions {
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .ritual-btn {
            background: linear-gradient(135deg, var(--bg-tertiary), var(--border-color));
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 12px;
            font-size: 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            margin: 0 5px;
            text-align: center;
        }
        
        .ritual-btn:hover {
            background: linear-gradient(135deg, var(--border-color), var(--bg-tertiary));
            border-color: var(--text-secondary);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
        }
        
        .ritual-btn:active {
            transform: scale(0.98);
        }
        
        .ritual-btn.primary {
            background: linear-gradient(135deg, var(--warning), var(--danger));
            border-color: var(--warning);
        }
        
        .ritual-btn.primary:hover {
            background: linear-gradient(135deg, var(--danger), var(--warning));
        }
        
        .ritual-status {
            padding: 10px 15px;
            font-size: 11px;
            text-align: center;
            color: var(--text-secondary);
            background: rgba(0, 0, 0, 0.2);
            border-radius: 0 0 8px 8px;
        }
        
        .ritual-active-label {
            position: absolute;
            top: -10px;
            right: -10px;
            background: var(--success);
            color: black;
            font-size: 8px;
            padding: 2px 5px;
            border-radius: 3px;
            transform: rotate(10deg);
            z-index: 1;
        }
        
        /* Rit√ºel animasyonlarƒ± */
        @keyframes ritualActivate {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.5; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        @keyframes ritualPulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 170, 0, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(255, 170, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 170, 0, 0); }
        }
        
        .ritual-active {
            animation: ritualPulse 2s infinite;
        }
        
        .ritual-activate-effect {
            animation: ritualActivate 0.5s ease-in-out;
        }
        
        /* Rit√ºel efektleri - Grafik stillerine eklemeler */
        .ritual-effect-trend #live-chart {
            box-shadow: 0 0 15px rgba(0, 170, 255, 0.5);
        }
        
        .ritual-effect-confluence #live-chart {
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }
        
        .ritual-effect-liquidity #live-chart {
            box-shadow: 0 0 15px rgba(255, 170, 0, 0.5);
        }
        
        .ritual-effect-orderflow #live-chart {
            box-shadow: 0 0 15px rgba(255, 51, 102, 0.5);
        }
        
        .ritual-effect-protection #live-chart {
            box-shadow: 0 0 15px rgba(132, 0, 255, 0.5);
        }
        
        @media screen and (max-width: 768px) {
            .desktop-only { display: none !important; }
            .mobile-only { display: flex !important; align-items: center; }

            .container { 
                padding-top: calc(var(--ticker-height) + var(--signal-bar-height)); 
                padding-bottom: var(--header-min-height); 
            }
            #signal-progress-bar-container { top: var(--ticker-height); }
            
            .header { 
                order: 2; 
                position: fixed;
                bottom: 0; 
                left: 0;
                right: 0;
                width: 100%; 
                z-index: 1000; 
                margin: 0; 
                border-radius: 0; 
                border: none; 
                border-top: 1px solid var(--border-color); 
            }
            /* D√úZELTME: Butonlar ve ba≈ülƒ±k i√ßin yeni ve daha basit d√ºzen */
            .header-top-bar { 
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 0 10px; 
                min-height: var(--header-min-height);
            }
            .header-center-title {
                cursor: pointer;
                flex-grow: 1;
                text-align: center;
            }
            .header-left-controls, .header-right-controls {
                display: flex;
                gap: 8px;
            }
            #mobile-toggle-controls-btn, .header-right-controls .btn {
                font-size: 16px;
                padding: 5px 10px;
            }
            /* Mobilde masa√ºst√º ba≈ülƒ±ƒüƒ±nƒ± gizle */
            .header-center-title .header-title-text {
                display: none;
            }

            .header-collapsible-content { padding: 0; }
            .header-collapsible-content .main-controls { flex-direction: column; align-items: center; padding: 0; width: 100%; }
            .form-control, .btn, .status { width: 100%; text-align: center; padding: 8px 10px; font-size: 11px; }
            .status { justify-content: center; }
            .price-display { grid-template-columns: repeat(2, 1fr); margin-top: 10px; }
            .price-item .price-value { font-size: 14px; } 
            
            .main-grid { 
                order: 1; 
                margin: 0;
                height: 100%;
                display: flex;
                flex-direction: column;
            }
            .center-panel { 
                order: 1; 
                flex-grow: 1;
                height: 100%;
                border: none;
                border-radius: 0; 
                background: transparent;
                box-shadow: none; 
                margin: 0; 
            }
            .center-panel > .panel-title { display: none; }
            .data-container { 
                flex-direction: column; 
                height: 100%; 
                padding: 5px;
            }
            .data-grid { 
                height: 100%;
                flex-grow: 1;
            }
            #live-chart { height: 100%; width: 100%; } 
            .heatmap-container { height: 150px; flex-shrink: 0; margin-top: 10px; border-top: 1px solid var(--border-color); padding-top: 10px; }
            .heatmap-container .panel-title { border-bottom: none; margin-bottom: 5px; }
            .settings-modal-content { width: 95%; margin: 10px; }
            .settings-modal-body { grid-template-columns: 1fr; gap: 15px; }
            .super-top-right-buttons { display: none; }
            .resize-handle { display: none; }
            #chart-countdown-overlay { font-size: 12px; padding: 3px 6px; }

            body.fullscreen-chart .main-grid { height: 100vh; }
            body.fullscreen-chart .center-panel { height: 100vh; }
        }




    </style>
</head>
<body class="header-collapsed" data-theme="dark">
    <!-- Panteon Paneli -->
    <aside id="panteon-panel" aria-label="Panteon Paneli">
        <div class="pp-title">
            <span>‚ö° Panteon</span>
            <span id="pp-env">v3.5</span>
            <button class="pp-expand-btn" id="pp-expand-btn" title="Panel Geni≈ület/Daralt">‚öôÔ∏è</button>
        </div>
        <div class="pp-body">
            <div class="panteon-stats">
                <div class="regime-indicator">
                    <span>Rejim:</span>
                    <span class="current-regime">NORMAL</span>
                </div>
                <div class="state-indicator">
                    <span>Kolektif:</span>
                    <span class="collective-state">Dengeli</span>
                </div>
            </div>
            
            <div class="panteon-panel">
                <!-- Metatron - Bilgelik El√ßisi -->
                <div class="ambassador" data-name="metatron" data-mode="ƒ∞NAN√áLI" data-role="wisdom">
                    <div class="ambassador-header">
                        <div class="ambassador-name">Metatron</div>
                        <div class="ambassador-toggle" title="Aktif/Pasif">‚úì</div>
                    </div>
                    <div class="ambassador-info">
                        <div class="ambassador-role">Bilgelik, Analiz</div>
                        <div class="ambassador-status">
                            <span class="ambassador-mode">ƒ∞NAN√áLI</span>
                            <span class="reputation">ƒ∞tibar: <span class="reputation-score">0.0</span></span>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="confidence">
                            <span>G√ºven</span>
                            <div class="confidence-bar">
                                <div class="confidence-level" style="width:75%">75%</div>
                            </div>
                        </div>
                        <div class="power">
                            <span>G√º√ß</span>
                            <div class="power-bar">
                                <div class="power-level" style="width:0%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="strategy-select">
                        <button data-strategy="SupportResistanceStrategy">Destek/Diren√ß</button>
                        <button data-strategy="MeanReversionStrategy">Ort. Geri D√∂n√º≈ü</button>
                        <button data-strategy="OrderBookImbalanceStrategy">Emir Defteri</button>
                    </div>
                </div>
                
                <!-- Uriel - Cesaret El√ßisi -->
                <div class="ambassador" data-name="uriel" data-mode="ƒ∞NAN√áLI" data-role="courage">
                    <div class="ambassador-header">
                        <div class="ambassador-name">Uriel</div>
                        <div class="ambassador-toggle" title="Aktif/Pasif">‚úì</div>
                    </div>
                    <div class="ambassador-info">
                        <div class="ambassador-role">Cesaret, Hƒ±z</div>
                        <div class="ambassador-status">
                            <span class="ambassador-mode">ƒ∞NAN√áLI</span>
                            <span class="reputation">ƒ∞tibar: <span class="reputation-score">0.0</span></span>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="confidence">
                            <span>G√ºven</span>
                            <div class="confidence-bar">
                                <div class="confidence-level" style="width:75%">75%</div>
                            </div>
                        </div>
                        <div class="power">
                            <span>G√º√ß</span>
                            <div class="power-bar">
                                <div class="power-level" style="width:0%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="strategy-select">
                        <button data-strategy="BreakoutPatternStrategy">Kƒ±rƒ±lma</button>
                        <button data-strategy="MomentumStrategy">Momentum</button>
                        <button data-strategy="TrendFollowingStrategy">Trend Takip</button>
                    </div>
                </div>
                
                <!-- Raphael - ≈ûifa El√ßisi -->
                <div class="ambassador" data-name="raphael" data-mode="ƒ∞NAN√áLI" data-role="healing">
                    <div class="ambassador-header">
                        <div class="ambassador-name">Raphael</div>
                        <div class="ambassador-toggle" title="Aktif/Pasif">‚úì</div>
                    </div>
                    <div class="ambassador-info">
                        <div class="ambassador-role">≈ûifa, Denge</div>
                        <div class="ambassador-status">
                            <span class="ambassador-mode">ƒ∞NAN√áLI</span>
                            <span class="reputation">ƒ∞tibar: <span class="reputation-score">0.0</span></span>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="confidence">
                            <span>G√ºven</span>
                            <div class="confidence-bar">
                                <div class="confidence-level" style="width:75%">75%</div>
                            </div>
                        </div>
                        <div class="power">
                            <span>G√º√ß</span>
                            <div class="power-bar">
                                <div class="power-level" style="width:0%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="strategy-select">
                        <button data-strategy="StatArbitrageStrategy">ƒ∞statistik Arb.</button>
                        <button data-strategy="LiquidityGapStrategy">Likidite Bo≈ül.</button>
                        <button data-strategy="OverboughtOversoldStrategy">A≈üƒ±rƒ± Al/Sat</button>
                    </div>
                </div>
                
                <!-- Gabriel - ƒ∞leti≈üim El√ßisi -->
                <div class="ambassador" data-name="gabriel" data-mode="ƒ∞NAN√áLI" data-role="communication">
                    <div class="ambassador-header">
                        <div class="ambassador-name">Gabriel</div>
                        <div class="ambassador-toggle" title="Aktif/Pasif">‚úì</div>
                    </div>
                    <div class="ambassador-info">
                        <div class="ambassador-role">ƒ∞leti≈üim, Bilgi</div>
                        <div class="ambassador-status">
                            <span class="ambassador-mode">ƒ∞NAN√áLI</span>
                            <span class="reputation">ƒ∞tibar: <span class="reputation-score">0.0</span></span>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="confidence">
                            <span>G√ºven</span>
                            <div class="confidence-bar">
                                <div class="confidence-level" style="width:75%">75%</div>
                            </div>
                        </div>
                        <div class="power">
                            <span>G√º√ß</span>
                            <div class="power-bar">
                                <div class="power-level" style="width:0%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="strategy-select">
                        <button data-strategy="SmartMoneyStrategy">Akƒ±llƒ± Para</button>
                        <button data-strategy="VolumeProfileStrategy">Hacim Profili</button>
                        <button data-strategy="SentimentAnalysisStrategy">Duygu Analizi</button>
                    </div>
                </div>
                
                <!-- Michael - Sava≈ü El√ßisi -->
                <div class="ambassador" data-name="michael" data-mode="ƒ∞NAN√áLI" data-role="warfare">
                    <div class="ambassador-header">
                        <div class="ambassador-name">Michael</div>
                        <div class="ambassador-toggle" title="Aktif/Pasif">‚úì</div>
                    </div>
                    <div class="ambassador-info">
                        <div class="ambassador-role">Sava≈ü, G√º√ß</div>
                        <div class="ambassador-status">
                            <span class="ambassador-mode">ƒ∞NAN√áLI</span>
                            <span class="reputation">ƒ∞tibar: <span class="reputation-score">0.0</span></span>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="confidence">
                            <span>G√ºven</span>
                            <div class="confidence-bar">
                                <div class="confidence-level" style="width:75%">75%</div>
                            </div>
                        </div>
                        <div class="power">
                            <span>G√º√ß</span>
                            <div class="power-bar">
                                <div class="power-level" style="width:0%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="strategy-select">
                        <button data-strategy="AggressiveCandleStrategy">Agresif Mum</button>
                        <button data-strategy="LiquidationCascadeStrategy">Likid. Kaskad</button>
                        <button data-strategy="VolatilityBreakoutStrategy">Volatilite</button>
                    </div>
                </div>
                
                <!-- Yetenek D√ºƒümeleri -->
                <div class="pantheon-abilities">
                    <div class="pantheon-ability ready" data-ability="council">
                        <div class="ability-icon">üëë</div>
                        <div class="ability-name">Konsey</div>
                        <div class="cooldown-indicator">Hazƒ±r</div>
                    </div>
                    <div class="pantheon-ability ready" data-ability="reset">
                        <div class="ability-icon">üîÑ</div>
                        <div class="ability-name">Sƒ±fƒ±rla</div>
                        <div class="cooldown-indicator">Hazƒ±r</div>
                    </div>
                </div>
            </div>
                    <div class="pp-power-bar"><div class="pp-power-fill" style="width:0%"></div></div>
                </div>
            </div>
            <div class="pp-amb" id="amb-uriel" data-role="courage">
                <span class="pp-name">Uriel</span>
                <span class="pp-rep" data-rep="0">0</span>
                <span class="pp-mode" data-mode="ƒ∞NAN√áLI">ƒ∞NAN√áLI</span>
                <div class="pp-details">
                    <div class="pp-strategies">Momentum, Kƒ±rƒ±lƒ±m (Breakout)</div>
                    <div class="pp-power-bar"><div class="pp-power-fill" style="width:0%"></div></div>
                </div>
            </div>
            <div class="pp-amb" id="amb-raphael" data-role="healing">
                <span class="pp-name">Raphael</span>
                <span class="pp-rep" data-rep="0">0</span>
                <span class="pp-mode" data-mode="ƒ∞NAN√áLI">ƒ∞NAN√áLI</span>
                <div class="pp-details">
                    <div class="pp-strategies">ƒ∞statistiksel Arbitraj, Likidite</div>
                    <div class="pp-power-bar"><div class="pp-power-fill" style="width:0%"></div></div>
                </div>
            </div>
            <div class="pp-amb" id="amb-gabriel" data-role="communication">
                <span class="pp-name">Gabriel</span>
                <span class="pp-rep" data-rep="0">0</span>
                <span class="pp-mode" data-mode="ƒ∞NAN√áLI">ƒ∞NAN√áLI</span>
                <div class="pp-details">
                    <div class="pp-strategies">Akƒ±llƒ± Para, Hacim Profili, Duygu</div>
                    <div class="pp-power-bar"><div class="pp-power-fill" style="width:0%"></div></div>
                </div>
            </div>
            <div class="pp-amb" id="amb-michael" data-role="warfare">
                <span class="pp-name">Michael</span>
                <span class="pp-rep" data-rep="0">0</span>
                <span class="pp-mode" data-mode="ƒ∞NAN√áLI">ƒ∞NAN√áLI</span>
                <div class="pp-details">
                    <div class="pp-strategies">Agresif Mum, Likidasyon √áaƒülayanlarƒ±</div>
                    <div class="pp-power-bar"><div class="pp-power-fill" style="width:0%"></div></div>
                </div>
            </div>
        </div>
        <div class="pp-footer">
            <div class="pp-collective-state">
                <span class="pp-state-label">Kolektif Durum:</span>
                <span class="pp-state-value" id="pp-collective-state">Dengeli</span>
            </div>
            <div class="pp-actions">
                <button class="pp-action-btn" id="pp-action-council" title="Meclis Toplantƒ±sƒ±">üèõÔ∏è</button>
                <button class="pp-action-btn" id="pp-action-reset" title="ƒ∞tibarlarƒ± Sƒ±fƒ±rla">üîÑ</button>
            </div>
        </div>
    </aside>
    
    <!-- Kehanet Paneli -->
    <aside id="kehanet-panel" aria-label="Kehanet Paneli">
        <div class="kp-title">
            <span>üú≤ Kehanet</span>
            <span id="kp-session">‚Äî</span>
            <button class="kp-expand-btn" id="kp-expand-btn" title="Panel Geni≈ület/Daralt">‚öôÔ∏è</button>
        </div>
        <div class="kp-body">
            <div class="kp-row">
                <span class="kp-key">üõ°Ô∏è Koruma</span>
                <span class="kp-val" id="kp-guardian">Aktif</span>
            </div>
            <div class="kp-row">
                <span class="kp-key">‚öñÔ∏è Rejim</span>
                <span class="kp-val" id="kp-regime">‚Äî</span>
            </div>
            <div class="kp-row">
                <span class="kp-key">‚öîÔ∏è Nabƒ±z</span>
                <span class="kp-val" id="kp-pulse">‚Äî</span>
            </div>
            <div class="kp-row">
                <span class="kp-key">üéØ Eƒüilim</span>
                <span class="kp-val" id="kp-trend">‚Äî</span>
            </div>
            <div class="kp-divider"></div>
            <div class="kp-advanced" id="kp-advanced">
                <div class="kp-row">
                    <span class="kp-key">üß† Tahmin</span>
                    <span class="kp-val" id="kp-prediction">‚Äî</span>
                </div>
                <div class="kp-row">
                    <span class="kp-key">üîÆ Olasƒ±lƒ±k</span>
                    <span class="kp-val" id="kp-probability">‚Äî</span>
                </div>
                <div class="kp-row">
                    <span class="kp-key">‚è±Ô∏è Zaman Hedefi</span>
                    <span class="kp-val" id="kp-timeframe">‚Äî</span>
                </div>
                <div class="kp-row">
                    <span class="kp-key">üåä Likidite</span>
                    <span class="kp-val" id="kp-liquidity">‚Äî</span>
                </div>
                <div class="kp-row">
                    <span class="kp-key">üíß Baskƒ±</span>
                    <span class="kp-val" id="kp-pressure">‚Äî</span>
                </div>
                <div class="kp-chart-container">
                    <div id="kp-mini-chart" class="kp-mini-chart"></div>
                </div>
            </div>
        </div>
        <div class="kp-footer">
            <div class="kp-confidence-bar">
                <div class="kp-confidence-fill" id="kp-confidence-fill"></div>
                <div class="kp-confidence-label" id="kp-confidence-label">G√ºven: %75</div>
            </div>
            <button class="kp-refresh-btn" id="kp-refresh-btn" title="Tahminleri Yenile">‚ü≥</button>
        </div>
    </aside>
    
    <!-- Ana Men√º Sistemi -->
    <div id="main-menu-container" class="main-menu-container">
        <button id="menu-toggle-btn" class="menu-toggle-btn">
            <span class="menu-icon">‚ò∞</span>
        </button>
        
        <div id="main-menu" class="main-menu">
            <div class="menu-header">
                <h3>üèõÔ∏è Komuta Merkezi</h3>
                <button id="menu-close-btn" class="menu-close-btn">‚úñ</button>
            </div>
            
            <div class="menu-sections">
                <!-- Panteon B√∂l√ºm√º -->
                <div class="menu-section">
                    <div class="section-header" data-section="panteon">
                        <span class="section-icon">‚ö°</span>
                        <span class="section-title">Panteon Sistemi</span>
                        <span class="section-toggle">‚ñº</span>
                    </div>
                    <div class="section-content" id="panteon-content">
                        <div class="panteon-stats">
                            <div class="regime-indicator">
                                <span class="pp-state-label">Rejim:</span>
                                <span class="current-regime" id="pp-current-regime">NORMAL</span>
                            </div>
                            <div class="state-indicator">
                                <span class="pp-state-label">Durum:</span>
                                <span class="collective-state" id="pp-collective-state">HAZIR</span>
                            </div>
                        </div>
                        
                        <div class="panteon-panel">
                            <div class="pp-amb" id="amb-metatron" data-role="wisdom">
                                <div class="pp-amb-header">
                                    <span class="pp-amb-name">üëÅÔ∏è Metatron</span>
                                    <button class="pp-expand-btn">‚öôÔ∏è</button>
                                </div>
                                <div class="pp-amb-info">
                                    <span class="pp-role">Bilgelik</span>
                                    <div class="pp-amb-status">
                                        <span class="pp-mode">ƒ∞NAN√áLI</span>
                                        <span class="reputation">Rep: <span class="pp-rep">100</span></span>
                                    </div>
                                </div>
                                <div class="pp-power-container">
                                    <span>G√º√ß:</span>
                                    <div class="pp-power-bar">
                                        <div class="pp-power-fill" style="width: 75%"></div>
                                    </div>
                                    <span class="pp-power-val">75%</span>
                                </div>
                            </div>
                            
                            <div class="pp-amb" id="amb-uriel" data-role="courage">
                                <div class="pp-amb-header">
                                    <span class="pp-amb-name">üî• Uriel</span>
                                    <button class="pp-expand-btn">‚öôÔ∏è</button>
                                </div>
                                <div class="pp-amb-info">
                                    <span class="pp-role">Cesaret</span>
                                    <div class="pp-amb-status">
                                        <span class="pp-mode">ƒ∞NAN√áLI</span>
                                        <span class="reputation">Rep: <span class="pp-rep">85</span></span>
                                    </div>
                                </div>
                                <div class="pp-power-container">
                                    <span>G√º√ß:</span>
                                    <div class="pp-power-bar">
                                        <div class="pp-power-fill" style="width: 60%"></div>
                                    </div>
                                    <span class="pp-power-val">60%</span>
                                </div>
                            </div>
                            
                            <div class="pp-amb" id="amb-raphael" data-role="healing">
                                <div class="pp-amb-header">
                                    <span class="pp-amb-name">üíö Raphael</span>
                                    <button class="pp-expand-btn">‚öôÔ∏è</button>
                                </div>
                                <div class="pp-amb-info">
                                    <span class="pp-role">≈ûifa</span>
                                    <div class="pp-amb-status">
                                        <span class="pp-mode">ƒ∞NAN√áLI</span>
                                        <span class="reputation">Rep: <span class="pp-rep">90</span></span>
                                    </div>
                                </div>
                                <div class="pp-power-container">
                                    <span>G√º√ß:</span>
                                    <div class="pp-power-bar">
                                        <div class="pp-power-fill" style="width: 80%"></div>
                                    </div>
                                    <span class="pp-power-val">80%</span>
                                </div>
                            </div>
                            
                            <div class="pp-amb" id="amb-gabriel" data-role="communication">
                                <div class="pp-amb-header">
                                    <span class="pp-amb-name">üì¢ Gabriel</span>
                                    <button class="pp-expand-btn">‚öôÔ∏è</button>
                                </div>
                                <div class="pp-amb-info">
                                    <span class="pp-role">ƒ∞leti≈üim</span>
                                    <div class="pp-amb-status">
                                        <span class="pp-mode">≈û√úPHECƒ∞</span>
                                        <span class="reputation">Rep: <span class="pp-rep">70</span></span>
                                    </div>
                                </div>
                                <div class="pp-power-container">
                                    <span>G√º√ß:</span>
                                    <div class="pp-power-bar">
                                        <div class="pp-power-fill" style="width: 45%"></div>
                                    </div>
                                    <span class="pp-power-val">45%</span>
                                </div>
                            </div>
                            
                            <div class="pp-amb" id="amb-michael" data-role="warfare">
                                <div class="pp-amb-header">
                                    <span class="pp-amb-name">‚öîÔ∏è Michael</span>
                                    <button class="pp-expand-btn">‚öôÔ∏è</button>
                                </div>
                                <div class="pp-amb-info">
                                    <span class="pp-role">Sava≈ü</span>
                                    <div class="pp-amb-status">
                                        <span class="pp-mode">KIYAMET</span>
                                        <span class="reputation">Rep: <span class="pp-rep">95</span></span>
                                    </div>
                                </div>
                                <div class="pp-power-container">
                                    <span>G√º√ß:</span>
                                    <div class="pp-power-bar">
                                        <div class="pp-power-fill" style="width: 90%"></div>
                                    </div>
                                    <span class="pp-power-val">90%</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="pantheon-abilities">
                            <div class="pp-ability" data-ability="revelation">
                                <span class="ability-icon">üîÆ</span>
                                <span class="ability-name">Vahiy</span>
                                <span class="ability-status">Hazƒ±r</span>
                            </div>
                            <div class="pp-ability" data-ability="valor">
                                <span class="ability-icon">‚ö°</span>
                                <span class="ability-name">Cesaret</span>
                                <span class="ability-status">Hazƒ±r</span>
                            </div>
                            <div class="pp-ability" data-ability="restoration">
                                <span class="ability-icon">üíö</span>
                                <span class="ability-name">≈ûifa</span>
                                <span class="ability-status">Bekleme</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Kehanet B√∂l√ºm√º -->
                <div class="menu-section">
                    <div class="section-header" data-section="kehanet">
                        <span class="section-icon">üîÆ</span>
                        <span class="section-title">Kehanet Sistemi</span>
                        <span class="section-toggle">‚ñº</span>
                    </div>
                    <div class="section-content" id="kehanet-content">
                        <div class="kp-stats">
                            <div class="kp-row">
                                <span class="kp-key">Rejim:</span>
                                <span class="kp-val" id="kp-regime">NORMAL</span>
                            </div>
                            <div class="kp-row">
                                <span class="kp-key">Seans:</span>
                                <span class="kp-val" id="kp-session">AVRUPA</span>
                            </div>
                            <div class="kp-row">
                                <span class="kp-key">Koruyucu:</span>
                                <span class="kp-val" id="kp-guardian">Aktif</span>
                            </div>
                            <div class="kp-row">
                                <span class="kp-key">Nabƒ±z:</span>
                                <span class="kp-val" id="kp-pulse">0.15%</span>
                            </div>
                        </div>
                        
                        <div class="kp-divider"></div>
                        
                        <div class="kp-predictions">
                            <div class="kp-row">
                                <span class="kp-key">Eƒüilim:</span>
                                <span class="kp-val trend-up" id="kp-trend">‚ÜóÔ∏è Y√ºkseli≈ü</span>
                            </div>
                            <div class="kp-row">
                                <span class="kp-key">Tahmin:</span>
                                <span class="kp-val" id="kp-prediction">YUKARI</span>
                            </div>
                            <div class="kp-row">
                                <span class="kp-key">Olasƒ±lƒ±k:</span>
                                <span class="kp-val" id="kp-probability">%78</span>
                            </div>
                            <div class="kp-row">
                                <span class="kp-key">Zaman:</span>
                                <span class="kp-val" id="kp-timeframe">25 dk</span>
                            </div>
                        </div>
                        
                        <div class="kp-confidence-container">
                            <span class="kp-key">G√ºven:</span>
                            <div class="kp-confidence-bar">
                                <div class="kp-confidence-fill" style="width: 75%"></div>
                            </div>
                            <span class="kp-confidence-label">75%</span>
                        </div>
                        
                        <div class="kp-actions">
                            <button class="kp-refresh-btn" id="kp-refresh-btn" title="Tahminleri Yenile">üîÑ Yenile</button>
                        </div>
                    </div>
                </div>
                
                <!-- Enerji Y√∂netimi -->
                <div class="menu-section">
                    <div class="section-header" data-section="energy">
                        <span class="section-icon">‚ö°</span>
                        <span class="section-title">Enerji Y√∂netimi</span>
                        <span class="section-toggle">‚ñº</span>
                    </div>
                    <div class="section-content" id="energy-content">
                        <div class="energy-info">
                            <div class="energy-level-display">
                                <span class="energy-percentage" id="energy-percentage">80%</span>
                                <span class="energy-status-text" id="energy-status-text">Normal</span>
                            </div>
                        </div>
                        
                        <div class="energy-meter">
                            <div class="energy-fill" id="energy-fill" style="width: 80%;"></div>
                        </div>
                        
                        <div class="energy-actions">
                            <button class="energy-action-btn" onclick="window.app?.energyManager?.boostEnergy()">‚ö° G√º√ßlendir</button>
                            <button class="energy-action-btn" onclick="window.app?.energyManager?.optimizeEnergy()">üîß Optimize</button>
                            <button class="energy-action-btn" onclick="window.app?.energyManager?.recycleEnergy()">‚ôªÔ∏è Geri D√∂n√º≈üt√ºr</button>
                        </div>
                    </div>
                </div>
                
                <!-- Rit√ºel Sistemi -->
                <div class="menu-section">
                    <div class="section-header" data-section="ritual">
                        <span class="section-icon">‚ú®</span>
                        <span class="section-title">Rit√ºel Sistemi</span>
                        <span class="section-toggle">‚ñº</span>
                    </div>
                    <div class="section-content" id="ritual-content">
                        <div class="ritual-status">
                            <span>Aktif Rit√ºel: </span>
                            <span id="active-ritual-name">Yok</span>
                        </div>
                        
                        <div class="ritual-list-mini">
                            <div class="ritual-item-mini" data-ritual="trend">
                                <span class="ritual-icon">üìà</span>
                                <span class="ritual-name">Trend G√ºc√º</span>
                                <span class="ritual-status-mini">Hazƒ±r</span>
                            </div>
                            <div class="ritual-item-mini" data-ritual="protection">
                                <span class="ritual-icon">üõ°Ô∏è</span>
                                <span class="ritual-name">Koruma</span>
                                <span class="ritual-status-mini">Hazƒ±r</span>
                            </div>
                            <div class="ritual-item-mini" data-ritual="insight">
                                <span class="ritual-icon">üí°</span>
                                <span class="ritual-name">ƒ∞√ßg√∂r√º</span>
                                <span class="ritual-status-mini">Bekleme</span>
                            </div>
                        </div>
                        
                        <div class="ritual-actions">
                            <button class="ritual-action-btn" onclick="window.app?.ritualManager?.toggleRitualContainer(true)">‚öôÔ∏è Detaylar</button>
                        </div>
                    </div>
                </div>
                
                <!-- Ayarlar -->
                <div class="menu-section">
                    <div class="section-header" data-section="settings">
                        <span class="section-icon">‚öôÔ∏è</span>
                        <span class="section-title">Sistem Ayarlarƒ±</span>
                        <span class="section-toggle">‚ñº</span>
                    </div>
                    <div class="section-content" id="settings-content">
                        <div class="quick-settings">
                            <div class="setting-item">
                                <label class="setting-label">
                                    <input type="checkbox" id="quick-tts-toggle" checked>
                                    <span>üîä Sesli Bildirimler</span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">
                                    <input type="checkbox" id="quick-auto-optimize" checked>
                                    <span>ü§ñ Otomatik Optimizasyon</span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">
                                    <input type="checkbox" id="quick-combat-mode">
                                    <span>‚öîÔ∏è Sava≈ü Modu</span>
                                </label>
                            </div>
                        </div>
                        
                        <div class="settings-actions">
                            <button class="settings-action-btn" onclick="document.getElementById('open-settings-modal-btn').click()">‚öôÔ∏è Geli≈ümi≈ü Ayarlar</button>
                            <button class="settings-action-btn" onclick="window.app?.resetAllSettings?.()">üîÑ Sƒ±fƒ±rla</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Kozmik Efektler Katmanƒ± -->
    <div id="cosmic-effects-layer"></div>
    <!-- Canvas for visual effects -->
    <canvas id="effects-canvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999;"></canvas> 
    
    <!-- Ultra Kompakt Panteon Sistemi UI -->
    <div id="pantheon-ui" class="pantheon-ui">
        <div class="pantheon-header">
            <span class="pantheon-title">PANTHEON</span>
            <div class="pantheon-controls">
                <button class="pantheon-toggle-btn" title="Toggle view">‚ñº</button>
                <button class="pantheon-close" title="Close Pantheon">√ó</button>
            </div>
        </div>
        
        <div class="pantheon-content">
            <div class="pantheon-gods">
                <div class="god metatron" data-god="metatron">
                    <div class="god-info">
                        <div class="god-icon">üëÅÔ∏è</div>
                        <div class="god-details">
                            <div class="god-name">Metatron</div>
                            <div class="god-power">0%</div>
                        </div>
                    </div>
                    <div class="god-progress"><div class="god-progress-fill"></div></div>
                </div>
                
                <div class="god uriel" data-god="uriel">
                    <div class="god-info">
                        <div class="god-icon">‚öîÔ∏è</div>
                        <div class="god-details">
                            <div class="god-name">Uriel</div>
                            <div class="god-power">0%</div>
                        </div>
                    </div>
                    <div class="god-progress"><div class="god-progress-fill"></div></div>
                </div>
                
                <div class="god raphael" data-god="raphael">
                    <div class="god-info">
                        <div class="god-icon">üíä</div>
                        <div class="god-details">
                            <div class="god-name">Raphael</div>
                            <div class="god-power">0%</div>
                        </div>
                    </div>
                    <div class="god-progress"><div class="god-progress-fill"></div></div>
                </div>
                
                <div class="god gabriel" data-god="gabriel">
                    <div class="god-info">
                        <div class="god-icon">üì¢</div>
                        <div class="god-details">
                            <div class="god-name">Gabriel</div>
                            <div class="god-power">0%</div>
                        </div>
                    </div>
                    <div class="god-progress"><div class="god-progress-fill"></div></div>
                </div>
                
                <div class="god michael" data-god="michael">
                    <div class="god-info">
                        <div class="god-icon">‚öñÔ∏è</div>
                        <div class="god-details">
                            <div class="god-name">Michael</div>
                            <div class="god-power">0%</div>
                        </div>
                    </div>
                    <div class="god-progress"><div class="god-progress-fill"></div></div>
                </div>
            </div>
            
            <div class="pantheon-abilities">
                <div class="ability" id="ability-revelation" data-ability="revelation">
                    <div class="ability-icon">üîç</div>
                    <div class="ability-details">
                        <div class="ability-name">Vahiy</div>
                        <div class="ability-status">Ready</div>
                    </div>
                    <div class="ability-cooldown"></div>
                </div>
                <div class="ability" id="ability-valor" data-ability="valor">
                    <div class="ability-icon">üõ°Ô∏è</div>
                    <div class="ability-details">
                        <div class="ability-name">Cesaret</div>
                        <div class="ability-status">Ready</div>
                    </div>
                    <div class="ability-cooldown"></div>
                </div>
                <div class="ability" id="ability-restoration" data-ability="restoration">
                    <div class="ability-icon">üí´</div>
                    <div class="ability-details">
                        <div class="ability-name">≈ûifa</div>
                        <div class="ability-status">Ready</div>
                    </div>
                    <div class="ability-cooldown"></div>
                </div>
            </div>
        </div>
    </div>
    
        <div id="super-top-ticker">
        <div class="super-top-left">
            <span id="ticker-bar-symbol">BTC/USDT</span>
            <span id="ticker-bar-price">$43,250.75</span>
            <span class="price-change positive">+2.45%</span>
        </div>
        
        <!-- YENƒ∞ EMOJƒ∞ STICKER BAR -->
        <div class="emoji-sticker-bar">
            <div class="sticker-item" data-action="menu" title="Ana Men√º">
                <span class="sticker-emoji">üèõÔ∏è</span>
            </div>
            <div class="sticker-item" data-action="notifications" title="Bildirimler">
                <span class="sticker-emoji">üì¢</span>
                <span class="notification-badge" id="notification-count">3</span>
            </div>
            <div class="sticker-item" data-action="energy" title="Enerji: 80%">
                <span class="sticker-emoji">‚ö°</span>
                <div class="mini-energy-bar">
                    <div class="mini-energy-fill" style="width: 80%"></div>
                </div>
            </div>
            <div class="sticker-item" data-action="signals" title="Aktif Sinyaller">
                <span class="sticker-emoji">üéØ</span>
                <span class="signal-badge" id="signal-count">2</span>
            </div>
            <div class="sticker-item" data-action="pantheon" title="Panteon G√ºc√º">
                <span class="sticker-emoji">üëë</span>
                <div class="mini-power-indicator">
                    <div class="power-dot active"></div>
                    <div class="power-dot active"></div>
                    <div class="power-dot"></div>
                </div>
            </div>
            <div class="sticker-item" data-action="regime" title="Piyasa Rejimi: Normal">
                <span class="sticker-emoji" id="regime-emoji">üåä</span>
            </div>
            <div class="sticker-item" data-action="prophet" title="Kehanet G√ºveni: 75%">
                <span class="sticker-emoji">üîÆ</span>
                <div class="mini-confidence-circle">
                    <span class="confidence-text">75</span>
                </div>
            </div>
            <div class="sticker-item" data-action="status" title="Sistem Durumu">
                <span class="sticker-emoji">üíö</span>
            </div>
        </div>
        <!-- MASA√úST√ú BUTONLARI -->
        <div class="super-top-right-buttons desktop-only">
            <button id="main-controls-btn" class="btn btn-tiny">Komuta Merkezi</button>
            <button id="chart-view-btn" class="btn btn-tiny">Grafik</button>
            <button id="heatmap-view-btn" class="btn btn-tiny">Isƒ± Haritasƒ±</button>
            <button id="fullscreen-chart-btn" class="btn btn-tiny">Tam Ekran Grafik</button>
            <button id="honor-board-btn" class="btn btn-tiny">≈ûeref Tablosu</button>
            <button id="banned-board-btn" class="btn btn-tiny">Banlƒ±lar</button>
            <button id="open-settings-modal-btn" class="btn btn-tiny">Ayarlar</button>
        </div>
                <!-- YENƒ∞ MOBƒ∞L BUTONLARI -->
        <div class="super-top-right-buttons mobile-only">
            <button id="mobile-fullscreen-chart-btn" class="btn btn-tiny">Tam Ekran</button>
            <!-- D√úZELTME: Yeni Log butonu eklendi -->
            <button id="mobile-open-log-modal-btn" class="btn btn-tiny">üìú Log</button>
            <button id="mobile-open-settings-modal-btn" class="btn btn-tiny btn-success">Ayarlar</button>
        </div>

    </div>


    <!-- Yeni Sinyal Barƒ± -->
    <div id="signal-progress-bar-container">
        <div class="signal-bar-wrapper">
            <div class="signal-bar-label">BUY SINYAL G√úC√ú</div>
            <div class="signal-bar">
                <div id="buy-signal-bar-fill" class="signal-bar-fill buy"></div>
            </div>
            <div id="buy-signal-score-text" class="signal-score-text">0.0</div>
        </div>
        <div class="signal-bar-wrapper">
            <div class="signal-bar-label">SELL SINYAL G√úC√ú</div>
            <div class="signal-bar">
                <div id="sell-signal-bar-fill" class="signal-bar-fill sell"></div>
            </div>
            <div id="sell-signal-score-text" class="signal-score-text">0.0</div>
        </div>
    </div>

    <div class="container">
                                <header class="header">
            <div id="header-main-bar" class="header-top-bar">
                <div class="header-left-controls">
                    <button id="mobile-toggle-controls-btn" class="btn btn-tiny mobile-only" title="Kontrolleri A√ß/Kapat">‚ò∞</button>
                </div>
                <div class="header-center-title" title="Paneli a√ß/kapatmak i√ßin √ßift tƒ±kla">
                    <span class="header-title-text">KOMUTA MERKEZƒ∞ KONTROLLERƒ∞</span>
                </div>
                <div class="header-right-controls">
                    <!-- D√úZELTME: Eksik olan Grafik butonu eklendi -->
                    <button id="mobile-chart-view-btn" class="btn btn-tiny mobile-only" title="Grafik">üìà</button>
                    <button id="mobile-heatmap-view-btn" class="btn btn-tiny mobile-only" title="Isƒ± Haritasƒ±">üî•</button>
                    <button id="mobile-honor-board-btn" class="btn btn-tiny mobile-only" title="≈ûeref Tablosu">üèÜ</button>
                    <button id="mobile-banned-board-btn" class="btn btn-tiny mobile-only" title="Banlƒ±lar">BAN</button>
                </div>
            </div>
            <div class="header-collapsible-content">
                <div class="main-controls">
                    <input type="text" id="symbol-input" class="form-control" placeholder="√ñrn: BTC, ETH, SOL">
                    <select id="timeframe-select" class="form-control">
                        <option value="1m">1m</option><option value="5m">5m</option><option value="15m" selected>15m</option><option value="1h">1h</option><option value="4h">4h</option>
                    </select>
                    <div class="status">
                        <div id="connection-status" class="status-dot"></div>
                        <span id="connection-text">BAƒûLANTI YOK</span>
                    </div>
                    <button id="theme-toggle-btn" class="btn">Tema</button>
                    <button id="start-btn" class="btn btn-success">Sƒ∞STEMƒ∞ BA≈ûLAT</button>
                    <button id="stop-btn" class="btn btn-danger" disabled>DURDUR</button>
                    <button id="clear-markers-btn" class="btn">Grafik Sinyallerini Sil</button> 
                </div>
                <div class="price-display">
                    <div class="price-item"><div class="price-label">Fƒ∞YAT</div><div class="price-value" id="current-price">-</div></div>
                    <div class="price-item"><div class="price-label">24s DEƒûƒ∞≈ûƒ∞M</div><div class="price-value" id="price-change-24h">-</div></div>
                    <div class="price-item"><div class="price-label">24s HACƒ∞M</div><div class="price-value" id="volume-24h">-</div></div>
                    <div class="price-item"><div class="price-label">VOLATƒ∞Lƒ∞TE (ATR)</div><div class="price-value" id="atr-value">-</div></div>
                    <div class="price-item countdown"><span id="candle-countdown">--:--</span></div>
                </div>
            </div>
        </header>




        <main class="main-grid">
            <section class="center-panel panel">
                <div class="data-container">
                    <div class="data-grid" id="chart-container-view">
                        <div id="live-chart"></div>
                        <div class="chart-zoom-controls"> 
                            <button id="chart-zoom-in" class="btn btn-tiny">+</button>
                            <button id="chart-zoom-out" class="btn btn-tiny">-</button>
                            <button id="chart-zoom-reset" class="btn btn-tiny">Sƒ±fƒ±rla</button>
                        </div>
                        <button id="exit-fullscreen-btn" class="btn btn-tiny hidden-view" title="Tam Ekrandan √áƒ±k">&times;</button>
                        <div id="chart-countdown-overlay" class="hidden-view">--:--</div>
                    </div>
                    <div class="heatmap-container" id="heatmap-container-view">
                        <div class="panel-title" style="border-top: 1px solid var(--border-color); border-bottom: none;">EMƒ∞R DEFTERƒ∞ ISI HARƒ∞TASI</div>
                        <canvas id="orderbook-heatmap"></canvas>
                    </div>
                </div>
                <div class="resize-handle"></div>
            </section>
        </main>
    </div>
    
    <div id="notifications-container" class="notifications"></div>
    
    <!-- Enerji Kutusu -->
    <div id="energy-box" class="energy-box">
        <div class="energy-box-header">
            <div class="energy-box-title">Sistem Enerjisi</div>
            <div class="energy-box-close" onclick="window.app.energyManager.toggleEnergyBox(false)">‚úñ</div>
        </div>
        <div class="energy-meter">
            <div id="energy-fill" class="energy-fill" style="width: 80%;"></div>
        </div>
        <div class="energy-info">
            <span id="energy-level">80%</span>
            <span id="energy-time">12:05:21</span>
        </div>
        <div class="energy-status" id="energy-status">Normal i≈üleyi≈ü s√ºr√ºyor</div>
        <div class="energy-actions">
            <div class="energy-action-btn" onclick="window.app.energyManager.boostEnergy()">G√º√ßlendir</div>
            <div class="energy-action-btn" onclick="window.app.energyManager.optimizeEnergy()">Optimize Et</div>
            <div class="energy-action-btn" onclick="window.app.energyManager.recycleEnergy()">Geri D√∂n√º≈üt√ºr</div>
        </div>
    </div>
    
    <!-- Rit√ºel Sistemi -->
    <div id="ritual-container" class="ritual-container hidden">
        <div class="ritual-header">
            <div class="ritual-title">
                <div class="ritual-icon"></div>
                Rit√ºel Sistemi
            </div>
            <div class="ritual-close" onclick="window.app.ritualManager.toggleRitualContainer(false)">‚úñ</div>
        </div>
        
        <div class="ritual-description">
            Rit√ºeller, piyasa g√ºc√ºn√ºz√º artƒ±ran √∂zel eylemlerdir. Her rit√ºel farklƒ± etkilere ve s√ºrelere sahiptir. Rit√ºeller enerji gerektirir ve aktifle≈ütirmek i√ßin hazƒ±rlƒ±k s√ºreci gerekir.
        </div>
        
        <div class="ritual-list" id="ritual-list">
            <!-- Rit√ºeller JavaScript tarafƒ±ndan dinamik olarak eklenecek -->
        </div>
        
        <div class="ritual-actions">
            <div class="ritual-btn" onclick="window.app.ritualManager.prepareSelectedRitual()">Hazƒ±rla</div>
            <div class="ritual-btn primary" onclick="window.app.ritualManager.activateSelectedRitual()">Aktifle≈ütir</div>
        </div>
        
        <div class="ritual-status" id="ritual-status">
            Aktif rit√ºel yok. Bir rit√ºel se√ßip hazƒ±rlayƒ±n.
        </div>
    </div>

    <!-- Dikey ƒ∞kon Paneli -->
    <div class="vertical-icon-panel">
        <button id="notifications-btn" class="vertical-icon-btn" title="Bildirimler">üì¢</button>
        <button id="pantheon-toggle-btn" class="vertical-icon-btn" title="Panteon Sistemi">üëë</button>
        <button id="energy-toggle-btn" class="vertical-icon-btn" title="Enerji Y√∂netimi">‚ö°</button>
        <button id="ritual-toggle-btn" class="vertical-icon-btn" title="Rit√ºel Sistemi">‚ú®</button>
        <button id="quick-settings-btn" class="vertical-icon-btn" title="Hƒ±zlƒ± Ayarlar">‚öôÔ∏è</button>
        <button id="vertical-stats-btn" class="vertical-icon-btn" title="ƒ∞statistikler">üìä</button>
        <button id="vertical-log-btn" class="vertical-icon-btn" title="Log">üìú</button>
    </div>

    <!-- AYARLAR MODAL -->
    <div id="settings-modal-overlay">
        <div class="settings-modal-content">
            <div class="settings-modal-header">
                <span>AYARLAR & OPTƒ∞Mƒ∞ZASYON</span>
                <button class="close-btn" id="close-settings-modal-btn">&times;</button>
            </div>
            <div class="settings-modal-body">
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Temel Parametreler</div>
                    <div class="form-group"><label class="form-label">Min. Uyum Skoru (1-10)</label><input type="range" id="modal-confluence-threshold" class="form-control" min="1" max="10" value="3" step="1"></div>
                    <div class="form-group"><label class="form-label">RSI Periyodu</label><input type="number" id="modal-param-rsi-period" class="form-control" value="14"></div>
                    <div class="form-group"><label class="form-label">ATR Periyodu</label><input type="number" id="modal-param-atr-period" class="form-control" value="14"></div>
                    <div class="form-group"><label class="form-label">Duvar Tespiti (BTC Miktarƒ±)</label><input type="number" id="modal-param-wall-btc" class="form-control" value="20"></div>
                    <div class="form-group"><label class="form-label">Risk/√ñd√ºl Oranƒ± (R/R)</label><input type="number" id="modal-param-rr-ratio" class="form-control" value="1.5" step="0.1"></div>
                </div>
                <div
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Cooldown Ayarlarƒ±</div>
                    <div class="form-group"><label class="form-label">Genel Sinyal Cooldown (ms)</label><input type="number" id="modal-signal-cooldown-ms" class="form-control" value="15000" min="0" step="100"></div>
                    <div class="form-group"><label class="form-label">Aynƒ± Y√∂n Sinyal Cooldown (ms)</label><input type="number" id="modal-same-direction-cooldown-ms" class="form-control" value="30000" min="0" step="100"></div>
                    <div class="form-group"><label class="form-label">Ters Y√∂n Cooldown (ms)</label><input type="number" id="modal-opposite-direction-cooldown-ms" class="form-control" value="20000" min="0" step="100"></div>
                    <div class="form-group"><label class="form-label">Ters Y√∂n Histerezis (+Puan)</label><input type="number" id="modal-reverse-hysteresis-points" class="form-control" value="2" min="0" step="1"></div>
                    <div class="form-group"><label class="form-label">Proposal Timeout (ms)</label><input type="number" id="modal-proposal-timeout-ms" class="form-control" value="3000" min="500" step="100"></div>
                    <div class="form-group"><label class="form-label">Strateji Teklifi Cooldown (ms)</label><input type="number" id="modal-strategy-proposal-cooldown-ms" class="form-control" value="10000" min="0" step="100"></div>
                </div>
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Geli≈ümi≈ü √ñzellikler</div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-spoof-detection" class="feature-toggle" checked> Spoof Tespiti</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-cusum-drift" class="feature-toggle" checked> CUSUM Sapma Tespiti</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-risk-guardian" class="feature-toggle" checked> Risk Koruyucu (Kill Switch)</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-auto-optimize" class="feature-toggle" checked> Oto-Optimizasyon</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-auto-toggle-strat" class="feature-toggle" checked> Stratejileri Oto-Ayarla</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-breakeven-trail" class="feature-toggle" checked> Maliyete √áek/Takip Eden SL</label></div>
                    <div class="form-group"><label class="form-label">BE R Oranƒ±</label><input type="number" id="modal-be-at-r" class="form-control" value="0.8" step="0.1"></div>
                    <div class="form-group"><label class="form-label">Trailing Ba≈ülangƒ±√ß R Oranƒ±</label><input type="number" id="modal-trail-after-r" class="form-control" value="1.5" step="0.1"></div>
                    <div class="form-group"><label class="form-label">Trailing K√¢rƒ± R Oranƒ±</label><input type="number" id="modal-trail-to-r" class="form-control" value="0.5" step="0.1"></div>
                </div>

                <!-- YENƒ∞ EKLENEN B√ñL√úM BA≈ûLANGICI -->
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Sinyal Teyit & Geli≈ümi≈ü Filtreleme</div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-candle-confirm" class="feature-toggle" checked> Sinyal i√ßin Mum Kapanƒ±≈üƒ±nƒ± Bekle</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-mtf-confirm" class="feature-toggle" checked> √úst Zaman Dilimi Trend Teyidi</label></div>
                    <div class="form-group">
                        <label class="form-label">MTF Zaman Dilimi</label>
                        <select id="modal-mtf-timeframe" class="form-control">
                            <option value="5m">5m</option>
                            <option value="15m" selected>15m</option>
                            <option value="1h">1h</option>
                            <option value="4h">4h</option>
                        </select>
                    </div>
                     <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-dynamic-sizing" class="feature-toggle" checked> Sinyal G√ºc√ºne G√∂re Dinamik Boyutlandƒ±rma</label></div>
                    <hr style="border-color: var(--border-color); margin: 10px 0;">
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-tts" class="feature-toggle" checked> Sesli Bildirimler</label></div>
                    <div class="form-group">
                        <label class="form-label">Ses Se√ßimi</label>
                        <select id="modal-tts-voice-select" class="form-control"></select>
                    </div>
                </div>
                <!-- YENƒ∞ EKLENEN B√ñL√úM SONU -->

                <div class="settings-group" style="grid-column: 1 / -1;">
                     <div class="panel-title" style="margin-bottom: 10px;">Aktif Stratejiler</div>
                    <div id="modal-strategy-toggles" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 5px;"></div>
                </div>
                <div class="settings-group" style="grid-column: 1 / -1;">
                    <div class="panel-title" style="margin-bottom: 10px;">Sinyal Ge√ßmi≈üi ve Analiz</div>
                    <div class="data-table-container" style="max-height: 300px;">
                        <table class="data-table">
                            <thead>
                                <tr>
                                    <th>Zaman</th>
                                    <th>Sembol</th>
                                    <th>Tip</th>
                                    <th>Fiyat</th>
                                    <th>TP</th>
                                    <th>SL</th>
                                    <th>Skor</th>
                                    <th>Katkƒ±</th>
                                    <th>Boyut</th>
                                    <th>Durum</th>
                                    <th>Not</th>
                                </tr>
                            </thead>
                            <tbody id="modal-signals-body"></tbody>
                        </table>
                    </div>
                    <button id="modal-clear-signals-btn" class="btn btn-danger btn-sm" style="margin-top: 10px;">T√ºm Sinyalleri Sil</button>
                    <div id="modal-stats-container" style="margin-top: 15px;"></div>
                </div>
            </div>
            <div class="settings-modal-footer">
                <button id="reset-all-settings-btn" class="btn btn-danger">AYARLARI SIFIRLA</button>
                <button id="save-settings-btn" class="btn btn-success">AYARLARI KAYDET</button>
            </div>
        </div>
    </div>
    <!-- YENƒ∞ LOG PANELƒ∞ (MODAL) -->
    <div id="log-modal-overlay">
        <div class="log-modal-content">
            <div class="log-modal-header">
                <span>Sƒ∞STEM LOGLARI & G√úNL√úK</span>
                <div>
                    <button id="export-logs-btn" class="btn btn-sm btn-success">Loglarƒ± Dƒ±≈üa Aktar</button>
                    <button class="close-btn" id="close-log-modal-btn">&times;</button>
                </div>
            </div>
            <div class="log-modal-body">
                <pre id="log-output"></pre>
            </div>
        </div>
    </div>

   

    <!-- ≈ûEREF TABLOSU MODAL -->
    <div id="honor-modal-overlay" style="position:fixed; inset:0; background:rgba(0,0,0,0.7); display:none; z-index:2600; align-items:center; justify-content:center;">
      <div style="background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; width:90%; max-width:900px; max-height:90%; overflow:auto;">
        <div style="padding:10px; border-bottom:1px solid var(--border-color); display:flex; justify-content:space-between; align-items:center;">
          <div style="font-weight:700; color:var(--primary)">≈ûeref Tablosu</div>
          <button id="close-honor-modal" class="btn btn-tiny">Kapat</button>
        </div>
        <div id="honor-modal-body" style="padding:12px;"></div>
      </div>
    </div>

<script>
    // Sinyal sesleri
    function playSignal(type) {
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            if (type === 'buy') {
                oscillator.type = 'triangle'; oscillator.frequency.value = 1000;
            } else if (type === 'sell') {
                oscillator.type = 'square'; oscillator.frequency.value = 400;
            } else if (type === 'combat') {
                oscillator.type = 'sawtooth'; oscillator.frequency.value = 800; 
                gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1);
                oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 1);
                return;
            }
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.5);
        } catch (error) { console.log('Ses √ßalƒ±namadƒ±:', error); }
    }
    
    // Ses sentez motoruyla geli≈ümi≈ü sesli bildirim fonksiyonu
    function playSoundAlert(type, priority = 1) {
        try {
            if (!window.audioContext) {
                window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            const audioContext = window.audioContext;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filterNode = audioContext.createBiquadFilter();
            
            oscillator.connect(filterNode);
            filterNode.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Bildirim t√ºr√ºne g√∂re ses ayarlarƒ±
            switch (type) {
                case 'success':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(660, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(880, audioContext.currentTime + 0.1);
                    filterNode.type = 'lowpass';
                    filterNode.frequency.value = 1500;
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.4);
                    break;
                    
                case 'warning':
                case 'alert':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(330, audioContext.currentTime + 0.15);
                    filterNode.type = 'bandpass';
                    filterNode.frequency.value = 500;
                    filterNode.Q.value = 3;
                    gainNode.gain.setValueAtTime(0.25 * Math.min(priority/2, 1), audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
                    
                case 'error':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(196, audioContext.currentTime + 0.2);
                    filterNode.type = 'highpass';
                    filterNode.frequency.value = 150;
                    gainNode.gain.setValueAtTime(0.3 * Math.min(priority/2, 1), audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.6);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.6);
                    break;
                    
                case 'notification':
                default:
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 523.25; // C5
                    filterNode.type = 'lowpass';
                    filterNode.frequency.value = 800;
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
            }
            
            // Y√ºksek √∂ncelikli bildirimlerde ikincil ses
            if (priority >= 4) {
                setTimeout(() => {
                    const osc2 = audioContext.createOscillator();
                    const gain2 = audioContext.createGain();
                    osc2.connect(gain2);
                    gain2.connect(audioContext.destination);
                    
                    osc2.type = 'sine';
                    osc2.frequency.value = 880;
                    gain2.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gain2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    
                    osc2.start(audioContext.currentTime);
                    osc2.stop(audioContext.currentTime + 0.15);
                }, 300);
            }
            
        } catch (error) {
            console.error('Ses sentezleme hatasƒ±:', error);
        }
    }

    /* =========================
       G√ñRSELLE≈ûTƒ∞RME Y√ñNETƒ∞Cƒ∞LERƒ∞
       ========================= */
        class AdvancedNotificationCenter {
        constructor(app) {
            this.app = app;
            this.container = document.getElementById('notifications-container');
            this.notifications = [];
            this.maxHistory = 50; // Maximum number of notifications to keep in history
            this.maxVisibleNotifications = 10; // How many notifications to show at once
            this.groupSimilarTimeWindow = 5000; // Group similar notifications within 5 seconds
            
            // Load history from localStorage if available
            this.loadHistory();
            
            // Create notification categories
            this.categories = {
                system: { icon: 'üîß', sound: false, color: 'var(--text-secondary)' },
                trade: { icon: 'üìä', sound: true, color: 'var(--primary)' },
                alert: { icon: '‚ö†Ô∏è', sound: true, color: 'var(--neutral)' },
                success: { icon: '‚úÖ', sound: true, color: 'var(--positive)' },
                error: { icon: '‚ùå', sound: true, color: 'var(--negative)' }
            };
            
            this.soundEnabled = true;
            this.priorityThreshold = 2; // Priority level for playing sounds (1-5)
            
            // Initialize UI
            this.initStyles();
            this.initNotificationPanel();
        }
        
        initStyles() {
            // Add custom styles for notifications if not already added
            if (!document.getElementById('notification-center-styles')) {
                const style = document.createElement('style');
                style.id = 'notification-center-styles';
                style.textContent = `
                    /* Advanced Notification Center Styles */
                    .notifications { 
                        position: fixed; 
                        bottom: 15px; 
                        left: 15px;
                        z-index: 2000; 
                        width: 320px;
                        max-height: 80vh;
                        overflow-y: auto;
                        display: flex;
                        flex-direction: column;
                        gap: 8px;
                        padding-right: 8px;
                    }

                    .notification { 
                        background: rgba(22, 27, 34, 0.95);
                        backdrop-filter: blur(5px);
                        border: 1px solid var(--border-color); 
                        border-left-width: 4px; 
                        border-radius: 6px; 
                        padding: 10px 12px;
                        font-size: 12px;
                        box-shadow: 0 3px 10px rgba(0,0,0,0.3); 
                        animation: slide-in 0.3s ease-out;
                        transition: opacity 0.3s ease, transform 0.3s ease;
                        overflow: hidden;
                    }

                    .notification-control-panel {
                        background: var(--panel-bg);
                        border: 1px solid var(--border-color);
                        border-radius: 4px;
                        padding: 5px 8px;
                        margin-bottom: 8px;
                    }

                    .notification-header {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        margin-bottom: 5px;
                        font-size: 11px;
                        font-weight: bold;
                        color: var(--text-secondary);
                    }

                    .notification-header div {
                        display: flex;
                        gap: 5px;
                    }

                    .notification-icon {
                        font-size: 14px;
                        margin-right: 8px;
                        flex-shrink: 0;
                    }

                    .notification-priority {
                        font-size: 9px;
                        color: var(--primary);
                        letter-spacing: 1px;
                    }

                    .notification-close {
                        cursor: pointer;
                        font-size: 16px;
                        line-height: 1;
                        opacity: 0.7;
                        transition: opacity 0.2s;
                    }

                    .notification-close:hover {
                        opacity: 1;
                    }

                    .notification-content {
                        flex-grow: 1;
                        line-height: 1.4;
                        word-break: break-word;
                        position: relative;
                    }

                    .notification-time {
                        font-size: 9px;
                        color: var(--text-secondary);
                        margin-top: 2px;
                    }

                    .notification-count {
                        position: absolute;
                        top: -8px;
                        right: -5px;
                        background: var(--primary);
                        color: #000;
                        border-radius: 10px;
                        padding: 1px 6px;
                        font-size: 10px;
                        font-weight: bold;
                    }

                    /* Category-specific styles */
                    .notification.system { border-left-color: var(--text-secondary); }
                    .notification.trade { border-left-color: var(--primary); }
                    .notification.alert { border-left-color: var(--neutral); }
                    .notification.success { border-left-color: var(--positive); }
                    .notification.error { border-left-color: var(--negative); }
                    
                    .high-priority {
                        border-left-width: 6px !important;
                        animation: pulse-highlight 2s infinite;
                    }

                    /* Animation keyframes */
                    @keyframes slide-in {
                        from { transform: translateX(-100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    
                    @keyframes pulse-highlight {
                        0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4); }
                        70% { box-shadow: 0 0 0 8px rgba(255, 255, 255, 0); }
                        100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
                    }
                    
                    /* Notification history modal */
                    #notification-history-modal .modal-body {
                        max-height: 400px;
                        overflow-y: auto;
                    }
                    
                    .notification-filters {
                        display: flex;
                        gap: 5px;
                        margin-bottom: 10px;
                        flex-wrap: wrap;
                    }
                    
                    .notification-filters .filter {
                        padding: 3px 8px;
                        border-radius: 12px;
                        background: var(--panel-bg);
                        border: 1px solid var(--border-color);
                        font-size: 11px;
                        cursor: pointer;
                    }
                    
                    .notification-filters .filter.active {
                        background: var(--primary);
                        color: #000;
                    }
                    
                    #notification-history-list {
                        display: flex;
                        flex-direction: column;
                        gap: 8px;
                    }
                    
                    /* Responsive adjustments */
                    @media screen and (max-width: 768px) {
                        .notifications {
                            width: 85%;
                            max-width: 320px;
                        }
                        
                        .notification {
                            padding: 8px 10px;
                            font-size: 11px;
                        }
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
        initNotificationPanel() {
            // Create container if it doesn't exist
            if (!this.container) {
                this.container = document.createElement('div');
                this.container.id = 'notifications-container';
                this.container.className = 'notifications';
                document.body.appendChild(this.container);
            }
            
            // Create history modal but don't attach to DOM yet
            this.createHistoryModal();
            
            // Not adding notification control panel here anymore
            // It's now handled in the initApp() function with the vertical icon panel
        }
        
        /**
         * Create the notification history modal
         */
        createHistoryModal() {
            // Remove existing modal if any
            const existingModal = document.getElementById('notification-history-modal');
            if (existingModal) existingModal.remove();
            
            const modal = document.createElement('div');
            modal.id = 'notification-history-modal';
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>Bildirim Ge√ßmi≈üi</h3>
                        <span class="close-modal">&times;</span>
                    </div>
                    <div class="modal-body">
                        <div class="notification-filters">
                            <button class="filter active" data-filter="all">T√ºm√º</button>
                            <button class="filter" data-filter="trade">ƒ∞≈ülem</button>
                            <button class="filter" data-filter="alert">Uyarƒ±</button>
                            <button class="filter" data-filter="success">Ba≈üarƒ±lƒ±</button>
                            <button class="filter" data-filter="error">Hata</button>
                            <button class="filter" data-filter="system">Sistem</button>
                        </div>
                        <div id="notification-history-list"></div>
                    </div>
                    <div class="modal-footer">
                        <button id="clear-notifications-history" class="btn btn-danger">Ge√ßmi≈üi Temizle</button>
                    </div>
                </div>
            `;
            
            // Append to body but keep it hidden
            document.body.appendChild(modal);
            
            // Add event listeners
            const closeBtn = modal.querySelector('.close-modal');
            closeBtn.addEventListener('click', () => {
                modal.style.display = 'none';
            });
            
            const filters = modal.querySelectorAll('.filter');
            filters.forEach(filter => {
                filter.addEventListener('click', (e) => {
                    filters.forEach(f => f.classList.remove('active'));
                    e.target.classList.add('active');
                    this.filterHistory(e.target.getAttribute('data-filter'));
                });
            });
            
            document.getElementById('clear-notifications-history').addEventListener('click', () => {
                this.clearHistory();
                this.notify('Bildirim ge√ßmi≈üi temizlendi', 'system', 1);
                modal.style.display = 'none';
            });
        }
        
        /**
         * Display a new notification
         * @param {string} message - The notification message
         * @param {string} category - Notification category (system, trade, alert, success, error)
         * @param {number} priority - Priority level (1-5)
         * @param {number} timeout - How long to display (ms)
         */
        notify(message, category = 'system', priority = 2, timeout = 5000) {
            if (!this.container) return;
            
            // Default category if invalid
            if (!this.categories[category]) category = 'system';
            
            // Check for similar recent notifications to avoid spam
            if (this.shouldGroupWithSimilar(message, category)) {
                return;
            }
            
            // Generate unique ID
            const notificationId = 'notify-' + Date.now() + '-' + Math.random().toString(36).substr(2, 5);
            const timestamp = new Date();
            
            // Create notification element
            const notification = document.createElement('div');
            notification.id = notificationId;
            notification.className = `notification ${category}`;
            notification.setAttribute('data-id', notificationId);
            if (priority >= 4) notification.classList.add('high-priority');
            
            // Build notification content
            const catInfo = this.categories[category];
            notification.innerHTML = `
                <div class="notification-header">
                    <span class="notification-icon">${catInfo.icon}</span>
                    <span class="notification-priority">${'‚Ä¢'.repeat(priority)}</span>
                    <span class="notification-close">&times;</span>
                </div>
                <div class="notification-content">
                    ${message}
                    <div class="notification-time">${timestamp.toLocaleTimeString()}</div>
                </div>
            `;
            
            // Add to DOM
            const controlPanel = this.container.querySelector('.notification-control-panel');
            if (controlPanel && controlPanel.nextSibling) {
                this.container.insertBefore(notification, controlPanel.nextSibling);
            } else {
                this.container.appendChild(notification);
            }
            
            // Add to history
            this.addToHistory({
                id: notificationId,
                message,
                category,
                priority,
                timestamp
            });
            
            // Play sound for high priority notifications
            if (this.soundEnabled && priority >= this.priorityThreshold) {
                this.playNotificationSound(category, priority);
            }
            
            // Add close event
            const closeBtn = notification.querySelector('.notification-close');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    notification.remove();
                });
            }
            
            // Clean up old notifications
            this.cleanupOldNotifications();
            
            // Auto-remove after timeout
            setTimeout(() => {
                if (notification.parentNode) {
                    // Add fade-out animation
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateX(-100%)';
                    setTimeout(() => notification.remove(), 300);
                }
            }, timeout);
            
            return notification;
        }
        
        /**
         * Determine if a similar notification was recently shown
         */
        shouldGroupWithSimilar(message, category) {
            const now = Date.now();
            const similar = this.notifications.find(n => 
                n.category === category && 
                this.isSimilarMessage(n.message, message) && 
                (now - n.timestamp < this.groupSimilarTimeWindow)
            );
            
            if (similar) {
                // Update the existing notification instead of creating a new one
                const existingNotification = document.querySelector(`.notification.${category}[data-id="${similar.id}"]`);
                if (existingNotification) {
                    const countBadge = existingNotification.querySelector('.notification-count');
                    if (countBadge) {
                        countBadge.textContent = (parseInt(countBadge.textContent) || 1) + 1;
                    } else {
                        const contentDiv = existingNotification.querySelector('.notification-content');
                        if (contentDiv) {
                            contentDiv.innerHTML += `<span class="notification-count">2</span>`;
                        }
                    }
                    // Reset the timestamp for this notification
                    similar.timestamp = now;
                    return true;
                }
            }
            
            return false;
        }
        
        /**
         * Compare messages for similarity
         */
        isSimilarMessage(msg1, msg2) {
            // Basic similarity check - can be enhanced with more sophisticated comparison
            if (msg1 === msg2) return true;
            
            // Check for pattern-based similarities (e.g., only numbers differ)
            const normalized1 = msg1.replace(/\d+(\.\d+)?%?/g, 'X');
            const normalized2 = msg2.replace(/\d+(\.\d+)?%?/g, 'X');
            
            return normalized1 === normalized2;
        }
        
        /**
         * Add notification to history and save
         */
        addToHistory(notification) {
            // Add to history array
            this.notifications.unshift(notification);
            
            // Trim history if needed
            if (this.notifications.length > this.maxHistory) {
                this.notifications = this.notifications.slice(0, this.maxHistory);
            }
            
            // Save to localStorage
            this.saveHistory();
        }
        
        /**
         * Play sound notification
         */
        playNotificationSound(category, priority) {
            try {
                // Try to use app's built-in sound if available
                if (this.app.settings?.features?.enableTts && priority >= 3 && this.categories[category].sound) {
                    if (typeof this.app.playSignal === 'function') {
                        // Use existing signal player if available
                        if (category === 'error' || category === 'alert') {
                            this.app.playSignal('alert');
                        } else if (category === 'success' || category === 'trade') {
                            this.app.playSignal('combat');
                        }
                        return;
                    }
                }
                
                // Fallback to Web Audio API
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Different sounds for different categories
                switch(category) {
                    case 'success':
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(880, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(1320, audioContext.currentTime + 0.1);
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                    case 'alert':
                    case 'error':
                        oscillator.type = 'triangle';
                        oscillator.frequency.setValueAtTime(660, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(330, audioContext.currentTime + 0.15);
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.4);
                        break;
                    case 'trade':
                        oscillator.type = 'sawtooth';
                        oscillator.frequency.setValueAtTime(priority >= 4 ? 880 : 440, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;
                    default:
                        oscillator.type = 'sine';
                        oscillator.frequency.value = 440;
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.1);
                }
            } catch (error) {
                console.error('Bildirim sesi √ßalƒ±namadƒ±:', error);
            }
        }
        
        /**
         * Remove old notifications to maintain visibility limit
         */
        cleanupOldNotifications() {
            // Get all current notification elements (excluding control panel)
            const notifElements = Array.from(this.container.querySelectorAll('.notification')).filter(
                el => !el.classList.contains('notification-control-panel')
            );
            
            // If we're over the limit, remove oldest ones
            if (notifElements.length > this.maxVisibleNotifications) {
                const toRemove = notifElements.slice(this.maxVisibleNotifications);
                toRemove.forEach(el => el.remove());
            }
        }
        
        /**
         * Clear all visible notifications
         */
        clearAll() {
            const notifications = this.container.querySelectorAll('.notification');
            notifications.forEach(notification => {
                // Don't remove the control panel
                if (!notification.classList.contains('notification-control-panel')) {
                    notification.remove();
                }
            });
        }
        
        /**
         * Clear notification history and save
         */
        clearHistory() {
            this.notifications = [];
            this.saveHistory();
        }
        
        /**
         * Save notification history to localStorage
         */
        saveHistory() {
            try {
                localStorage.setItem('utc_notifications', JSON.stringify(this.notifications));
            } catch (e) {
                console.error('Failed to save notification history', e);
            }
        }
        
        /**
         * Load notification history from localStorage
         */
        loadHistory() {
            try {
                const saved = localStorage.getItem('utc_notifications');
                if (saved) {
                    this.notifications = JSON.parse(saved);
                    
                    // Convert date strings back to Date objects
                    this.notifications.forEach(n => {
                        if (typeof n.timestamp === 'string') {
                            n.timestamp = new Date(n.timestamp).getTime();
                        }
                    });
                }
            } catch (e) {
                console.error('Failed to load notification history', e);
                this.notifications = [];
            }
        }
        
        /**
         * Show notification history in a modal
         */
        showHistory() {
            const modal = document.getElementById('notification-history-modal');
            if (!modal) return;
            
            // Update the history list
            this.filterHistory('all');
            
            // Show the modal
            modal.style.display = 'block';
        }
        
        /**
         * Filter history by category
         */
        filterHistory(filter = 'all') {
            const historyList = document.getElementById('notification-history-list');
            if (!historyList) return;
            
            // Clear current list
            historyList.innerHTML = '';
            
            // Filter notifications
            const filtered = filter === 'all' 
                ? [...this.notifications]
                : this.notifications.filter(n => n.category === filter);
            
            if (filtered.length === 0) {
                historyList.innerHTML = '<div class="empty-state">Bu kategoride bildirim bulunmuyor.</div>';
                return;
            }
            
            // Add notifications to history list
            filtered.forEach(n => {
                const item = document.createElement('div');
                item.className = `notification ${n.category}`;
                
                const catInfo = this.categories[n.category] || this.categories.system;
                const date = new Date(n.timestamp);
                const dateStr = date.toLocaleString();
                
                item.innerHTML = `
                    <div class="notification-header">
                        <span class="notification-icon">${catInfo.icon}</span>
                        <span class="notification-priority">${'‚Ä¢'.repeat(n.priority || 1)}</span>
                    </div>
                    <div class="notification-content">
                        ${n.message}
                        <div class="notification-time">${dateStr}</div>
                    </div>
                `;
                
                historyList.appendChild(item);
            });
        }
    }

    class ChartManager {
        constructor(chartContainerId) {
            this.chartContainer = document.getElementById(chartContainerId);
            if (!this.chartContainer) throw new Error("Chart container bulunamadƒ±!");
            this.chart = null; this.series = {}; this.signalMarkers = [];
            this.bbandsSeries = null;
            this._initChart();
        }
        _initChart() {
            this.chart = LightweightCharts.createChart(this.chartContainer, this._getChartOptions());
            this.series.candles = this.chart.addCandlestickSeries(this._getCandlestickOptions());
            this.series.volume = this.chart.addHistogramSeries(this._getVolumeOptions());
            
            const lineStyle = { color: 'rgba(255, 255, 0, 0.6)', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted };
            this.series.bbUpper = this.chart.addLineSeries(lineStyle);
            this.series.bbMiddle = this.chart.addLineSeries(lineStyle);
            this.series.bbLower = this.chart.addLineSeries(lineStyle);

            window.addEventListener('resize', () => { 
                if (this.chart && this.chartContainer.clientWidth > 0 && this.chartContainer.clientHeight > 0) {
                    this.chart.resize(this.chartContainer.clientWidth, this.chartContainer.clientHeight);
                }
            });

            // --- YENƒ∞: Grafik g√∂r√ºn√ºm√ºn√º kaydetmek i√ßin olay dinleyici ---
            this.chart.timeScale().subscribeVisibleLogicalRangeChange(logicalRange => {
                if (logicalRange) {
                    localStorage.setItem('utc_chart_view', JSON.stringify(logicalRange));
                }
            });
        }

        // --- YENƒ∞: Kaydedilmi≈ü g√∂r√ºn√ºm√º geri y√ºkleme fonksiyonu ---
        restoreView() {
            const savedView = localStorage.getItem('utc_chart_view');
            if (savedView) {
                try {
                    const logicalRange = JSON.parse(savedView);
                    this.chart.timeScale().setVisibleLogicalRange(logicalRange);
                } catch (e) {
                    console.error("Kaydedilmi≈ü grafik g√∂r√ºn√ºm√º y√ºklenemedi:", e);
                    this.chart.timeScale().fitContent();
                }
            } else {
                this.chart.timeScale().fitContent();
            }
        }

        updateTheme() {
            if(!this.chart) return;
            this.chart.applyOptions(this._getChartOptions());
            this.series.candles.applyOptions(this._getCandlestickOptions());
            this.series.volume.applyOptions(this._getVolumeOptions());
            const lineStyle = { color: 'rgba(255, 255, 0, 0.6)', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted };
            this.series.bbUpper.applyOptions(lineStyle);
            this.series.bbMiddle.applyOptions(lineStyle);
            this.series.bbLower.applyOptions(lineStyle);
        }
        setData(candles) {
            if (!this.series.candles) return;
            const candleData = candles.map(c => ({ time: c.time / 1000, open: c.open, high: c.high, low: c.low, close: c.close }));
            const volumeData = candles.map(c => ({ time: c.time / 1000, value: c.volume, color: c.close >= c.open ? 'rgba(40, 167, 69, 0.5)' : 'rgba(220, 53, 69, 0.5)' }));
            this.series.candles.setData(candleData);
            this.series.volume.setData(volumeData);
            
            // --- D√úZELTME: Veri y√ºklendikten sonra kaydedilmi≈ü g√∂r√ºn√ºm√º uygula ---
            this.restoreView();
        }

        drawBollingerBands(bbandsData) {
            if (!this.series.bbUpper || !bbandsData) return;
            const mapToChartTime = (d) => ({ time: d.time / 1000, value: d.value });
            this.series.bbUpper.setData(bbandsData.upper.map(mapToChartTime));
            this.series.bbMiddle.setData(bbandsData.middle.map(mapToChartTime));
            this.series.bbLower.setData(bbandsData.lower.map(mapToChartTime));
        }

        updateRealtime(kline) {
             if (!this.series.candles) return;
             const candle = { time: kline.t / 1000, open: parseFloat(kline.o), high: parseFloat(kline.h), low: parseFloat(kline.l), close: parseFloat(kline.c) };
             const volume = { time: kline.t / 1000, value: parseFloat(kline.v), color: candle.close >= candle.open ? 'rgba(40, 167, 69, 0.5)' : 'rgba(220, 53, 69, 0.5)' };
             this.series.candles.update(candle);
             this.series.volume.update(volume);
        }
        addSignalMarker(signal) {
            if (!this.series.candles) return;
            const styles = getComputedStyle(document.body);
            const isMobile = window.innerWidth <= 768;
            let text = '';

            if (isMobile) {
                text = `S:${typeof signal.score === 'number' ? signal.score.toFixed(1) : signal.score}`;
            } else {
                text = `Skor: ${typeof signal.score === 'number' ? signal.score.toFixed(1) : signal.score} @ ${this._formatMarkerPrice(signal.price)}`;
                if (signal.recommendedSize) {
                    text += ` | ${signal.recommendedSize}`;
                }
            }

            const marker = {
                id: signal.id,
                time: signal.timestamp / 1000,
                position: signal.direction === 'buy' ? 'belowBar' : 'aboveBar',
                color: signal.direction === 'buy' ? styles.getPropertyValue('--positive').trim() : styles.getPropertyValue('--negative').trim(),
                shape: signal.direction === 'buy' ? 'arrowUp' : 'arrowDown',
                text: text
            };
            if (signal.status === 'pending') {
                marker.color = styles.getPropertyValue('--neutral').trim();
                marker.shape = 'circle';
            }
            
            this.signalMarkers = this.signalMarkers.filter(m => m.id !== signal.id);
            this.signalMarkers.push(marker);
            this.series.candles.setMarkers(this.signalMarkers);
        }
        clearMarkers() { if (!this.series.candles) return; this.signalMarkers = []; this.series.candles.setMarkers([]); }
        zoom(factor) {
            if (!this.chart) return;
            const timeScale = this.chart.timeScale();
            const currentLogicalRange = timeScale.getVisibleLogicalRange();
            if (!currentLogicalRange) return;
            const newLogicalRange = { from: currentLogicalRange.from * factor, to: currentLogicalRange.to * factor };
            timeScale.setVisibleLogicalRange(newLogicalRange);
        }
        zoomIn() { this.zoom(0.9); }
        zoomOut() { this.zoom(1.1); }
        resetZoom() { 
            if (this.chart) {
                this.chart.timeScale().fitContent(); 
                // --- YENƒ∞: Sƒ±fƒ±rlama sonrasƒ± hafƒ±zayƒ± da temizle ---
                localStorage.removeItem('utc_chart_view');
            }
        }

        _getDecimalPlacesBasedOnPrice(price) { if(!price) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
        _formatMarkerPrice(price) { const d = this._getDecimalPlacesBasedOnPrice(price); return price.toFixed(d); }
        _getChartOptions() {
            const styles = getComputedStyle(document.body);
            return {
                width: this.chartContainer.clientWidth, height: this.chartContainer.clientHeight,
                layout: { backgroundColor: 'transparent', textColor: styles.getPropertyValue('--text-main').trim(), fontFamily: "'Roboto Mono', monospace" },
                grid: { vertLines: { color: styles.getPropertyValue('--border-color').trim() }, horzLines: { color: styles.getPropertyValue('--border-color').trim() } },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                timeScale: { borderColor: styles.getPropertyValue('--border-color').trim(), timeVisible: true, secondsVisible: false, rightOffset: 10 }
            };
        }
        _getCandlestickOptions() {
             const styles = getComputedStyle(document.body);
             return { 
                upColor: styles.getPropertyValue('--positive').trim(), downColor: styles.getPropertyValue('--negative').trim(),
                borderVisible: false, wickUpColor: styles.getPropertyValue('--positive').trim(), wickDownColor: styles.getPropertyValue('--negative').trim(),
                priceFormat: { type: 'price', precision: 6, minMove: 0.000001 }
             };
        }
        _getVolumeOptions() { return { priceFormat: { type: 'volume' }, priceScaleId: '', scaleMargins: { top: 0.8, bottom: 0 } }; }
    }


    class HeatmapManager {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            if (!this.canvas) throw new Error("Heatmap canvas bulunamadƒ±!");
            this.ctx = this.canvas.getContext('2d');
            this._resizeCanvas();
            window.addEventListener('resize', () => this._resizeCanvas());
        }
        draw(orderBook, symbolPrice) {
            if (!orderBook.bids || !Array.isArray(orderBook.bids) || orderBook.bids.length === 0 || !orderBook.asks || !Array.isArray(orderBook.asks) || orderBook.asks.length === 0) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                return;
            }
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            const asks = orderBook.asks.slice().reverse(); const bids = orderBook.bids;
            const allLevels = [...bids, ...asks]; const maxQty = Math.max(...allLevels.map(l => l[1]));
            this._drawSection(asks, 'asks', maxQty, symbolPrice); this._drawSection(bids, 'bids', maxQty, symbolPrice);
        }
        updateTheme() { this._resizeCanvas(); }
        _drawSection(levels, type, maxQty, symbolPrice) {
            const styles = getComputedStyle(document.body);
            const baseColor = type === 'asks' ? styles.getPropertyValue('--negative').trim() : styles.getPropertyValue('--positive').trim();
            if (levels.length === 0) return;
            const heightPerLevel = (this.canvas.height / 2) / levels.length;
            const priceDecimals = this._getDecimalPlaces(symbolPrice);
            const labelSkipInterval = heightPerLevel < 12 ? Math.ceil(12 / heightPerLevel) : 1;
            levels.forEach((level, index) => {
                const [price, qty] = level;
                const intensity = Math.min(Math.sqrt(qty / maxQty), 1.0);
                this.ctx.fillStyle = this._hexToRgba(baseColor, intensity * 0.6 + 0.1);
                const y = type === 'asks' ? index * heightPerLevel : (this.canvas.height / 2) + (index * heightPerLevel);
                const barWidth = this.canvas.width * intensity;
                this.ctx.fillRect(0, y, barWidth, heightPerLevel);
                if (index % labelSkipInterval === 0) {
                    this.ctx.fillStyle = intensity > 0.5 ? '#FFFFFF' : styles.getPropertyValue('--text-secondary').trim();
                    this.ctx.font = '10px "Roboto Mono"'; this.ctx.textAlign = 'left';
                    this.ctx.fillText(`${(qty).toFixed(2)} @ ${price.toFixed(priceDecimals)}`, 10, y + heightPerLevel - 3);
                }
            });
        }
        _getDecimalPlaces(price) { if (!price) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
        _hexToRgba(hex, alpha) {
            if(!hex.startsWith('#')) return `rgba(120,120,120,${alpha})`;
            let r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        _resizeCanvas() { 
            if(this.canvas.parentElement) {
                this.canvas.width = this.canvas.parentElement.clientWidth; 
                this.canvas.height = this.canvas.parentElement.clientHeight; 
            }
        }
    }

    /* =========================
       GELƒ∞≈ûMƒ∞≈û √ñZELLƒ∞K Y√ñNETƒ∞Cƒ∞LERƒ∞
       ========================= */

    // √áoklu Zaman Dilimi Y√∂neticisi (Multi-Timeframe Manager) - Geli≈ümi≈ü
    class LegacyMultiTimeframeManager {
        constructor(bot) {
            this.bot = bot;
            this.data = {}; // { '1h': { candles: [], ema20: null }, '15m': { ... } }
            this.intervals = {};
            this.isInitialized = false;
        }

        async initialize(symbol, timeframes = []) {
            if (this.isInitialized) this.cleanup();
            this.isInitialized = true;
            this.bot.logToJournal(`MTF Manager ba≈ülatƒ±lƒ±yor: ${timeframes.join(', ')}`);
            for (const tf of timeframes) {
                this.data[tf] = { candles: [], ema20: null };
                await this.fetchHistoricalData(symbol, tf);
                this.intervals[tf] = setInterval(() => this.fetchRealtimeData(symbol, tf), this._timeframeToMs(tf));
            }
        }

        async fetchHistoricalData(symbol, timeframe) {
            try {
                const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${timeframe}&limit=100`;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`API Hatasƒ±: ${response.statusText}`);
                const data = await response.json();
                this.data[timeframe].candles = data.map(d => ({ time: d[0], close: parseFloat(d[4]) }));
                this.calculateIndicators(timeframe);
                this.bot.logToJournal(`${timeframe} i√ßin ${this.data[timeframe].candles.length} mum y√ºklendi.`);
            } catch (error) {
                console.error(`MTF ge√ßmi≈ü veri hatasƒ± (${timeframe}):`, error);
            }
        }

        async fetchRealtimeData(symbol, timeframe) {
            try {
                const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${timeframe}&limit=2`;
                const response = await fetch(url);
                if (!response.ok) return;
                const data = await response.json();
                const newCandle = { time: data[0][0], close: parseFloat(data[0][4]) };
                const lastCandle = this.data[timeframe].candles[this.data[timeframe].candles.length - 1];
                if (lastCandle && lastCandle.time === newCandle.time) {
                    this.data[timeframe].candles[this.data[timeframe].candles.length - 1] = newCandle;
                } else {
                    this.data[timeframe].candles.push(newCandle);
                    if(this.data[timeframe].candles.length > 101) this.data[timeframe].candles.shift();
                }
                this.calculateIndicators(timeframe);
            } catch (error) {
                 console.error(`MTF anlƒ±k veri hatasƒ± (${timeframe}):`, error);
            }
        }
        
        calculateIndicators(timeframe) {
            const candles = this.data[timeframe]?.candles;
            if (!candles || candles.length < 20) return;
            const closes = candles.map(c => c.close);
            this.data[timeframe].ema20 = this._calculateEMA(closes, 20);
        }

        _calculateEMA(prices, period) {
            const k = 2 / (period + 1);
            let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
            for (let i = period; i < prices.length; i++) {
                ema = (prices[i] * k) + (ema * (1 - k));
            }
            return ema;
        }

        getTrend(timeframe) {
            const tfData = this.data[timeframe];
            if (!tfData || !tfData.ema20) return 'neutral';
            
            const price = this.bot.marketData.price;
            const ema = tfData.ema20;
            if (!price || !ema) return 'neutral';

            const diff = Math.abs(price - ema) / ema;
            
            // Belirsizlik durumu i√ßin e≈üik deƒüer (%0.1)
            if (diff < 0.001) return 'neutral';
            
            return price > ema ? 'up' : 'down';
        }
        
        _timeframeToMs(tf) {
            const unit = tf.slice(-1);
            const val = parseInt(tf.slice(0, -1));
            if (unit === 'm') return val * 60 * 1000;
            if (unit === 'h') return val * 60 * 60 * 1000;
            return 60000;
        }

        cleanup() {
            this.isInitialized = false;
            Object.values(this.intervals).forEach(clearInterval);
            this.data = {};
            this.intervals = {};
            this.bot.logToJournal("MTF Manager durduruldu ve temizlendi.");
        }
    }

    // Sahte Emir Tespiti (Spoof Detector)
        class SpoofDetector {
        constructor(bot) {
            this.bot = bot;
            // --- YENƒ∞ OPTƒ∞Mƒ∞ZASYON DEƒûƒ∞≈ûKENLERƒ∞ ---
            this.largeOrderThreshold = 10; // BTC cinsinden BA≈ûLANGI√á e≈üiƒüi
            this.pendingChecks = []; // Onay bekleyen tespitler
            this.confirmationStats = { confirmed: 0, rejected: 0 }; // ƒ∞statistikler
            // --- Bƒ∞TTƒ∞ ---
            this.trackedOrders = new Map();
            this.NOTIFICATION_COOLDOWN_MS = 30000;
            this.lastNotificationTime = 0;
            this.PRICE_PROXIMITY_PERCENT = 0.0005;
        }

        trackOrderBook(orderBook) {
            const now = Date.now();
            const currentBids = new Map(orderBook.bids.map(([p, q]) => [p, q]));
            const currentAsks = new Map(orderBook.asks.map(([p, q]) => [p, q]));
            this._detectSpoofing(now, currentBids, currentAsks);
            this._trackNewLargeOrders(now, orderBook);
        }

        _detectSpoofing(now, currentBids, currentAsks) {
            const ordersToDelete = [];
            for (const [price, order] of this.trackedOrders.entries()) {
                if (now - order.timestamp > 15000) {
                    ordersToDelete.push(price);
                    continue;
                }
                const book = order.type === 'bid' ? currentBids : currentAsks;
                const priceTolerance = price * this.PRICE_PROXIMITY_PERCENT;
                let stillExists = false;
                for (const [currentPrice, currentQty] of book.entries()) {
                    if (Math.abs(currentPrice - price) <= priceTolerance) {
                        if (currentQty >= order.qty * 0.8) {
                            stillExists = true;
                            break;
                        }
                    }
                }
                if (!stillExists) {
                    if (now - this.lastNotificationTime > this.NOTIFICATION_COOLDOWN_MS) {
                        let notificationText = '';
                        let ttsKey = '';
                        let expectedDirection = '';

                        if (order.type === 'bid') {
                            notificationText = `Sahte Alƒ±≈ü Emri √áekildi! D√º≈ü√º≈ü gelebilir. Dikkat et hacƒ± abi.`;
                            ttsKey = 'spoofBidRemoved';
                            expectedDirection = 'down';
                        } else {
                            notificationText = `Sahte Satƒ±≈ü Emri √áekildi! Alƒ±m gelebilir. Dikkat et komutanƒ±m.`;
                            ttsKey = 'spoofAskRemoved';
                            expectedDirection = 'up';
                        }

                        this.bot.showNotification(notificationText, 'warning');
                        this.bot.speak(this.bot.getRandomMessage(ttsKey));
                        
                        // --- YENƒ∞: TESPƒ∞Tƒ∞ ONAY ƒ∞√áƒ∞N KAYDET ---
                        this.pendingChecks.push({
                            timestamp: now,
                            priceAtDetection: this.bot.marketData.price,
                            expectedDirection: expectedDirection,
                            checkAfterCandles: 5 // 5 mum sonra kontrol et
                        });
                        // --- Bƒ∞TTƒ∞ ---

                        this.lastNotificationTime = now;
                    }
                    ordersToDelete.push(price);
                }
            }
            ordersToDelete.forEach(price => this.trackedOrders.delete(price));
        }

        _trackNewLargeOrders(now, orderBook) {
            const processBook = (book, type) => {
                for (const [price, qty] of book) {
                    const btcValue = (this.bot.currentSymbol === 'BTCUSDT') ?
                        qty :
                        (qty * price) / (this.bot.marketData.btcPrice || 70000);
                    if (btcValue > this.largeOrderThreshold) { // Deƒüi≈üken e≈üiƒüi kullan
                        if (!this.trackedOrders.has(price)) {
                            this.trackedOrders.set(price, { qty, timestamp: now, type });
                        }
                    }
                }
            };
            processBook(orderBook.bids, 'bid');
            processBook(orderBook.asks, 'ask');
        }

        // --- YENƒ∞ OPTƒ∞Mƒ∞ZASYON FONKSƒ∞YONLARI ---
        checkConfirmations() {
            const candleCount = this.bot.candles.length;
            if (candleCount < 10) return;

            this.pendingChecks = this.pendingChecks.filter(check => {
                const candlesSince = candleCount - this.bot.candles.findIndex(c => c.time >= check.timestamp);
                if (candlesSince < check.checkAfterCandles) {
                    return true; // Hen√ºz kontrol zamanƒ± gelmedi, listede kalsƒ±n
                }

                const priceNow = this.bot.candles[candleCount - 1].close;
                const priceChange = (priceNow - check.priceAtDetection) / check.priceAtDetection;
                
                let confirmed = false;
                if (check.expectedDirection === 'up' && priceChange > 0.001) { // %0.1'den fazla y√ºkseldiyse
                    confirmed = true;
                } else if (check.expectedDirection === 'down' && priceChange < -0.001) { // %0.1'den fazla d√º≈üt√ºyse
                    confirmed = true;
                }

                if (confirmed) {
                    this.confirmationStats.confirmed++;
                } else {
                    this.confirmationStats.rejected++;
                }
                return false; // Kontrol edildi, listeden kaldƒ±r
            });
        }

        autoOptimizeThreshold() {
            const totalChecks = this.confirmationStats.confirmed + this.confirmationStats.rejected;
            if (totalChecks < 10) return; // Yeterli veri birikene kadar bekle

            const rejectionRate = this.confirmationStats.rejected / totalChecks;

            if (rejectionRate > 0.6) { // Reddedilme oranƒ± %60'tan fazlaysa (√ßok hassas)
                this.largeOrderThreshold *= 1.10; // E≈üiƒüi %10 artƒ±r (daha az hassas yap)
                this.bot.logToJournal(`Spoof Detector optimizasyonu: E≈üik ${this.largeOrderThreshold.toFixed(2)} BTC'ye y√ºkseltildi.`);
            } else if (rejectionRate < 0.3) { // Reddedilme oranƒ± %30'dan azsa (√ßok kaba olabilir)
                this.largeOrderThreshold *= 0.95; // E≈üiƒüi %5 d√º≈ü√ºr (daha hassas yap)
                this.bot.logToJournal(`Spoof Detector optimizasyonu: E≈üik ${this.largeOrderThreshold.toFixed(2)} BTC'ye d√º≈ü√ºr√ºld√º.`);
            }

            // E≈üiƒüin mantƒ±klƒ± sƒ±nƒ±rlar i√ßinde kalmasƒ±nƒ± saƒüla
            this.largeOrderThreshold = Math.max(5, Math.min(50, this.largeOrderThreshold));

            // ƒ∞statistikleri sƒ±fƒ±rla ki yeni e≈üikle tekrar √∂l√ß√ºm yapƒ±lsƒ±n
            this.confirmationStats = { confirmed: 0, rejected: 0 };
        }
        // --- Bƒ∞TTƒ∞ ---
    }



    // CUSUM Sapma Tespiti (CUSUM Drift Detector)
    class CUSUMDriftDetector {
        constructor() {
            this.K = 0.5;
            this.H = 3;
            this.Cp = 0;
            this.Cn = 0;
            this.dataPoints = 0; 
        }
        update(isWin) {
            this.dataPoints++;
            const Xn = isWin ? 1 : 0;
            this.Cp = Math.max(0, this.Cp + (Xn - this.K));
            this.Cn = Math.max(0, this.Cn + ((1 - Xn) - this.K));
            let driftDetected = false;
            if (this.Cp > this.H) { driftDetected = false; this.reset(); }
            if (this.Cn > this.H) { driftDetected = true; this.reset(); }
            return driftDetected;
        }
        reset() { this.Cp = 0; this.Cn = 0; this.dataPoints = 0; }
    }

    // Piyasa Seans Profilleri (Session Profiler)
    class SessionProfiler {
        constructor(bot) { // bot instance'ƒ±nƒ± almasƒ± i√ßin constructor'a eklendi
            this.bot = bot;
            this.sessions = {
                'asia': { start: 0, end: 8, name: 'Asya' },
                'europe': { start: 8, end: 13, name: 'Avrupa' },
                'america': { start: 13, end: 22, name: 'Amerika' },
                'overlap': { start: 13, end: 16, name: 'Avr-Ame √áakƒ±≈ümasƒ±' },
                'transition': { start: 22, end: 24, name: 'Ge√ßi≈ü' }
            };
        }
        getCurrentSession() {
            const now = new Date();
            const utcHour = now.getUTCHours();
            if (utcHour >= this.sessions.overlap.start && utcHour < this.sessions.overlap.end) return this.sessions.overlap.name;
            else if (utcHour >= this.sessions.america.start && utcHour < this.sessions.america.end) return this.sessions.america.name;
            else if (utcHour >= this.sessions.europe.start && utcHour < this.sessions.europe.end) return this.sessions.europe.name;
            else if (utcHour >= this.sessions.asia.start && utcHour < this.sessions.asia.end) return this.sessions.asia.name;
            else return this.sessions.transition.name;
        }
    }

    // Risk Koruyucu (Risk Guardian - Kill Switch)
    class RiskGuardian {
        constructor(bot) {
            this.bot = bot;
            this.killSwitchActivated = false;
        }
        checkKillSwitch() {
            // D√úZELTME: Kill switch aktifse, yeni teklifleri anƒ±nda temizle
            if (this.killSwitchActivated) {
                if (this.bot.confluenceEngine.proposals.length > 0) {
                    this.bot.confluenceEngine.proposals = [];
                }
                return true; // Aktifse ba≈üka kontrol yapma
            }

            if (!this.bot.settings.features.enableRiskGuardian) {
                this.killSwitchActivated = false; return false;
            }
            const totalSignals = this.bot.stats.total;
            const tpSignals = this.bot.stats.tp;
            const winRate = totalSignals > 0 ? (tpSignals / totalSignals) * 100 : 100; // Ba≈ülangƒ±√ßta 100 kabul et
            
            // G√ºvenlik kontrol√º - riskGuardian ayarlarƒ± yoksa veya killSwitchWinRate tanƒ±mlƒ± deƒüilse varsayƒ±lan deƒüeri kullan
            const riskSettings = this.bot.settings.riskGuardian || {};
            const drawdownWinRateThreshold = riskSettings.killSwitchWinRate || 35.0; // Default threshold
            
            if (totalSignals >= 10 && winRate < drawdownWinRateThreshold && !this.killSwitchActivated) {
                this.killSwitchActivated = true;
                this.bot.showNotification(`!!! ACƒ∞L DURDURMA !!! Kazanma oranƒ± ${winRate.toFixed(1)}% (${drawdownWinRateThreshold}% altƒ±). Sistem durduruldu.`, 'danger');
                this.bot.speak(`Uyarƒ±! Acil durdurma Protokol√º aktif edildi. Kazanma oranƒ± e≈üiƒüin altƒ±nda. Sistemi acilen kontrol edin.`);
                this.bot.stop();
                return true;
            }
            return false;
        }
    }

    /* =========================
       STRATEJƒ∞LER (YENƒ∞ VE MEVCUT)
       ========================= */
    class Strategy {
        constructor(bot, name) { 
            this.bot = bot; this.name = name; this.displayName = this._getDisplayName(name); 
            this.lastProposalTime = {};
            this.DEFAULT_PROPOSAL_COOLDOWN_MS = 10000;
            this._isLive = false;
        }
        setIsLive(status) { this._isLive = status; }
        propose(symbol, direction, reason, score) {
            try {
                if (!this.bot.strategyStats[this.name] || !this.bot.strategyStats[this.name].overall) {
                    const baseStat = { alpha: 3, beta: 2, proposals: 0, contrib: 0, wins: 0, losses: 0, shadowWins: 0, shadowLosses: 0, shadowProposals: 0, lastUpdate: Date.now() };
                    this.bot.strategyStats[this.name] = {
                        overall: { ...baseStat },
                        trend: { ...baseStat },
                        range: { ...baseStat },
                        transition: { ...baseStat }
                    };
                }
                const stratStats = this.bot.strategyStats[this.name];

                stratStats.overall.proposals = (stratStats.overall.proposals || 0) + 1;
                stratStats.overall.lastUpdate = Date.now();
                this.bot.saveStrategyStats();

                if (!this._isLive) {
                    this.bot.recordShadowProposal(this.name, direction, reason, score);
                    return;
                }
                if (this.bot.settings.features.enableRiskGuardian && this.bot.riskGuardian.killSwitchActivated) return;

                const now = Date.now();
                const key = `${symbol}-${direction}`;
                const cooldown = (this.DEFAULT_PROPOSAL_COOLDOWN_MS ?? 10000);
                if (now - (this.lastProposalTime[key] || 0) < cooldown) return;
                this.bot.confluenceEngine.propose(this.name, direction, reason, score);
                this.lastProposalTime[key] = now;
            } catch (error) {
                console.error(`[${this.name}] Propose Error:`, error);
            }
        }

        _getDisplayName(name) { return name.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()); }
        analyzeOrderBook(orderBook) {}
        processTrade(trade) {}
        periodicAnalyze() {}
    }

    class WallBounceStrategy extends Strategy {
        constructor(bot) { super(bot, 'wallBounce'); this.DISTANCE_THRESHOLD_PERCENT = 0.05 / 100; }
        analyzeOrderBook(orderBook) {
            const currentPrice = this.bot.marketData.price; if (!currentPrice) return;
            const btcPrice = this.bot.marketData.btcPrice || 70000;
            const wallQuantityThreshold = (this.bot.settings.params.wallBtc * btcPrice) / currentPrice;
            for (const [price, qty] of orderBook.asks) { 
                if (qty > wallQuantityThreshold) { 
                    const distance = (price - currentPrice) / currentPrice; 
                    if (distance > 0 && distance < this.DISTANCE_THRESHOLD_PERCENT) { 
                        this.propose(this.bot.currentSymbol, 'sell', `Satƒ±≈ü Duvarƒ± ${price.toFixed(this.bot.getDecimalPlaces(price))}`, 3); return; 
                    } 
                } 
            }
            for (const [price, qty] of orderBook.bids) { 
                if (qty > wallQuantityThreshold) { 
                    const distance = (currentPrice - price) / currentPrice; 
                    if (distance > 0 && distance < this.DISTANCE_THRESHOLD_PERCENT) { 
                        this.propose(this.bot.currentSymbol, 'buy', `Alƒ±≈ü Duvarƒ± ${price.toFixed(this.bot.getDecimalPlaces(price))}`, 3); return; 
                    } 
                } 
            }
        }
    }
    class VelocityScalpingStrategy extends Strategy {
        constructor(bot) { super(bot, 'velocityScalping'); this.pricePoints = []; this.VELOCITY_WINDOW_MS = 2000; this.MIN_POINTS = 20; this.VELOCITY_THRESHOLD_PERCENT = 0.10 / 100; }
        processTrade(trade) {
            const now = Date.now(); 
            this.pricePoints.push({ time: now, price: trade.price }); 
            this.pricePoints = this.pricePoints.filter(p => now - p.time < this.VELOCITY_WINDOW_MS); 
            if (this.pricePoints.length < this.MIN_POINTS) return;
            const firstPoint = this.pricePoints[0]; const lastPoint = this.pricePoints[this.pricePoints.length - 1]; 
            const priceChange = (lastPoint.price - firstPoint.price) / firstPoint.price;
            if (priceChange > this.VELOCITY_THRESHOLD_PERCENT) { 
                this.propose(this.bot.currentSymbol, 'buy', `Fiyat Hƒ±zƒ±: +${(priceChange * 100).toFixed(2)}%`, 4); this.pricePoints = []; 
            } else if (priceChange < -this.VELOCITY_THRESHOLD_PERCENT) { 
                this.propose(this.bot.currentSymbol, 'sell', `Fiyat Hƒ±zƒ±: ${(priceChange * 100).toFixed(2)}%`, 4); this.pricePoints = []; 
            }
        }
    }
    class RsiDivergenceStrategy extends Strategy {
        constructor(bot) { super(bot, 'rsiDivergence'); }
        periodicAnalyze() {
            const candles = this.bot.candles; const rsiValues = this.bot.indicators.rsi; const lookback = this.bot.settings.params.rsiPeriod;
            if (!rsiValues || rsiValues.length < lookback || !candles || candles.length < lookback) return;
            const recentRsi = rsiValues.slice(-lookback);
            const lastCandle = candles[candles.length - 1]; 
            const prevCandle = candles[candles.length - lookback]; 
            const lastRsi = recentRsi[recentRsi.length - 1]; 
            const prevRsi = recentRsi[0];
            if (!lastCandle || !prevCandle || !isFinite(lastRsi) || !isFinite(prevRsi)) return;
            if (lastCandle.high > prevCandle.high && lastRsi < prevRsi) { 
                this.propose(this.bot.currentSymbol, 'sell', 'RSI Ayƒ± Uyu≈ümazlƒ±ƒüƒ±', 5); 
            }
            if (lastCandle.low < prevCandle.low && lastRsi > prevRsi) { 
                this.propose(this.bot.currentSymbol, 'buy', 'RSI Boƒüa Uyu≈ümazlƒ±ƒüƒ±', 5); 
            }
        }
    }
    class OrderFlowMomentumStrategy extends Strategy {
        constructor(bot) { super(bot, 'orderFlowMomentum'); this.trades = []; this.WINDOW_MS = 5000; }
        processTrade(trade) {
            const now = Date.now(); 
            this.trades.push(trade); 
            this.trades = this.trades.filter(t => now - t.timestamp < this.WINDOW_MS); 
            if (this.trades.length < 50) return;
            const buys = this.trades.filter(t => !t.isBuyerMaker).reduce((sum, t) => sum + t.quantity, 0); 
            const sells = this.trades.filter(t => t.isBuyerMaker).reduce((sum, t) => sum + t.quantity, 0);
            const total = buys + sells; if (total === 0) return; 
            if (buys / total > 0.7) { this.propose(this.bot.currentSymbol, 'buy', `Alƒ±cƒ± Akƒ±≈üƒ±: %${(buys / total * 100).toFixed(0)}`, 4); this.trades = []; }
            else if (sells / total > 0.7) { this.propose(this.bot.currentSymbol, 'sell', `Satƒ±cƒ± Akƒ±≈üƒ±: %${(sells / total * 100).toFixed(0)}`, 4); this.trades = []; }
        }
    }
    class LiquidityGapsStrategy extends Strategy {
        constructor(bot) { super(bot, 'liquidityGaps'); this.GAP_THRESHOLD_PERCENT = 0.1 / 100; }
        analyzeOrderBook(orderBook) {
            if (!orderBook.asks || orderBook.asks.length === 0 || !orderBook.bids || orderBook.bids.length === 0) return;
            for (let i = 0; i < orderBook.asks.length - 1; i++) { 
                const gap = orderBook.asks[i + 1][0] - orderBook.asks[i][0]; 
                if ((gap / orderBook.asks[i][0]) > this.GAP_THRESHOLD_PERCENT) { 
                    this.propose(this.bot.currentSymbol, 'buy', `Likidite Bo≈üluƒüu ${orderBook.asks[i][0].toFixed(this.bot.getDecimalPlaces(orderBook.asks[i][0]))}`, 3); return; 
                } 
            }
            for (let i = 0; i < orderBook.bids.length - 1; i++) { 
                const gap = orderBook.bids[i][0] - orderBook.bids[i + 1][0]; 
                if ((gap / orderBook.bids[i][0]) > this.GAP_THRESHOLD_PERCENT) { 
                    this.propose(this.bot.currentSymbol, 'sell', `Likidite Bo≈üluƒüu ${orderBook.bids[i][0].toFixed(this.bot.getDecimalPlaces(orderBook.bids[i][0]))}`, 3); return; 
                } 
            }
        }
    }
    class BreakoutPatternStrategy extends Strategy {
        constructor(bot) { super(bot, 'breakoutPattern'); this.LOOKBACK = 30; this.VOL_SPIKE = 1.4; this.BREAK_PCT = 0.03/100; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.LOOKBACK + 1) return;
            const recent = c.slice(-this.LOOKBACK-1);
            const highs = recent.map(x=>x.high), lows = recent.map(x=>x.low), vols = recent.map(x=>x.volume);
            const last = recent[recent.length-1]; 
            const maxH = Math.max(...highs.slice(0, -1)); const minL = Math.min(...lows.slice(0, -1));
            const volSma = vols.reduce((a,b)=>a+b,0) / (vols.length-1);
            if (last.close > maxH * (1 + this.BREAK_PCT) && last.volume > volSma * this.VOL_SPIKE) {
                this.propose(this.bot.currentSymbol, 'buy', 'Aralƒ±k √úst√º Hacimli Kƒ±rƒ±lƒ±m', 4);
            } else if (last.close < minL * (1 - this.BREAK_PCT) && last.volume > volSma * this.VOL_SPIKE) {
                this.propose(this.bot.currentSymbol, 'sell', 'Aralƒ±k Altƒ± Hacimli Kƒ±rƒ±lƒ±m', 4);
            }
        }
    }
    class SupportResistanceStrategy extends Strategy {
        constructor(bot) { super(bot, 'supportResistance'); this.LOOKBACK = 60; this.THRESH = 0.15/100; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.LOOKBACK) return;
            const slice = c.slice(-this.LOOKBACK);
            const last = slice[slice.length-1];
            const maxH = Math.max(...slice.map(x=>x.high)); const minL = Math.min(...slice.map(x=>x.low));
            const distTop = (maxH - last.close)/last.close; const distBot = (last.close - minL)/last.close;
            if (distTop >= 0 && distTop < this.THRESH && last.close < last.open) {
                this.propose(this.bot.currentSymbol, 'sell', 'Diren√ß B√∂lgesi Reddi', 3);
            }
            if (distBot >= 0 && distBot < this.THRESH && last.close > last.open) {
                this.propose(this.bot.currentSymbol, 'buy', 'Destek B√∂lgesi Tepkisi', 3);
            }
        }
    }
    class FibonacciRetracementStrategy extends Strategy {
        constructor(bot) { super(bot, 'fibonacciRetracement'); this.LOOKBACK = 120; this.TOL = 0.2/100; this.levels = [0.382, 0.5, 0.618]; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.LOOKBACK) return;
            const slice = c.slice(-this.LOOKBACK);
            let high = -Infinity, low = Infinity, hT=0, lT=0;
            slice.forEach(k => { if(k.high > high){high=k.high; hT=k.time;} if(k.low < low){low=k.low; lT=k.time;} });
            if (!isFinite(high) || !isFinite(low) || high===low) return;
            const last = slice[slice.length-1];
            if (hT > lT) {
                const retr = (high - last.close) / (high - low);
                for (const L of this.levels) {
                    if (Math.abs(retr - L) < this.TOL) { this.propose(this.bot.currentSymbol, 'buy', `Fibo ${Math.round(L*100)}% B√∂lgesi`, 3); break; }
                }
            } else {
                const retr = (last.close - low) / (high - low);
                for (const L of this.levels) {
                    if (Math.abs(retr - L) < this.TOL) { this.propose(this.bot.currentSymbol, 'sell', `Fibo ${Math.round(L*100)}% B√∂lgesi`, 3); break; }
                }
            }
        }
    }
    class VolumeProfileStrategy extends Strategy {
        constructor(bot) { super(bot, 'volumeProfile'); this.PERIOD = 20; this.SPIKE = 2.0; this.CLOSE_POS = 0.7; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.PERIOD + 1) return;
            const last = c[c.length-1];
            const vols = c.slice(-this.PERIOD-1, -1).map(x=>x.volume);
            const volSma = vols.reduce((a,b)=>a+b,0)/vols.length;
            if (last.volume > volSma * this.SPIKE && (last.close - last.low) / Math.max(1e-8,(last.high - last.low)) > this.CLOSE_POS) {
                this.propose(this.bot.currentSymbol, 'buy', 'Hacim Spike - √úst Kapanƒ±≈ü', 3);
            } else if (last.volume > volSma * this.SPIKE && (last.high - last.close) / Math.max(1e-8,(last.high - last.low)) > this.CLOSE_POS) {
                this.propose(this.bot.currentSymbol, 'sell', 'Hacim Spike - Alt Kapanƒ±≈ü', 3);
            }
        }
    }
    class SmartMoneyConceptsStrategy extends Strategy {
        constructor(bot) { super(bot, 'smartMoneyConcepts'); this.GAP_MIN_PCT = 0.05/100; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < 3) return;
            const a = c[c.length-3], b = c[c.length-2], d = c[c.length-1];
            if ((d.low - b.high > 0) && (b.low - a.high > 0) && ((d.low - a.high)/Math.max(1e-8, d.low) > this.GAP_MIN_PCT)) {
                 this.propose(this.bot.currentSymbol, 'buy', 'Bullish FVG (IMB)', 4);
            }
            if ((a.low - b.high > 0) && (b.low - d.high > 0) && ((a.low - d.high)/Math.max(1e-8, d.high) > this.GAP_MIN_PCT)) {
                this.propose(this.bot.currentSymbol, 'sell', 'Bearish FVG (IMB)', 4);
            }
        }
    }
    class DivergenceDetectionStrategy extends Strategy {
        constructor(bot) { super(bot, 'divergenceDetection'); this.LOOKBACK = 40; this.SWING_PERIOD = 3; }
        periodicAnalyze() {
            const c = this.bot.candles; const rsi = this.bot.indicators.rsi; 
            if (!rsi || c.length < this.LOOKBACK || rsi.length < this.LOOKBACK) return;
            const slice = c.slice(-this.LOOKBACK), r = rsi.slice(-this.LOOKBACK);
            const pivLows = []; const pivHighs = [];
            for (let i = this.SWING_PERIOD; i < slice.length - this.SWING_PERIOD; i++) {
                const isPivotLow = slice[i].low < Math.min(...slice.slice(i-this.SWING_PERIOD, i).map(x=>x.low)) && 
                                   slice[i].low < Math.min(...slice.slice(i+1, i+1+this.SWING_PERIOD).map(x=>x.low));
                const isPivotHigh = slice[i].high > Math.max(...slice.slice(i-this.SWING_PERIOD, i).map(x=>x.high)) && 
                                    slice[i].high > Math.max(...slice.slice(i+1, i+1+this.SWING_PERIOD).map(x=>x.high));
                if (isPivotLow) pivLows.push(i);
                if (isPivotHigh) pivHighs.push(i);
            }
            if (pivLows.length >= 2) {
                const i1 = pivLows[pivLows.length-2], i2 = pivLows[pivLows.length-1];
                if (slice[i2].low < slice[i1].low && r[i2] > r[i1]) {
                    this.propose(this.bot.currentSymbol, 'buy', 'Boƒüa Sapmasƒ± (RSI)', 5);
                }
            }
            if (pivHighs.length >= 2) {
                const i1 = pivHighs[pivHighs.length-2], i2 = pivHighs[pivHighs.length-1];
                if (slice[i2].high > slice[i1].high && r[i2] < r[i1]) {
                    this.propose(this.bot.currentSymbol, 'sell', 'Ayƒ± Sapmasƒ± (RSI)', 5);
                }
            }
        }
    }
    class MarketStructureStrategy extends Strategy {
        constructor(bot) { super(bot, 'marketStructure'); this.SWING = 3; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < 2*this.SWING+5) return;
            const pivotHighs = [], pivotLows = [];
            for (let i = this.SWING; i < c.length - this.SWING; i++) {
                if (c[i].high > Math.max(...c.slice(i-this.SWING, i).map(x=>x.high)) && c[i].high > Math.max(...c.slice(i+1, i+1+this.SWING).map(x=>x.high))) pivotHighs.push(i);
                if (c[i].low < Math.min(...c.slice(i-this.SWING, i).map(x=>x.low)) && c[i].low < Math.min(...c.slice(i+1, i+1+this.SWING).map(x=>x.low))) pivotLows.push(i);
            }
            const last = c[c.length-1];
            if (pivotHighs.length) {
                const ph = c[pivotHighs[pivotHighs.length-1]].high;
                if (last.close > ph) this.propose(this.bot.currentSymbol, 'buy', 'Yapƒ± Kƒ±rƒ±lƒ±mƒ± (BOS Up)', 4);
            }
            if (pivotLows.length) {
                const pl = c[pivotLows[pivotLows.length-1]].low;
                if (last.close < pl) this.propose(this.bot.currentSymbol, 'sell', 'Yapƒ± Kƒ±rƒ±lƒ±mƒ± (BOS Down)', 4);
            }
        }
    }
    class InstitutionalOrderFlowStrategy extends Strategy {
        constructor(bot) { super(bot, 'institutionalOrderFlow'); this.TOP_N = 5; this.IMB_THRESHOLD = 2.0; }
        analyzeOrderBook(orderBook) {
            if (!orderBook.bids || orderBook.bids.length === 0 || !orderBook.asks || orderBook.asks.length === 0) return;
            const topB = orderBook.bids.slice(0, this.TOP_N).reduce((s,[,q])=>s+q,0);
            const topA = orderBook.asks.slice(0, this.TOP_N).reduce((s,[,q])=>s+q,0);
            if (topB / Math.max(1e-8, topA) > this.IMB_THRESHOLD) {
                this.propose(this.bot.currentSymbol, 'buy', 'Orderbook ƒ∞mbalansƒ± (Bid Aƒüƒ±rlƒ±k)', 3);
            } else if (topA / Math.max(1e-8, topB) > this.IMB_THRESHOLD) {
                this.propose(this.bot.currentSymbol, 'sell', 'Orderbook ƒ∞mbalansƒ± (Ask Aƒüƒ±rlƒ±k)', 3);
            }
        }
    }
    class MicroSpreadArbitrageStrategy extends Strategy {
        constructor(bot) { super(bot, 'microSpreadArbitrage'); this.SPREAD_PCT = 0.08/100; }
        analyzeOrderBook(orderBook) {
            if (!orderBook.bids || orderBook.bids.length === 0 || !orderBook.asks || orderBook.asks.length === 0) return;
            const bestBid = orderBook.bids[0][0], bestAsk = orderBook.asks[0][0];
            const mid = (bestAsk + bestBid)/2;
            const spreadPct = (bestAsk - bestBid) / mid;
            if (spreadPct > this.SPREAD_PCT) {
                const current = this.bot.marketData.price || mid;
                if (current < mid) this.propose(this.bot.currentSymbol, 'buy', 'Geni≈ü Spread - Mean Reversion', 2);
                else this.propose(this.bot.currentSymbol, 'sell', 'Geni≈ü Spread - Mean Reversion', 2);
            }
        }
    }
    class VWAPReversionStrategy extends Strategy {
        constructor(bot) { super(bot, 'vwapReversion'); this.MULT = 1.0; }
        periodicAnalyze() {
            const price = this.bot.marketData.price, vwap = this.bot.indicators.vwap, atr = this.bot.indicators.atr;
            if (!price || !vwap || !atr) return;
            const dev = atr / price; 
            const diffPct = (price - vwap) / vwap;
            if (diffPct > this.MULT * dev) this.propose(this.bot.currentSymbol, 'sell', 'VWAP √úst√º A≈üƒ±rƒ± Sapma', 3);
            if (diffPct < -this.MULT * dev) { this.propose(this.bot.currentSymbol, 'buy', 'VWAP Altƒ± A≈üƒ±rƒ± Sapma', 3); }
        }
    }
    class SuperTrendStrategy extends Strategy {
        constructor(bot) { super(bot, 'superTrend'); this.MULT = 3.0; this.PERIOD = 14; }
        periodicAnalyze() {
            const c = this.bot.candles; const atr = this.bot.indicators.atr;
            if (!atr || c.length < 2) return;
            const last = c[c.length-1];
            const m = (last.high + last.low) / 2;
            const upper = m + this.MULT * atr, lower = m - this.MULT * atr;
            if (last.close > upper) this.propose(this.bot.currentSymbol, 'buy', 'ATR Kanal √úst√º Kƒ±rƒ±lƒ±m (SuperTrend)', 4);
            else if (last.close < lower) { this.propose(this.bot.currentSymbol, 'sell', 'ATR Kanal Altƒ± Kƒ±rƒ±lƒ±m (SuperTrend)', 4); }
        }
    }

    // YENƒ∞ STRATEJƒ∞LER
    class VolatilityBreakoutStrategy extends Strategy {
        constructor(bot) { 
            super(bot, 'volatilityBreakout'); 
            this.SQUEEZE_LOOKBACK = 20;
            this.SQUEEZE_MULT = 1.0; // ATR'ye g√∂re sƒ±kƒ±≈üma tespiti i√ßin √ßarpan
            this.BREAKOUT_VOL_MULT = 1.5; // Kƒ±rƒ±lƒ±m anƒ±ndaki hacim artƒ±≈üƒ±
        }
        periodicAnalyze() {
            const { bbands, atr, volSma20 } = this.bot.indicators;
            const c = this.bot.candles;
            if (!bbands || !atr || !volSma20 || c.length < this.SQUEEZE_LOOKBACK || !bbands.upper || bbands.upper.length === 0) return;

            const lastBandUpper = bbands.upper[bbands.upper.length-1];
            const lastBandMiddle = bbands.middle[bbands.middle.length-1];
            const lastBandLower = bbands.lower[bbands.lower.length-1];

            if (!lastBandUpper || !lastBandMiddle || !lastBandLower || lastBandMiddle.value === 0) return;

            const bandwidth = (lastBandUpper.value - lastBandLower.value) / lastBandMiddle.value;
            
            const isSqueeze = bandwidth < (atr * this.SQUEEZE_MULT / (c[c.length-1]?.close || 1));
            if(!isSqueeze) return;

            const lastCandle = c[c.length-1];
            if (!lastCandle) return;

            if (lastCandle.close > lastBandUpper.value && lastCandle.volume > volSma20 * this.BREAKOUT_VOL_MULT) {
                this.propose(this.bot.currentSymbol, 'buy', 'Volatilite Sƒ±kƒ±≈üma Kƒ±rƒ±lƒ±mƒ± (Yukarƒ±)', 5);
            } else if (lastCandle.close < lastBandLower.value && lastCandle.volume > volSma20 * this.BREAKOUT_VOL_MULT) {
                this.propose(this.bot.currentSymbol, 'sell', 'Volatilite Sƒ±kƒ±≈üma Kƒ±rƒ±lƒ±mƒ± (A≈üaƒüƒ±)', 5);
            }
        }
    }

    class CandleCharacterStrategy extends Strategy {
        constructor(bot) {
            super(bot, 'candleCharacter');
            this.MIN_BODY_TO_WICK_RATIO = 0.6; // G√∂vde / Toplam Mum Boyu oranƒ±
            this.ANALYSIS_WINDOW_PERCENT = 0.2; // Mumun son %20'sinde √ßalƒ±≈üƒ±r
        }
        periodicAnalyze() {
            if (this.bot.candles.length < 1) return;
            const candle = this.bot.candles[this.bot.candles.length-1];
            const timeframeMs = this.bot._timeframeToMs(this.bot.currentTimeframe);
            const candleAge = Date.now() - candle.time;
            
            // Sadece mumun sonlarƒ±na doƒüru √ßalƒ±≈ü
            if (candleAge < timeframeMs * (1 - this.ANALYSIS_WINDOW_PERCENT)) return;

            const { open, high, low, close } = candle;
            const bodySize = Math.abs(close - open);
            const totalSize = high - low;
            if (totalSize === 0) return; // Doji veya veri hatasƒ±

            const bodyRatio = bodySize / totalSize;
            if(bodyRatio < this.MIN_BODY_TO_WICK_RATIO) return; // G√º√ßs√ºz g√∂vde, kararsƒ±zlƒ±k

            if (close > open) { // Ye≈üil mum
                const upperWick = high - close;
                // Eƒüer √ºst fitil toplam mum boyutunun %20'sinden azsa, g√∂vde g√º√ßl√ºd√ºr
                if (upperWick / totalSize < 0.2) { 
                    this.propose(this.bot.currentSymbol, 'buy', 'G√º√ßl√º Alƒ±cƒ± Mumu', 4);
                }
            } else { // Kƒ±rmƒ±zƒ± mum
                const lowerWick = close - low;
                // Eƒüer alt fitil toplam mum boyutunu %20'sinden azsa, g√∂vde g√º√ßl√ºd√ºr
                if(lowerWick / totalSize < 0.2) { 
                    this.propose(this.bot.currentSymbol, 'sell', 'G√º√ßl√º Satƒ±cƒ± Mumu', 4);
                }
            }
        }
    }

     class FundingRateReversalStrategy extends Strategy {
        constructor(bot) {
            super(bot, 'fundingRateReversal');
            this.fundingRate = 0;
            this.openInterest = 0;
            this.lastFetchTime = 0;
            this.FETCH_INTERVAL_MS = 60 * 1000; // 1 dakikada bir veri √ßek
            this.EXTREME_FUNDING_THRESHOLD = 0.001; // %0.1 fonlama oranƒ± e≈üiƒüi
        }

        async periodicAnalyze() {
            const now = Date.now();
            if (now - this.lastFetchTime > this.FETCH_INTERVAL_MS) {
                this.lastFetchTime = now;
                try {
                    const response = await fetch(`https://fapi.binance.com/fapi/v1/premiumIndex?symbol=${this.bot.currentSymbol}`);
                    if (!response.ok) {
                        console.error(`Funding Rate/Open Interest API Hatasƒ±: ${response.statusText}`);
                        return;
                    }
                    const data = await response.json();
                    this.fundingRate = parseFloat(data.lastFundingRate);
                    this.openInterest = parseFloat(data.openInterest) || 0; 

                } catch (e) { 
                    console.error("Fonlama Oranƒ±/A√ßƒ±k Faiz verisi √ßekilemedi:", e); 
                    return;
                }
            }

            const currentPrice = this.bot.marketData.price;
            if (!currentPrice || !isFinite(this.fundingRate) || this.fundingRate === 0 || this.bot.candles.length < 2) return;

            if (this.fundingRate > this.EXTREME_FUNDING_THRESHOLD) {
                if (currentPrice < this.bot.candles[this.bot.candles.length - 2]?.close) { 
                     this.propose(this.bot.currentSymbol, 'sell', `A≈üƒ±rƒ± Pozitif Fonlama & Fiyat D√º≈ü√º≈ü√º (${(this.fundingRate*100).toFixed(3)}%)`, 4);
                }
            } else if (this.fundingRate < -this.EXTREME_FUNDING_THRESHOLD) {
                 if (currentPrice > this.bot.candles[this.bot.candles.length - 2]?.close) { 
                    this.propose(this.bot.currentSymbol, 'buy', `A≈üƒ±rƒ± Negatif Fonlama & Fiyat Y√ºkseli≈üi (${(this.fundingRate*100).toFixed(3)}%)`, 4);
                }
            }
        }
    }


    /* =========================
       UYUM MOTORU V2 (CONFLUENCE ENGINE V2)
       ========================= */
    class AdvancedConfluenceEngine {
        constructor(bot) { 
            this.bot = bot; 
            this.proposals = []; 
            this.lastSignalTime = 0; 
            this.lastSignalTimeByDirection = { buy: 0, sell: 0 };
            this.lastDirection = null;
            this.buyScore = 0;
            this.sellScore = 0;
        }
        propose(strategy, direction, reason, score) {
            const now = Date.now();
            this.proposals = this.proposals.filter(p => !(p.strategy === strategy && p.direction === direction));
            this.proposals.push({ strategy, direction, reason, score, timestamp: now });
            this.checkConfluence();
        }
        _computeDirectional(direction) {
            const now = Date.now();
            const decaySec = this.bot.settings.optimization.timeDecaySec || 3;
            const groupSums = { trending: 0, meanReversion: 0, neutral: 0 };
            const used = [];
            const groupsUsed = new Set();
            const activeProposals = this.proposals.filter(p => {
                const strategyInstance = this.bot.strategies[p.strategy];
                return strategyInstance && strategyInstance._isLive && p.direction === direction;
            });

            for (const p of activeProposals) {
                const w = this.bot.getStrategyWeight(p.strategy);
                const ageSec = (now - p.timestamp)/1000;
                const decay = Math.exp(-ageSec / decaySec);
                // D√úZELTME: NaN kontrol√º eklendi
                const eff = isNaN(p.score * w * decay) ? 0 : p.score * w * decay;
                const grp = this.bot.getStrategyGroup(p.strategy);
                groupsUsed.add(grp);
                groupSums[grp] = (groupSums[grp] || 0) + eff;
                used.push({ strategy: p.strategy, baseScore: p.score, weight: w, decay, effScore: eff });
            }
            const score = Object.values(groupSums).reduce((sum, val) => sum + val, 0); 
            return { score, contributors: used, groupSums, groupsCount: groupsUsed.size, contributorsCount: used.length };
        }
       
        checkConfluence() {
            const now = Date.now();
            const settings = this.bot.settings;
            const cd = settings.cooldowns || {};
            const proposalTimeout = cd.proposalTimeoutMs ?? 3000;
            const signalCooldown = cd.signalMs ?? 15000;
            const sameDirCooldown = cd.sameDirectionMs ?? 30000;
            const oppCooldown = cd.oppositeDirectionMs ?? 20000;
            const reverseHys = cd.reverseHysteresisPoints ?? 2;
            const dirMargin = settings.optimization.dirMargin ?? 0.5;
            const minThreshold = this.bot.getEffectiveThreshold();

            if (now - this.lastSignalTime < signalCooldown) return;
            this.proposals = this.proposals.filter(p => now - p.timestamp < proposalTimeout);

            const buy = this._computeDirectional('buy');
            const sell = this._computeDirectional('sell');

            let buyScoreAdj = buy.score;
            let sellScoreAdj = sell.score;

            if (settings.features.enableMtfConfirm) {
                const mtfTrend = this.bot.multiTimeframeManager.getTrend(settings.features.mtfTimeframe);
                if (mtfTrend === 'down') buyScoreAdj *= 0.6;
                if (mtfTrend === 'up') sellScoreAdj *= 0.6;
            }

            const buyPenalty = settings.optimization.gating.enabled ? this.bot.marketGatingPenalty('buy') : 0;
            const sellPenalty = settings.optimization.gating.enabled ? this.bot.marketGatingPenalty('sell') : 0;
            buyScoreAdj -= buyPenalty;
            sellScoreAdj -= sellPenalty;

            const q = settings.optimization.signalQuality || { minContributors: 1, minGroups: 1 };
            const buyOk = (buy.contributorsCount >= q.minContributors) && (buy.groupsCount >= q.minGroups);
            const sellOk = (sell.contributorsCount >= q.minContributors) && (sell.groupsCount >= q.minGroups);

            buyScoreAdj = buyOk ? buyScoreAdj : -Infinity;
            sellScoreAdj = sellOk ? sellScoreAdj : -Infinity;

            this.buyScore = buyScoreAdj;
            this.sellScore = sellScoreAdj;

            if (buyScoreAdj >= minThreshold && (buyScoreAdj > sellScoreAdj + dirMargin)) {
                if (now - this.lastSignalTimeByDirection.buy < sameDirCooldown) return;
                if (this.lastDirection === 'sell' && (now - this.lastSignalTime) < oppCooldown) {
                    if (buyScoreAdj < (minThreshold + reverseHys)) return;
                }
                this.generateFinalSignal('buy', buy.contributors, buyScoreAdj);
            } else if (sellScoreAdj >= minThreshold && (sellScoreAdj > buyScoreAdj + dirMargin)) {
                if (now - this.lastSignalTimeByDirection.sell < sameDirCooldown) return;
                if (this.lastDirection === 'buy' && (now - this.lastSignalTime) < oppCooldown) {
                    if (sellScoreAdj < (minThreshold + reverseHys)) return;
                }
                this.generateFinalSignal('sell', sell.contributors, sellScoreAdj);
            }
        }

        generateFinalSignal(direction, contributors, finalScore) {
            const contributingStrats = contributors.map(c => this.bot.strategies[c.strategy]?.displayName || c.strategy).join(', ');
            const status = this.bot.settings.features.enableCandleConfirm ? 'pending' : 'active';
            
            const signal = { 
                id: `sig_${Date.now()}`, timestamp: Date.now(), symbol: this.bot.currentSymbol, 
                direction, price: this.bot.marketData.price, score: finalScore, 
                reason: contributingStrats, contributors, status: status, note: '',
                mfeR: 0, beDone: false, trailingStage: 0, entrySlDistance: 0, entryTpDistance: 0,
                recommendedSize: this.bot.getRecommendedPositionSize(finalScore)
            };

            this.bot.calculateDynamicTpSl(signal);

            if (status === 'pending') {
                this.bot.addPendingSignal(signal);
            } else {
                this.bot.activateSignal(signal);
            }
            
            this.proposals = [];
            const now = Date.now();
            this.lastSignalTime = now;
            this.lastSignalTimeByDirection[direction] = now;
            this.lastDirection = direction;
        }
    }

    /* =========================
       ANA UYGULAMA
       ========================= */
    class UltimateTradingCommandCenter {
        constructor() {
            this.allStrategiesMap = {
                'wallBounce': WallBounceStrategy, 'velocityScalping': VelocityScalpingStrategy, 'rsiDivergence': RsiDivergenceStrategy, 
                'orderFlowMomentum': OrderFlowMomentumStrategy, 'liquidityGaps': LiquidityGapsStrategy, 'fibonacciRetracement': FibonacciRetracementStrategy, 
                'volumeProfile': VolumeProfileStrategy, 'smartMoneyConcepts': SmartMoneyConceptsStrategy, 'divergenceDetection': DivergenceDetectionStrategy, 
                'breakoutPattern': BreakoutPatternStrategy, 'supportResistance': SupportResistanceStrategy, 'marketStructure': MarketStructureStrategy, 
                'institutionalOrderFlow': InstitutionalOrderFlowStrategy, 'microSpreadArbitrage': MicroSpreadArbitrageStrategy,
                'vwapReversion': VWAPReversionStrategy, 'superTrend': SuperTrendStrategy,
                'volatilityBreakout': VolatilityBreakoutStrategy,
                'candleCharacter': CandleCharacterStrategy,
                'fundingRateReversal': FundingRateReversalStrategy
            };
            this.allStrategyKeys = Object.keys(this.allStrategiesMap); 

            this.isRunning = false; 
            this.sockets = {}; 
            
            this.currentSymbol = this.loadData('utc_current_symbol') || 'BTCUSDT'; 
            this.currentTimeframe = this.loadData('utc_current_timeframe') || '15m';
            this.headerCollapsed = this.loadData('utc_header_collapsed') !== null ? (this.loadData('utc_header_collapsed') === 'true') : true; 
            this.currentMainView = this.loadData('utc_current_view') || 'chart';

            this.marketData = { price: 0, change24h: 0, volume24h: 0, symbol: this.currentSymbol, btcPrice: 70000 }; 
            this.orderBook = { bids: [], asks: [], lastUpdateId: null }; 

            this.aggTrades = []; 
            this.candles = [];
            this.indicators = { rsi: [], atr: null, sma20: null, sma50: null, volSma20: null, vwap: null, adx: null, bbands: null }; 
            this.signals = this.loadData('utc_signals') || [];
            this.pendingSignals = [];
            this.stats = this.loadData('utc_stats') || { total: 0, tp: 0, sl: 0 };

            this.strategyStats = this.loadData('utc_strategy_stats') || this.initDefaultStrategyStats();
            this.marketRegime = 'unknown';
            this.riskState = 'neutral'; 
            this.sessionState = 'unknown';

            this.strategyGroups = {
                trending: ['breakoutPattern','orderFlowMomentum','marketStructure','volumeProfile','smartMoneyConcepts','superTrend', 'volatilityBreakout'],
                meanReversion: ['vwapReversion','wallBounce','liquidityGaps','fibonacciRetracement','supportResistance','microSpreadArbitrage','divergenceDetection','rsiDivergence','institutionalOrderFlow', 'fundingRateReversal'],
                neutral: ['candleCharacter']
            };
            
            this.settings = this.loadSettings();
            this.strategies = {}; 
            
            this.combatModeActive = false;
            this.manipulationDetector = null;
            this.reconnectAttempts = 0;
            this.reconnectDelay = 3000;

            this.shadowProposals = [];

            this.chartManager = new ChartManager('live-chart');
            this.heatmapManager = new HeatmapManager('orderbook-heatmap');
            this.confluenceEngine = new ConfluenceEngine(this);
            // MultiTimeframeManager olu≈ütur - hangisi mevcutsa onu kullan
            if (typeof MultiTimeframeManager === 'function') {
                this.multiTimeframeManager = new MultiTimeframeManager(this); 
            } else if (typeof LegacyMultiTimeframeManager === 'function') {
                this.multiTimeframeManager = new LegacyMultiTimeframeManager(this);
            }
            this.spoofDetector = new SpoofDetector(this);               
            this.cusumDetector = new CUSUMDriftDetector();               
            this.sessionProfiler = new SessionProfiler(this);
            this.riskGuardian = new RiskGuardian(this);                   
            this.notificationCenter = new AdvancedNotificationCenter(this);
            
            this.renderInterval = null; 
            this.analysisInterval = null;
            this.cooldownTuneInterval = null;
            this.thresholdTuneInterval = null;
            this.paramTuneInterval = null;
            this.sessionUpdateInterval = null;
            this.countdownInterval = null; 
            this.performanceMonitorInterval = null; // D√úZELTME: Performans izleyici i√ßin

            this.lastAutoToggleTs = 0;
            this.runtimeThresholdOffset = 0; 
            this.lastCalculatedCandle = null; // D√úZELTME: ƒ∞ndikat√∂r optimizasyonu i√ßin
            this.renderTimeout = null; // D√úZELTME: Render debounce i√ßin

            this.synth = window.speechSynthesis || null;
            this.speechQueue = []; // D√úZELTME: Konu≈üma kuyruƒüu
            this.isSpeaking = false; // D√úZELTME: Konu≈üma durumu
            this.voices = [];
            
            // Enerji Y√∂netim Sistemi
            this.energyManager = null;
            
            // Rit√ºel Sistemi
            this.ritualManager = null;
            
            // D√úZELTME: Eksik TTS metinleri eklendi
                        this.speechTexts = {
                buy: [
                    "Harika bir fƒ±rsat! [Sembol] i√ßin alƒ±m sinyali geldi. Ye≈üil ƒ±≈üƒ±k yanƒ±yor! Skor [Skor].",
                    "Piyasa nefes aldƒ±, [Sembol] y√ºkseli≈üe ge√ßiyor. Bu trene binmek ister misin? Skor [Skor].",
                    "Komutanƒ±m, hesaplamalar net: [Sembol] i√ßin g√º√ßl√º bir alƒ±m. Devler uyanƒ±yor! Skor [Skor].",
                    "C√ºzdanlarƒ±nƒ±za dikkat, [Sembol] i√ßin bir y√ºkseli≈ü trendi ba≈ülangƒ±cƒ±. Fƒ±rsat kapƒ±nƒ±zƒ± √ßaldƒ±! Skor [Skor].",
                    "G√∂z√ºn√º d√∂rt a√ß! [Sembol] i√ßin b√ºy√ºk bir potansiyel g√∂r√ºyorum. Roket kalkƒ±≈üa hazƒ±r! Skor [Skor].",
                    "Bug√ºn ≈üanslƒ± g√ºn√ºn olabilir! [Sembol] alƒ±m i√ßin √ßaƒüƒ±rƒ±yor. ƒ∞√ß sesine kulak ver! Skor [Skor].",
                    "Duy sesimi Komutanƒ±m! [Sembol] i√ßin alƒ±m sinyali. Hadi, pazarƒ±n nabzƒ±nƒ± tutalƒ±m! Skor [Skor].",
                    "Piyasa dans etmeye ba≈üladƒ±, [Sembol] y√ºkseli≈üle e≈ülik ediyor. Katƒ±lmak ister misin? Skor [Skor].",
                    "Bana g√ºven, [Sembol] i√ßin enerji pozitif. Bu i≈ülemi ka√ßƒ±rmak istemezsin. Skor [Skor].",
                    "Ulan [Sembol] i√ßin alƒ±m sinyali patladƒ±, hala ne bekliyorsun lanet olasƒ±! Kalk ve parayƒ± kap, yoksa pi≈ümanlƒ±k seni yer bitirir! Skor [Skor]."
                ],
                sell: [
                    "Piyasa biraz yorulmu≈ü gibi, [Sembol] i√ßin satƒ±≈ü sinyali geldi. Karlarƒ± garantiye alalƒ±m! Skor [Skor].",
                    "Komutanƒ±m, [Sembol] i√ßin a≈üaƒüƒ± y√∂nl√º bir hareketlilik bekliyorum. Tetikte ol! Skor [Skor].",
                    "Bazen geri √ßekilmek de kazanmaktƒ±r. [Sembol] i√ßin satƒ±≈ü vakti. Par√ßalarƒ± topluyoruz! Skor [Skor].",
                    "Bir fƒ±rtƒ±na yakla≈üƒ±yor olabilir, [Sembol] i√ßin satƒ±≈ü sinyali. Kendini g√ºvende tut! Skor [Skor].",
                    "Akƒ±llƒ±ca bir adƒ±m! [Sembol] i√ßin kazan√ßlarƒ± koruma zamanƒ±. Hƒ±zlƒ± ve isabetli olalƒ±m. Skor [Skor].",
                    "Piyasa nazik√ße fƒ±sƒ±ldƒ±yor: [Sembol] i√ßin biraz ara ver. Karƒ±nƒ± koru! Skor [Skor].",
                    "Riskleri minimize etmenin zamanƒ± geldi. [Sembol] i√ßin satƒ±≈ü √∂nerisi. Gerekirse tekrar gireriz. Skor [Skor].",
                    "Satƒ±≈ü sinyali geldi. Umarƒ±m boƒüalar √ßimlere basmamƒ±≈ütƒ±r! [Sembol] i√ßin. Skor [Skor].",
                    "Ulan [Sembol] d√º≈ü√ºyor, hala mƒ± tutuyorsun lanet olasƒ± aptal! Sat da kurtul, yoksa cebin bo≈üalƒ±r sinirlenme bana! Skor [Skor].",
                    "Siktir et o umudunu, [Sembol] satƒ±≈ü sinyali verdi! Sert ol, √ßƒ±k ve karƒ± kap, motive ol lan yoksa kaybedersin! Skor [Skor]."
                ],
                combatModeActivate: [
                    "Kumandanƒ±m, Kƒ±rmƒ±zƒ± Alarm! Sava≈ü Modu aktive edildi! Piyasanƒ±n kalbi ≈üimdi elimizde!",
                    "Sistem uyarƒ±sƒ±: Ultra sava≈ü modu devrede! Piyasa sava≈üƒ± ba≈ülƒ±yor! Her bir strateji tam kapasite!",
                    "Sava≈ü Modu Ba≈üladƒ±! ƒ∞leri Komutanƒ±m! T√ºm g√º√ßler hazƒ±r, her anƒ± avantaja √ßevireceƒüiz!",
                    "Hazƒ±rlanƒ±n! Sava≈ü Modu aktive edildi. Bu bir zihin oyunu ve biz kazanacaƒüƒ±z! Odaklanma ve hƒ±z, anahtarƒ±mƒ±z!",
                    "Ulan sava≈ü modu aktive! Piyasa seni ezmeye √ßalƒ±≈üƒ±yor ama biz daha sertiz lan, kalk ayaƒüa ve piyasayƒ± sikert! Zafer bizim olacak!"
                ],
                combatModeDeactivate: [
                    "Sava≈ü modu ba≈üarƒ±yla sonlandƒ±rƒ±ldƒ±. Piyasa ko≈üullarƒ± normale d√∂n√ºyor, normal operasyonlara geri d√∂n√ºyoruz. ƒ∞yi i≈ü √ßƒ±kardƒ±nƒ±z.",
                    "Operasyon sonu. Sava≈ü modu kapatƒ±ldƒ±. ≈ûimdi piyasanƒ±n sakin sularƒ±nda y√ºzme zamanƒ±.",
                    "Sava≈ü modu devre dƒ±≈üƒ±. Riskler azaldƒ±, piyasa sakinle≈üiyor. Sakin sularda bile fƒ±rsatlar vardƒ±r, unutmayƒ±n.",
                    "Kumandanƒ±m, sava≈ü bitti. Kazanƒ±lmƒ±≈ü bir zaferin ardƒ±ndan dinlenme vakti. Bir sonraki m√ºcadeleye kadar hazƒ±rƒ±z.",
                    "Ulan sava≈ü modu kapandƒ±, hala mƒ± sinirli duruyorsun lan? Rahatla Komutanƒ±m, zaferi kutla yoksa ben sinirlenirim sana da!"
                ],
                signalTP: [
                    "Hedef vuruldu! TP geldi, Komutanƒ±m! Bu ba≈üarƒ± sizin stratejik dehanƒ±zƒ±n kanƒ±tƒ±!",
                    "Tebrikler! Kar realizasyonu ger√ßekle≈üti. ≈ûimdi kahve i√ßme zamanƒ±, zafer sizin!",
                    "TP alarmƒ±! Kazan√ß cebinizde, piyasa artƒ±k bizim kontrol√ºm√ºzde. Harika i≈ü!",
                    "Boom! TP hedefi tutturuldu. Strateji kusursuz, Komutanƒ±m lider!",
                    "Kar alƒ±ndƒ±! Zek√¢nƒ±z ve disiplininizle piyasanƒ±n kalbini fethettiniz!",
                    "Ulan TP vuruldu, para cebinde lan! Sinirliydim piyasaya ama sen ezerdin, motive ol da kutla zaferi Komutanƒ±m!"
                ],
                signalSL: [
                    "SL tetiklendi! Sava≈ü kaybedilmi≈ü deƒüil, ders alƒ±nmƒ±≈ü! Komutanƒ±m, hazƒ±rlanƒ±n ve tekrar saldƒ±rƒ±n!",
                    "Stop Loss aktif. Kaybedilen bir sava≈ü deƒüil, bir sonraki zaferin ba≈ülangƒ±cƒ±!",
                    "SL geldi, ama moral bozulmasƒ±n. Bu sadece piyasanƒ±n egonuzu test etmesi!",
                    "Kaybƒ± kabul et, ama pes etme. SL tetiklendi, stratejiyi yeniden ≈üekillendiriyoruz!",
                    "SL alarmƒ±! Hedefi kaybettik ama deneyim kazandƒ±k, Komutanƒ±m!",
                    "Ulan SL tetiklendi, para gitti lan! Sinirlim piyasaya ama sen pes etme, motive ol da tekrar saldƒ±r Komutanƒ±m!"
                ],
                cusumDriftDetected: [
                    "CUSUM drift tespit edildi! Komutanƒ±m, piyasa dalgalanƒ±yor ama biz her zaman hazƒ±rƒ±z!",
                    "Sinyal deƒüi≈üimi geldi, dikkat! Bu bir fƒ±rsat ya da ders, sizin kararƒ±nƒ±z!",
                    "CUSUM alarmƒ±! Strateji tetikte, piyasa bizi test ediyor ama biz kazanmaya odaklƒ±yƒ±z!",
                    "Drift detected! Piyasa kƒ±vƒ±lcƒ±mlarƒ± u√ßu≈üuyor, Komutanƒ±m, kontrol sizde!",
                    "Ulan CUSUM drift patladƒ±, piyasa dalgalanƒ±yor lan! Sinirlim ulan, ama motive ol da hazƒ±r ol, fƒ±rsat mƒ± ders mi sen karar ver!"
                ],
                autoToggleDeactivate: [
                    "Optimizasyon uyarƒ±sƒ±: [Strateji Adƒ±] stratejisi beklenen performansƒ± g√∂stermedi. Ge√ßici olarak pasif edildi.",
                    "[Strateji Adƒ±] stratejisi, performans testinden ge√ßemedi. Ge√ßici olarak emekli edildi. Dikkatli olalƒ±m.",
                    "Bir strateji daha devredƒ±≈üƒ±. [Strateji Adƒ±] ≈üu an i√ßin dinlenmeye alƒ±ndƒ±. Daha iyi g√ºnler i√ßin bekliyoruz.",
                    "Ulan [Strateji Adƒ±] performansƒ± sƒ±√ßtƒ±, pasif edildi lan! Sinirlim ulan, ama motive ol da bekle, en iyisi bu!"
                ],
                autoToggleActivate: [
                    "Optimizasyon ba≈üarƒ±yla tamamlandƒ±: [Strateji Adƒ±] stratejisi tekrar aktif edildi. Yeni veriler √ßok umut verici!",
                    "M√ºjde! [Strateji Adƒ±] stratejisi tekrar g√∂reve hazƒ±r! Performansƒ± y√ºkseli≈üte. Hadi bakalƒ±m, piyasayƒ± sallayalƒ±m!",
                    "Ho≈ü geldin geri [Strateji Adƒ±]! Kendini toparlamƒ±≈üsƒ±n. Tekrar aktif edildi. ≈ûimdi bize neler g√∂stereceksin merak ediyorum.",
                    "Ulan [Strateji Adƒ±] geri d√∂nd√º, aktif edildi lan! Sinirlim yokluƒüunda ama motive ol da sallayalƒ±m piyasayƒ±, zafer yakƒ±n ulan!"
                ],
                cooldownOptimize: [
                    "Sistem, soƒüuma s√ºrelerini ba≈üarƒ±yla yeniden ayarladƒ±. Piyasanƒ±n nabzƒ±na g√∂re ≈üimdiden optimize edildik Komutanƒ±m.",
                    "Cooldown ayarlarƒ± g√ºncellendi. Artƒ±k sinyaller arasƒ±nda daha zeki bir denge kuruyoruz. Ben bu i≈üi biliyorum!",
                    "Piyasa ritmini deƒüi≈ütirdi, biz de cooldown s√ºrelerimizi. Tam senkronizasyon i√ßin her ≈üey ayarlandƒ± Komutanƒ±m.",
                    "Ulan cooldown s√ºreleri ayarlandƒ± lan! Sinirlim piyasanƒ±n ritmine ama optimize ettik, motive ol da dans pistinde ezeriz hepsini Komutanƒ±m!"
                ],
                systemStart: [
                    "Sistem ba≈ülatƒ±ldƒ±. Canlƒ± veri akƒ±≈üƒ± ba≈ülƒ±yor. G√∂zlerim ve kulaklarƒ±m piyasada Komutanƒ±m.",
                    "Ba≈ülatma tamamlandƒ±. Piyasa analizine ba≈ülƒ±yorum. Bana g√ºvenebilirsin.",
                    "Uyanƒ±yorum... T√ºm sens√∂rler aktif. Piyasa maceramƒ±z ≈üimdi ba≈ülƒ±yor!",
                    "Ulan sistem ba≈üladƒ± lan! Sinirlim uykuda ama ≈üimdi canlƒ± veri akƒ±yor, motive ol da piyasayƒ± ezeriz Komutanƒ±m!"
                ],
                systemStop: [
                    "Sistem durduruldu. Operasyonlar askƒ±ya alƒ±ndƒ±. Bir mola verelim Komutanƒ±m.",
                    "Kapanƒ±≈ü prosed√ºr√º aktif. Veri akƒ±≈üƒ± durduruldu. Daha sonra g√∂r√º≈ümek √ºzere!",
                    "Enerji tasarrufu modu. Sistem kapanƒ±yor. ƒ∞htiya√ß duyduƒüunuzda beni tekrar ba≈ülatabilirsiniz.",
                    "Ulan sistem durduruldu lan! Sinirlim piyasaya ama ≈üimdi mola ver, motive ol da dinlen Komutanƒ±m yoksa ezerim seni yorgunlukla!"
                ],
                symbolChange: [
                    "Sembol [Sembol] olarak deƒüi≈ütirildi. Yeni bir maceraya hazƒ±rƒ±z.",
                    "Hedef [Sembol] olarak g√ºncellendi. Adaptasyon tamamlandƒ±. ≈ûimdi bu sembole odaklanƒ±yoruz.",
                    "Sembol deƒüi≈üimi: [Sembol]. Her zaman yeni bir meydan okumaya a√ßƒ±ƒüƒ±m.",
                    "Ulan sembol [Sembol] oldu lan! Sinirlim eskisine ama ≈üimdi motive ol da yeni maceraya atƒ±l, ezeriz piyasayƒ± Komutanƒ±m!"
                ],
                timeframeChange: [
                    "Zaman aralƒ±ƒüƒ± [Timeframe] olarak deƒüi≈ütirildi. Daha b√ºy√ºk veya k√º√ß√ºk resme odaklanƒ±yoruz.",
                    "Mum √ßubuƒüu zaman dilimi [Timeframe] olarak ayarlandƒ±. Bakƒ±≈ü a√ßƒ±mƒ±zƒ± g√ºncelledik.",
                    "[Timeframe] zaman dilimindeyiz. Piyasanƒ±n farklƒ± bir y√ºz√ºn√º ke≈üfediyoruz.",
                    "Ulan zaman aralƒ±ƒüƒ± [Timeframe] oldu lan! Sinirlim eskisine ama ≈üimdi motive ol da b√ºy√ºk resme odaklan, ezeriz piyasayƒ± Komutanƒ±m!"
                ],
                resetAll: [
                    "T√ºm ayarlar sƒ±fƒ±rlandƒ±. Sistem yeniden ba≈ülatƒ±lmaya hazƒ±r. Temiz bir sayfa a√ßtƒ±k Komutanƒ±m.",
                    "Ulan t√ºm ayarlar sƒ±fƒ±rlandƒ± lan! Sinirlim karma≈üaya ama ≈üimdi motive ol da temiz sayfaya atƒ±l, ezeriz piyasayƒ± Komutanƒ±m!"
                ],
                shadowBan: [
                    "[Strateji] g√∂lgeye alƒ±ndƒ±. Uslan da gel!",
                    "≈û≈ü≈üt [Strateji], g√∂lge moduna ge√ß. √ñnce pistte kendini ispat et."
                ],
                shadowRehab: [
                    "Bravo! [Strateji] g√∂lgede form tuttu, tekrar sahnede.",
                    "[Strateji] rehabilite edildi. Hadi bakalƒ±m, y√ºz√ºm√ºz√º kara √ßƒ±karma!"
                ],
                rogueOfDay: [
                    "Bug√ºn√ºn ≈üerefsizi: [Strateji]! Kendine gel de adam gibi sinyal ver.",
                    "[Strateji], bug√ºn g√∂z√ºm √ºzerinde. ≈ûerefsizlikte ƒ±srar etme!"
                ],
                spoofBidRemoved: [
                    "Sahte emir tespit edildi, d√º≈ü√º≈ü gelebilir. Dikkat et hacƒ± abi.",
                    "Uyarƒ±! B√ºy√ºk bir alƒ±≈ü desteƒüi kayboldu. Piyasa a≈üaƒüƒ± sarkabilir, tetikte ol.",
                    "Balina desteƒüini √ßekti! Fiyat d√º≈üebilir, dikkatli ol komutanƒ±m."
                ],
                spoofAskRemoved: [
                    "Sahte emir tespit edildi, alƒ±m gelebilir. Dikkat et komutanƒ±m.",
                    "Uyarƒ±! B√ºy√ºk bir satƒ±≈ü duvarƒ± kayboldu. Fiyat yukarƒ± hareketlenebilir, hazƒ±r ol.",
                    "Balina direnci kaldƒ±rdƒ±! Fiyat yukarƒ± doƒüru gidebilir , g√∂z√ºn√º d√∂rt a√ß hacƒ± abi."
                ]
            };


            this.init();
        }

        initDefaultStrategyStats() {
            const stats = {};
            (this.allStrategyKeys || []).forEach(k => {
                const baseStat = { alpha: 3, beta: 2, proposals: 0, contrib: 0, wins: 0, losses: 0, shadowWins: 0, shadowLosses: 0, shadowProposals: 0, lastUpdate: Date.now() };
                stats[k] = {
                    overall: { ...baseStat },
                    trend: { ...baseStat },
                    range: { ...baseStat },
                    transition: { ...baseStat }
                };
            });
            return stats;
        }
        saveStrategyStats() { this.saveData('utc_strategy_stats', this.strategyStats); }

        loadSettings() {
            const savedSettings = JSON.parse(localStorage.getItem('utc_settings') || '{}');
            const defaults = {
                confluenceThreshold: 3,
                params: { rsiPeriod: 14, atrPeriod: 14, wallBtc: 20, rrRatio: 1.5 },
                cooldowns: { signalMs: 15000, sameDirectionMs: 30000, oppositeDirectionMs: 20000, reverseHysteresisPoints: 2, proposalTimeoutMs: 3000, strategyProposalMs: 10000 },
                features: { 
                    enableSpoofDetection: true, enableCUSUMDrift: true, enableRiskGuardian: true, enableTTS: true, preferredVoiceName: null,
                    enableCandleConfirm: true,
                    enableMtfConfirm: true,
                    mtfTimeframe: '15m',
                    enableDynamicSizing: true
                },
                riskGuardian: {
                    killSwitchWinRate: 35.0,
                    autoRecover: false,
                    maxDrawdown: 5.0
                },
                optimization: {
                    enabled: true,
                    autoToggle: true,
                    timeDecaySec: 3,
                    dirMargin: 0.5,
                    minWeightToStay: 0.60,
                    minContribForToggle: 30,
                    gating: { enabled: true, spreadMaxPct: 0.001, minDepthUsd: 50000 },
                    signalQuality: { minContributors: 2, minGroups: 1 },
                    breakeven: { enabled: true, beAtR: 0.8, trailAfterR: 1.5, trailToR: 0.5 }
                },
                penalties: {
                    shadowEnabled: true,
                    minWeightToShadow: 0.60,
                    minContribForShadow: 30,
                    rehabWinRate: 0.58,
                    minShadowProposals: 20,
                    coolOffMs: 30 * 60 * 1000
                },
                statusMaps: {
                    shadowBanned: {},
                    hardBanned: {}
                },
                strategyParams: {
                    wallBounce: { DISTANCE_THRESHOLD_PERCENT: 0.0005 },
                    velocityScalping: { VELOCITY_WINDOW_MS: 2000, MIN_POINTS: 20, VELOCITY_THRESHOLD_PERCENT: 0.001 },
                    liquidityGaps: { GAP_THRESHOLD_PERCENT: 0.001 },
                    breakoutPattern: { LOOKBACK: 30, VOL_SPIKE: 1.4, BREAK_PCT: 0.0003 },
                    supportResistance: { LOOKBACK: 60, THRESH: 0.0015 },
                    fibonacciRetracement: { LOOKBACK: 120, TOL: 0.002 },
                    vwapReversion: { MULT: 1.0 },
                    superTrend: { MULT: 3.0, PERIOD: 14 },
                    marketStructure: { SWING: 3 },
                    institutionalOrderFlow: { TOP_N: 5, IMB_THRESHOLD: 2.0 },
                    microSpreadArbitrage: { SPREAD_PCT: 0.0008 },
                    volumeProfile: { PERIOD: 20, SPIKE: 2.0, CLOSE_POS: 0.7 },
                    divergenceDetection: { LOOKBACK: 40, SWING_PERIOD: 3 },
                    volatilityBreakout: { SQUEEZE_LOOKBACK: 20, SQUEEZE_MULT: 1.0, BREAKOUT_VOL_MULT: 1.5 },
                    candleCharacter: { MIN_BODY_TO_WICK_RATIO: 0.6, ANALYSIS_WINDOW_PERCENT: 0.2 },
                    fundingRateReversal: { FETCH_INTERVAL_MS: 60 * 1000, EXTREME_FUNDING_THRESHOLD: 0.001 }
                },
                activeStrategies: {} 
            };
            
            const mergeDeep = (target, source) => {
                for (const key in source) {
                    if (source[key] instanceof Object && key in target && !(source[key] instanceof Array)) {
                        Object.assign(target[key], mergeDeep(target[key], source[key]));
                    } else {
                        target[key] = source[key];
                    }
                }
                return target;
            };

            const currentSettings = mergeDeep(defaults, savedSettings);
            
            this.allStrategyKeys.forEach(key => {
                if (typeof currentSettings.activeStrategies[key] === 'undefined') {
                    currentSettings.activeStrategies[key] = true; 
                }
                if (currentSettings.statusMaps.hardBanned[key] || currentSettings.statusMaps.shadowBanned[key]) {
                    currentSettings.activeStrategies[key] = false;
                }
            });
            return currentSettings;
        }

        saveSettings() {
            localStorage.setItem('utc_settings', JSON.stringify(this.settings));
            this.applyStrategyParamOverrides();
            if (this.isRunning) {
                this.multiTimeframeManager.initialize(this.currentSymbol, [this.settings.features.mtfTimeframe]);
            }
        }
        loadData(key) { try { return JSON.parse(localStorage.getItem(key)); } catch { return null; } }
        saveData(key, data) { localStorage.setItem(key, JSON.stringify(data)); }
        
        getStrategyGroup(key) {
            if (this.strategyGroups.trending.includes(key)) return 'trending';
            if (this.strategyGroups.meanReversion.includes(key)) return 'meanReversion';
            return 'neutral';
        }
        
        getStrategyWeight(name) {
            const regime = this.marketRegime || 'overall';
            const regimeStats = this.strategyStats[name]?.[regime];
            const overallStats = this.strategyStats[name]?.overall;
            
            let s;
            if (regimeStats && (regimeStats.contrib || 0) > 10) {
                s = regimeStats;
            } else {
                s = overallStats || { alpha: 3, beta: 2 };
            }

            const mean = s.alpha / (s.alpha + s.beta);
            const totalObservations = s.alpha + s.beta;
            const uncertaintyPenalty = totalObservations < 10 ? 0.5 + (totalObservations / 20) : 1.0; 
            let w = (0.5 + mean) * uncertaintyPenalty; 
            w *= this.getGroupBoost(name);
            w = Math.max(0.3, Math.min(2.0, w)); 
            return w;
        }

        getGroupBoost(key) {
            const grp = this.getStrategyGroup(key);
            let boost = 1.0;
            if (this.marketRegime === 'trend' && grp === 'trending') boost *= 1.15;
            if (this.marketRegime === 'range' && grp === 'meanReversion') boost *= 1.15;
            const atrPct = (this.indicators.atr && this.marketData.price) ? (this.indicators.atr / this.marketData.price) : 0;
            if (atrPct < 0.005) { // D√º≈ü√ºk volatilite
                if (grp === 'trending') boost *= 0.9; 
                if (grp === 'meanReversion') boost *= 1.05;
            } else if (atrPct > 0.02) { // Y√ºksek volatilite
                if (grp === 'trending') boost *= 1.05;
                if (grp === 'meanReversion') boost *= 0.95;
            }
            return boost;
        }
        init() {
            this.initStrategies(); 
            this.setupUI(); 
            this.setupEventListeners();
            this.debouncedRender();
            this.logToJournal('Sistem hazƒ±r. "Sƒ∞STEMƒ∞ BA≈ûLAT" butonuna tƒ±klayƒ±n.');
            
            if (this.headerCollapsed) document.body.classList.add('header-collapsed'); else document.body.classList.remove('header-collapsed');
            this.switchMainView(this.currentMainView);
            this.sessionUpdateInterval = setInterval(() => this.updateSession(), 60000); 
            this.updateSession(); 

            this.countdownInterval = setInterval(() => this.updateCandleCountdown(), 1000);

            if (this.synth) {
                this.loadVoices();
                if(this.synth.onvoiceschanged !== undefined) {
                    this.synth.onvoiceschanged = () => this.loadVoices();
                }
            } else {
                console.warn('SpeechSynthesis API bu tarayƒ±cƒ±/cihazda desteklenmiyor.');
            }
            this.applyStrategyParamOverrides();
            this.startPerformanceMonitor(); // D√úZELTME: Performans izleyiciyi ba≈ülat
            
            // Event sistemi ba≈ülatma
            this.eventListeners = {};
            
            // Geli≈ümi≈ü √∂zellikleri entegre et
            this.initAdvancedFeatures();
        }
        
        initAdvancedFeatures() {
            // Eƒüer √∂zelliker zaten ba≈ülatƒ±ldƒ±ysa bunu bildir
            if (this.dbManager && this.effectsManager && this.panteonManager) {
                console.log("Geli≈ümi≈ü √∂zellikler zaten ba≈ülatƒ±lmƒ±≈ü.");
                return;
            }
            
            try {
                // Veritabanƒ± y√∂neticisini ba≈ülat
                if (!this.dbManager) {
                    this.dbManager = new DBManager();
                    this.dbManager.init().then(() => {
                        console.log("Veritabanƒ± y√∂neticisi ba≈ülatƒ±ldƒ±.");
                        // ƒ∞statistikleri ve ayarlarƒ± veritabanƒ±ndan y√ºkle
                        this.loadDataFromDB();
                    });
                }
                
                // Efekt y√∂neticisini ba≈ülat
                if (!this.effectsManager) {
                    // TSParticles k√ºt√ºphanesinin varlƒ±ƒüƒ±nƒ± kontrol et
                    if (typeof tsParticles === 'undefined') {
                        console.warn("TSParticles k√ºt√ºphanesi bulunamadƒ±. K√ºt√ºphaneyi tekrar y√ºklemeyi dene...");
                        // K√ºt√ºphaneyi dinamik olarak y√ºkle
                        const script = document.createElement('script');
                        script.src = "https://cdn.jsdelivr.net/npm/tsparticles-slim@2.12.0/tsparticles.slim.bundle.min.js";
                        script.onload = () => {
                            console.log("TSParticles k√ºt√ºphanesi ba≈üarƒ±yla y√ºklendi!");
                            this.effectsManager = new EffectsManager();
                            this.effectsManager.init().then(() => {
                                // Test i√ßin bir efekt olu≈ütur
                                this.effectsManager.createMatrixEffect();
                            });
                        };
                        script.onerror = () => {
                            console.error("TSParticles k√ºt√ºphanesi y√ºklenemedi!");
                        };
                        document.head.appendChild(script);
                    } else {
                        console.log("TSParticles k√ºt√ºphanesi zaten y√ºklenmi≈ü.");
                        this.effectsManager = new EffectsManager();
                        this.effectsManager.init().then(() => {
                            // Test i√ßin bir efekt olu≈ütur
                            this.effectsManager.createMatrixEffect();
                        });
                    }
                }
                
                // Panteon y√∂neticisini ba≈ülat
                if (!this.panteonManager) {
                    if (typeof PantheonSystem === 'function') {
                        this.panteonManager = new PantheonSystem();
                        if (this.panteonManager && typeof this.panteonManager.init === 'function') {
                            this.panteonManager.init();
                        }
                    } else {
                        console.log("PantheonSystem sƒ±nƒ±fƒ± bulunamadƒ±. Panteon √∂zellikleri devre dƒ±≈üƒ±.");
                    }
                }
                
                // TheOracle (Mah≈üerin Atlƒ±larƒ±) sistemini ba≈ülat
                if (!this.oracle) {
                    this.oracle = new TheOracle(this);
                    this.oracle.init();
                }
                
                // MultiTimeframe y√∂neticisini ba≈ülat
                if (!this.multiTimeframeManager) {
                    if (typeof LegacyMultiTimeframeManager === 'function') {
                        this.multiTimeframeManager = new LegacyMultiTimeframeManager(this);
                    } else if (typeof MultiTimeframeManager === 'function') {
                        this.multiTimeframeManager = new MultiTimeframeManager(this);
                    }
                    
                    if (this.multiTimeframeManager && typeof this.multiTimeframeManager.init === 'function') {
                        this.multiTimeframeManager.init();
                    }
                }
                
                // Confluence Engine ba≈ülat
                if (!this.confluenceEngine) {
                    this.confluenceEngine = new ConfluenceEngine(this);
                }
                
                console.log("T√ºm geli≈ümi≈ü √∂zellikler ba≈ülatƒ±ldƒ±.");
            } catch (error) {
                console.error("Geli≈ümi≈ü √∂zellikler ba≈ülatƒ±lƒ±rken hata:", error);
            }
        }
        
        async loadDataFromDB() {
            if (!this.dbManager || !this.dbManager.ready) return;
            
            try {
                // Sinyalleri y√ºkle
                const dbSignals = await this.dbManager.getAll('signals');
                if (dbSignals && dbSignals.length > 0) {
                    // ƒ∞ki sinyali birle≈ütir ve son 100 tanesini sakla
                    this.signals = [...this.signals, ...dbSignals]
                        .sort((a, b) => b.timestamp - a.timestamp)
                        .slice(0, 100);
                    
                    console.log(`${dbSignals.length} sinyal veritabanƒ±ndan y√ºklendi.`);
                }
                
                // ƒ∞statistikleri y√ºkle
                const dbStats = await this.dbManager.get('stats', 'global');
                if (dbStats) {
                    this.stats = {...this.stats, ...dbStats.data};
                    console.log("ƒ∞statistikler veritabanƒ±ndan y√ºklendi.");
                }
                
                // Ayarlarƒ± y√ºkle
                const dbSettings = await this.dbManager.get('settings', 'global');
                if (dbSettings) {
                    this.settings = {...this.settings, ...dbSettings.data};
                    console.log("Ayarlar veritabanƒ±ndan y√ºklendi.");
                    this.applyStrategyParamOverrides();
                }
            } catch (error) {
                console.error("Veritabanƒ±ndan veri y√ºklenirken hata:", error);
            }
        }
        
        // Event emitter fonksiyonu
        emit(eventName, data) {
            if (!this.eventListeners[eventName]) return;
            
            this.eventListeners[eventName].forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    console.error(`Event handler (${eventName}) hatasƒ±:`, error);
                }
            });
        }
        
        // Event listener kayƒ±t fonksiyonu
        on(eventName, callback) {
            if (!this.eventListeners[eventName]) {
                this.eventListeners[eventName] = [];
            }
            this.eventListeners[eventName].push(callback);
            
            // Geri d√∂n√º≈ü fonksiyonu (listener'ƒ± kaldƒ±rmak i√ßin)
            return () => {
                this.eventListeners[eventName] = this.eventListeners[eventName].filter(cb => cb !== callback);
            };
        }

        initStrategies() { 
            for (const key in this.allStrategiesMap) { this.strategies[key] = new this.allStrategiesMap[key](this); } 
            this.updateActiveStrategies(); 
        }
        updateActiveStrategies() { 
            for (const key in this.strategies) { 
                this.strategies[key].DEFAULT_PROPOSAL_COOLDOWN_MS = this.settings.cooldowns.strategyProposalMs; 
                const isActive = this.settings.activeStrategies[key] && 
                                 !this.settings.statusMaps.shadowBanned[key] && 
                                 !this.settings.statusMaps.hardBanned[key];
                this.strategies[key].setIsLive(isActive);
            } 
        }

        applyStrategyParamOverrides() {
            const p = this.settings.strategyParams || {};
            for (const key of Object.keys(this.strategies)) {
                if (!this.strategies[key]) continue;
                const inst = this.strategies[key];
                const ov = p[key] || {};
                for (const k of Object.keys(ov)) {
                    if (k in inst) inst[k] = ov[k];
                }
            }
        }

        setupUI() {
            document.getElementById('symbol-input').value = this.currentSymbol.replace('USDT', '');
            document.getElementById('timeframe-select').value = this.currentTimeframe;

            this.updateSettingsModalUI();
            const savedTheme = localStorage.getItem('utc_theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            this.chartManager.updateTheme(); 
            this.heatmapManager.updateTheme();
            this.updateSuperTopTicker();
            
            // Geli≈ümi≈ü √∂zellikleri desteklemek i√ßin Ayarlar modalƒ±na yeni bir b√∂l√ºm ekle
            this.setupAdvancedFeaturesUI();
        }
        
        setupAdvancedFeaturesUI() {
            // Modal i√ßinde geli≈ümi≈ü √∂zellikleri i√ßeren b√∂l√ºm√º bul veya olu≈ütur
            const settingsModal = document.getElementById('settings-modal');
            if (!settingsModal) return;
            
            let featuresContainer = document.getElementById('modal-features');
            if (!featuresContainer) {
                featuresContainer = document.createElement('div');
                featuresContainer.id = 'modal-features';
                settingsModal.querySelector('.modal-body')?.appendChild(featuresContainer);
            }
            
            // Geli≈ümi≈ü √∂zellikler b√∂l√ºm√º var mƒ± kontrol et
            let advancedFeaturesSection = document.getElementById('advanced-features-section');
            if (!advancedFeaturesSection) {
                // Yoksa olu≈ütur
                advancedFeaturesSection = document.createElement('div');
                advancedFeaturesSection.id = 'advanced-features-section';
                advancedFeaturesSection.className = 'settings-section';
                advancedFeaturesSection.innerHTML = `
                    <h3>Geli≈ümi≈ü √ñzellikler</h3>
                    <div class="settings-item">
                        <label for="enable-panteon">Panteon Sistemi</label>
                        <div class="toggle-switch">
                            <input type="checkbox" id="enable-panteon" checked>
                            <span class="toggle-slider"></span>
                        </div>
                    </div>
                    <div class="settings-item">
                        <label for="enable-oracle">Mah≈üerin Atlƒ±larƒ±</label>
                        <div class="toggle-switch">
                            <input type="checkbox" id="enable-oracle" checked>
                            <span class="toggle-slider"></span>
                        </div>
                    </div>
                    <div class="settings-item">
                        <label for="enable-effects">G√∂rsel Efektler</label>
                        <div class="toggle-switch">
                            <input type="checkbox" id="enable-effects" checked>
                            <span class="toggle-slider"></span>
                        </div>
                    </div>
                    <div class="settings-item">
                        <label for="enable-multi-timeframe">√áoklu Zaman Dilimi</label>
                        <div class="toggle-switch">
                            <input type="checkbox" id="enable-multi-timeframe" checked>
                            <span class="toggle-slider"></span>
                        </div>
                    </div>
                    <div class="settings-item">
                        <label for="enable-confluence">Confluence Motoru</label>
                        <div class="toggle-switch">
                            <input type="checkbox" id="enable-confluence" checked>
                            <span class="toggle-slider"></span>
                        </div>
                    </div>
                    <div class="settings-item">
                        <label for="min-confluence-score">Min. Confluence Skoru:</label>
                        <input type="number" id="min-confluence-score" value="3" min="1" max="10" step="0.5" class="form-control">
                    </div>
                `;
                
                featuresContainer.appendChild(advancedFeaturesSection);
                
                // Event listener'lar ekle
                document.getElementById('enable-panteon')?.addEventListener('change', (e) => {
                    if (this.panteonManager) {
                        const isEnabled = e.target.checked;
                        document.getElementById('pantheon-ui').style.display = isEnabled ? 'block' : 'none';
                        this.showNotification(`Panteon sistemi ${isEnabled ? 'etkinle≈ütirildi' : 'devre dƒ±≈üƒ± bƒ±rakƒ±ldƒ±'}`, 'info');
                    }
                });
                
                document.getElementById('enable-oracle')?.addEventListener('change', (e) => {
                    if (this.oracle) {
                        const isEnabled = e.target.checked;
                        document.getElementById('mahser-atlilari').style.display = isEnabled ? 'flex' : 'none';
                        this.showNotification(`Mah≈üerin Atlƒ±larƒ± ${isEnabled ? 'g√∂r√ºn√ºr' : 'gizli'}`, 'info');
                    }
                });
                
                document.getElementById('enable-effects')?.addEventListener('change', (e) => {
                    if (this.effectsManager) {
                        const isEnabled = e.target.checked;
                        this.effectsManager.toggleEffects(isEnabled);
                        
                        // Test efekti g√∂ster
                        if (isEnabled) {
                            setTimeout(() => {
                                this.effectsManager.createMatrixEffect();
                            }, 500);
                        }
                        
                        this.showNotification(`G√∂rsel efektler ${isEnabled ? 'etkinle≈ütirildi' : 'devre dƒ±≈üƒ± bƒ±rakƒ±ldƒ±'}`, 'info');
                    }
                });
                
                // Test butonunu geli≈ümi≈ü √∂zellikler b√∂l√ºm√ºne ekle
                const testEffectsButton = document.createElement('button');
                testEffectsButton.className = 'btn btn-sm btn-primary mt-2';
                testEffectsButton.style.marginTop = '10px';
                testEffectsButton.textContent = 'Efektleri Test Et';
                testEffectsButton.addEventListener('click', () => {
                    if (this.effectsManager) {
                        this.effectsManager.createMatrixEffect();
                        this.effectsManager.createExplosionEffect(
                            window.innerWidth / 2, 
                            window.innerHeight / 2,
                            '#00ff00',
                            30
                        );
                        this.showNotification('Efekt testi √ßalƒ±≈ütƒ±rƒ±lƒ±yor!', 'success');
                    } else {
                        this.showNotification('Efekt y√∂neticisi hen√ºz ba≈ülatƒ±lmamƒ±≈ü!', 'error');
                    }
                });
                
                const effectSettingsItem = document.getElementById('enable-effects')?.closest('.settings-item');
                if (effectSettingsItem) {
                    effectSettingsItem.appendChild(testEffectsButton);
                }
                
                document.getElementById('enable-multi-timeframe')?.addEventListener('change', (e) => {
                    if (this.multiTimeframeManager) {
                        const isEnabled = e.target.checked;
                        const tabsContainer = document.querySelector('.tabs-container');
                        if (tabsContainer) tabsContainer.style.display = isEnabled ? 'flex' : 'none';
                        this.showNotification(`√áoklu zaman dilimi ${isEnabled ? 'etkinle≈ütirildi' : 'devre dƒ±≈üƒ± bƒ±rakƒ±ldƒ±'}`, 'info');
                    }
                });
                
                document.getElementById('enable-confluence')?.addEventListener('change', (e) => {
                    if (this.confluenceEngine) {
                        const isEnabled = e.target.checked;
                        this.confluenceEngine.toggleConfluence(isEnabled);
                        this.showNotification(`Confluence motoru ${isEnabled ? 'etkinle≈ütirildi' : 'devre dƒ±≈üƒ± bƒ±rakƒ±ldƒ±'}`, 'info');
                    }
                });
                
                document.getElementById('min-confluence-score')?.addEventListener('change', (e) => {
                    if (this.confluenceEngine) {
                        const score = parseFloat(e.target.value);
                        if (isNaN(score) || score < 1) {
                            e.target.value = '1';
                            this.confluenceEngine.setMinConfluenceScore(1);
                        } else if (score > 10) {
                            e.target.value = '10';
                            this.confluenceEngine.setMinConfluenceScore(10);
                        } else {
                            this.confluenceEngine.setMinConfluenceScore(score);
                        }
                        this.showNotification(`Minimum confluence skoru ${this.confluenceEngine.minConfluenceScore} olarak ayarlandƒ±`, 'info');
                    }
                });
            }
        }
        updateSuperTopTicker() { document.getElementById('ticker-bar-symbol').textContent = this.currentSymbol.replace('USDT', '/USDT'); }

        updateSettingsModalUI() {
            const s = this.settings;
            document.getElementById('modal-confluence-threshold').value = s.confluenceThreshold;
            document.getElementById('modal-param-rsi-period').value = s.params.rsiPeriod;
            document.getElementById('modal-param-atr-period').value = s.params.atrPeriod;
            document.getElementById('modal-param-wall-btc').value = s.params.wallBtc;
            document.getElementById('modal-param-rr-ratio').value = s.params.rrRatio;
            document.getElementById('modal-signal-cooldown-ms').value = s.cooldowns.signalMs;
            document.getElementById('modal-same-direction-cooldown-ms').value = s.cooldowns.sameDirectionMs;
            document.getElementById('modal-opposite-direction-cooldown-ms').value = s.cooldowns.oppositeDirectionMs;
            document.getElementById('modal-reverse-hysteresis-points').value = s.cooldowns.reverseHysteresisPoints;
            document.getElementById('modal-proposal-timeout-ms').value = s.cooldowns.proposalTimeoutMs;
            document.getElementById('modal-strategy-proposal-cooldown-ms').value = s.cooldowns.strategyProposalMs;
            document.getElementById('modal-enable-spoof-detection').checked = s.features.enableSpoofDetection;
            document.getElementById('modal-enable-cusum-drift').checked = s.features.enableCUSUMDrift;
            document.getElementById('modal-enable-risk-guardian').checked = s.features.enableRiskGuardian;
            document.getElementById('modal-enable-auto-optimize').checked = s.optimization.enabled;
            document.getElementById('modal-enable-auto-toggle-strat').checked = s.optimization.autoToggle;
            document.getElementById('modal-enable-breakeven-trail').checked = s.optimization.breakeven.enabled;
            document.getElementById('modal-be-at-r').value = s.optimization.breakeven.beAtR;
            document.getElementById('modal-trail-after-r').value = s.optimization.breakeven.trailAfterR;
            document.getElementById('modal-trail-to-r').value = s.optimization.breakeven.trailToR;
            document.getElementById('modal-enable-tts').checked = s.features.enableTTS;
            
            const enableCandleConfirmEl = document.getElementById('modal-enable-candle-confirm');
            if(enableCandleConfirmEl) enableCandleConfirmEl.checked = s.features.enableCandleConfirm;
            
            const enableMtfConfirmEl = document.getElementById('modal-enable-mtf-confirm');
            if(enableMtfConfirmEl) enableMtfConfirmEl.checked = s.features.enableMtfConfirm;
            
            const mtfTimeframeEl = document.getElementById('modal-mtf-timeframe');
            if(mtfTimeframeEl) mtfTimeframeEl.value = s.features.mtfTimeframe;
            
            const enableDynamicSizingEl = document.getElementById('modal-enable-dynamic-sizing');
            if(enableDynamicSizingEl) enableDynamicSizingEl.checked = s.features.enableDynamicSizing;
            
            this.updateTTSVoiceSelectUI(); 

            const strategyModalContainer = document.getElementById('modal-strategy-toggles');
            strategyModalContainer.innerHTML = '';
            this.allStrategyKeys.forEach(key => { 
                const strategy = this.strategies[key];
                if (!strategy) return;
                const isChecked = s.activeStrategies[key];
                const isShadowBanned = s.statusMaps.shadowBanned[key];
                const isHardBanned = s.statusMaps.hardBanned[key];
                
                let statusText = '';
                if (isHardBanned) statusText = ' (HARDBAN)';
                else if (isShadowBanned) statusText = ' (G√ñLGE)';

                const toggleHtml = `<div class="form-group"><label class="checkbox-label"><input type="checkbox" class="strategy-toggle" data-strategy-key="${key}" ${isChecked ? 'checked' : ''} ${isHardBanned || isShadowBanned ? 'disabled' : ''}> ${strategy.displayName}${statusText}</label></div>`;
                strategyModalContainer.innerHTML += toggleHtml;
            });
            this.debouncedRender();
        }

                                                setupEventListeners() {
            document.getElementById('start-btn').addEventListener('click', () => this.start());
            document.getElementById('stop-btn').addEventListener('click', () => this.stop());
            document.getElementById('theme-toggle-btn').addEventListener('click', () => this.toggleTheme());
            document.getElementById('symbol-input').addEventListener('change', async (e) => {
                let newSymbol = e.target.value.toUpperCase().trim();
                if (!newSymbol.endsWith('USDT')) newSymbol += 'USDT';
                await this.changeSymbol(newSymbol);
                this.saveData('utc_current_symbol', newSymbol);
            });
            document.getElementById('timeframe-select').addEventListener('change', async (e) => {
                this.changeTimeframe(e.target.value);
                this.saveData('utc_current_timeframe', e.target.value);
            });
            
            document.querySelector('.header-center-title').addEventListener('dblclick', () => {
                this.toggleControlsPanel();
                this.saveData('utc_header_collapsed', this.headerCollapsed.toString());
            });
            document.getElementById('mobile-toggle-controls-btn').addEventListener('click', () => {
                this.toggleControlsPanel();
                this.saveData('utc_header_collapsed', this.headerCollapsed.toString());
            });

            document.getElementById('main-controls-btn').addEventListener('click', () => {
                this.toggleControlsPanel();
                this.saveData('utc_header_collapsed', this.headerCollapsed.toString());
            });
            document.getElementById('chart-view-btn').addEventListener('click', () => { this.switchMainView('chart'); this.saveData('utc_current_view', 'chart'); });
            document.getElementById('heatmap-view-btn').addEventListener('click', () => { this.switchMainView('heatmap'); this.saveData('utc_current_view', 'heatmap'); });
            document.getElementById('fullscreen-chart-btn').addEventListener('click', () => this.enterFullscreenChart());
            document.getElementById('exit-fullscreen-btn').addEventListener('click', () => this.exitFullscreenChart());

            document.getElementById('open-settings-modal-btn').addEventListener('click', () => this.openSettingsModal());
            document.getElementById('clear-markers-btn').addEventListener('click', () => this.clearChartMarkers()); 
            document.getElementById('chart-zoom-in').addEventListener('click', () => this.chartManager.zoomIn());
            document.getElementById('chart-zoom-out').addEventListener('click', () => this.chartManager.zoomOut());
            document.getElementById('chart-zoom-reset').addEventListener('click', () => this.chartManager.resetZoom());
            document.getElementById('close-settings-modal-btn').addEventListener('click', () => this.closeSettingsModal());
            document.getElementById('settings-modal-overlay').addEventListener('click', (e) => { if (e.target.id === 'settings-modal-overlay') this.closeSettingsModal(); });
            
            // D√úZELTME: Yeni grafik butonu i√ßin olay dinleyici eklendi
            document.getElementById('mobile-chart-view-btn').addEventListener('click', () => { this.switchMainView('chart'); this.saveData('utc_current_view', 'chart'); });
            document.getElementById('mobile-heatmap-view-btn').addEventListener('click', () => { this.switchMainView('heatmap'); this.saveData('utc_current_view', 'heatmap'); });
            document.getElementById('mobile-fullscreen-chart-btn').addEventListener('click', () => this.enterFullscreenChart());
            document.getElementById('mobile-open-settings-modal-btn').addEventListener('click', () => this.openSettingsModal());
            document.getElementById('mobile-honor-board-btn').addEventListener('click', () => this.openHonorModal());
            document.getElementById('mobile-banned-board-btn').addEventListener('click', () => this.openHonorModal('banned'));
            // YENƒ∞: Log Paneli butonlarƒ± i√ßin olay dinleyicileri
            document.getElementById('mobile-open-log-modal-btn').addEventListener('click', () => {
                document.getElementById('log-modal-overlay').classList.add('visible');
            });
            document.getElementById('close-log-modal-btn').addEventListener('click', () => {
                document.getElementById('log-modal-overlay').classList.remove('visible');
            });
            document.getElementById('export-logs-btn').addEventListener('click', () => this.exportLogs());


            const s = this.settings;
            document.getElementById('modal-confluence-threshold').addEventListener('input', (e) => s.confluenceThreshold = parseInt(e.target.value));
            document.getElementById('modal-param-rsi-period').addEventListener('change', (e) => s.params.rsiPeriod = parseInt(e.target.value));
            document.getElementById('modal-param-atr-period').addEventListener('change', (e) => s.params.atrPeriod = parseInt(e.target.value));
            document.getElementById('modal-param-wall-btc').addEventListener('change', (e) => s.params.wallBtc = parseInt(e.target.value));
            document.getElementById('modal-param-rr-ratio').addEventListener('change', (e) => s.params.rrRatio = parseFloat(e.target.value));
            document.getElementById('modal-signal-cooldown-ms').addEventListener('change', (e) => s.cooldowns.signalMs = parseInt(e.target.value) || 0);
            document.getElementById('modal-same-direction-cooldown-ms').addEventListener('change', (e) => s.cooldowns.sameDirectionMs = parseInt(e.target.value) || 0);
            document.getElementById('modal-opposite-direction-cooldown-ms').addEventListener('change', (e) => s.cooldowns.oppositeDirectionMs = parseInt(e.target.value) || 0);
            document.getElementById('modal-reverse-hysteresis-points').addEventListener('change', (e) => s.cooldowns.reverseHysteresisPoints = parseInt(e.target.value) || 0);
            document.getElementById('modal-proposal-timeout-ms').addEventListener('change', (e) => s.cooldowns.proposalTimeoutMs = parseInt(e.target.value) || 1000);
            document.getElementById('modal-strategy-proposal-cooldown-ms').addEventListener('change', (e) => s.cooldowns.strategyProposalMs = parseInt(e.target.value) || 0);
            document.getElementById('modal-enable-spoof-detection').addEventListener('change', (e) => s.features.enableSpoofDetection = e.target.checked);
            document.getElementById('modal-enable-cusum-drift').addEventListener('change', (e) => s.features.enableCUSUMDrift = e.target.checked);
            document.getElementById('modal-enable-risk-guardian').addEventListener('change', (e) => s.features.enableRiskGuardian = e.target.checked);
            document.getElementById('modal-enable-auto-optimize').addEventListener('change', (e) => s.optimization.enabled = e.target.checked);
            document.getElementById('modal-enable-auto-toggle-strat').addEventListener('change', (e) => s.optimization.autoToggle = e.target.checked);
            document.getElementById('modal-enable-breakeven-trail').addEventListener('change', (e) => s.optimization.breakeven.enabled = e.target.checked);
            document.getElementById('modal-be-at-r').addEventListener('change', (e) => s.optimization.breakeven.beAtR = parseFloat(e.target.value));
            document.getElementById('modal-trail-after-r').addEventListener('change', (e) => s.optimization.breakeven.trailAfterR = parseFloat(e.target.value));
            document.getElementById('modal-trail-to-r').addEventListener('change', (e) => s.optimization.breakeven.trailToR = parseFloat(e.target.value));
            document.getElementById('modal-enable-tts').addEventListener('change', (e) => {
                s.features.enableTTS = e.target.checked;
                this.updateTTSVoiceSelectUI();
            });
            document.getElementById('modal-tts-voice-select').addEventListener('change', (e) => {
                s.features.preferredVoiceName = e.target.value === "" ? null : e.target.value;
                this.saveSettings();
                if (e.target.value !== "") this.speak("Ses ba≈üarƒ±yla deƒüi≈ütirildi.", { lang: 'tr-TR', rate: 1.0 });
            });
            const enableCandleConfirmEl = document.getElementById('modal-enable-candle-confirm');
            if(enableCandleConfirmEl) enableCandleConfirmEl.addEventListener('change', (e) => s.features.enableCandleConfirm = e.target.checked);
            
            const enableMtfConfirmEl = document.getElementById('modal-enable-mtf-confirm');
            if(enableMtfConfirmEl) enableMtfConfirmEl.addEventListener('change', (e) => s.features.enableMtfConfirm = e.target.checked);
            
            const mtfTimeframeEl = document.getElementById('modal-mtf-timeframe');
            if(mtfTimeframeEl) mtfTimeframeEl.addEventListener('change', (e) => s.features.mtfTimeframe = e.target.value);
            
            const enableDynamicSizingEl = document.getElementById('modal-enable-dynamic-sizing');
            if(enableDynamicSizingEl) enableDynamicSizingEl.addEventListener('change', (e) => s.features.enableDynamicSizing = e.target.checked);


            document.getElementById('modal-strategy-toggles').addEventListener('change', (e) => {
                if (e.target.classList.contains('strategy-toggle')) {
                    const key = e.target.dataset.strategyKey;
                    if (s.statusMaps.hardBanned[key] || s.statusMaps.shadowBanned[key]) {
                        e.target.checked = !e.target.checked; 
                        return;
                    }
                    s.activeStrategies[key] = e.target.checked;
                    this.updateActiveStrategies();
                    this.showNotification(`${this.strategies[key].displayName} ${e.target.checked ? 'aktif' : 'pasif'}.`, 'info');
                    this.saveSettings();
                }
            });

            document.getElementById('modal-clear-signals-btn').addEventListener('click', () => this.clearAllSignals());
            document.getElementById('reset-all-settings-btn').addEventListener('click', () => this.resetAllSettings());
            document.getElementById('save-settings-btn').addEventListener('click', () => { this.saveSettings(); this.showNotification('Ayarlar kaydedildi!', 'success'); this.closeSettingsModal(); });

            document.getElementById('honor-board-btn').addEventListener('click', () => this.openHonorModal());
            document.getElementById('banned-board-btn').addEventListener('click', () => this.openHonorModal('banned'));
            document.getElementById('close-honor-modal').addEventListener('click', () => this.closeHonorModal());
            document.getElementById('honor-modal-overlay').addEventListener('click', (e)=>{ if (e.target.id === 'honor-modal-overlay') this.closeHonorModal(); });
            
            const centerPanel = document.querySelector('.center-panel');
            const resizeHandle = centerPanel.querySelector('.resize-handle');
            if (resizeHandle) {
                let isResizing = false;
                const onMouseMove = (e) => {
                    if (!isResizing) return;
                    const containerRect = centerPanel.parentElement.getBoundingClientRect();
                    let newHeight = e.clientY - containerRect.top;
                    newHeight = Math.max(200, Math.min(containerRect.height - 150, newHeight));
                    centerPanel.style.height = `${newHeight}px`;
                    window.dispatchEvent(new Event('resize')); 
                };
                const onMouseUp = () => {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                resizeHandle.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    document.body.style.cursor = 'ns-resize';
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                });
            }
        }






        toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            let newTheme;
            
            if (currentTheme === 'dark') {
                newTheme = 'light';
            } else if (currentTheme === 'light') {
                newTheme = 'war';
                this.enterCombatMode();
            } else {
                newTheme = 'dark';
                this.exitCombatMode();
            }
            
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('utc_theme', newTheme);
            this.chartManager.updateTheme();
            this.heatmapManager.updateTheme();
        }
        
        enterCombatMode() {
            this.combatModeActive = true;
            this.speak(this.getRandomMessage('combatModeActivate'));
            
            // G√∂rsel efektler
            const overlay = document.createElement('div');
            overlay.id = 'war-mode-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: radial-gradient(circle at center, rgba(255,50,50,0.2), transparent 80%);
                z-index: 9999;
                pointer-events: none;
                animation: warPulse 3s infinite;
            `;
            
            const style = document.createElement('style');
            style.id = 'war-mode-animation';
            style.innerHTML = `
                @keyframes warPulse {
                    0% { opacity: 0.3; }
                    50% { opacity: 0.7; }
                    100% { opacity: 0.3; }
                }
                
                @keyframes war-pulse {
                    0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
                    70% { box-shadow: 0 0 0 10px rgba(255, 0, 0, 0); }
                    100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
                }
            `;
            
            document.head.appendChild(style);
            document.body.appendChild(overlay);
        }
        
        exitCombatMode() {
            this.combatModeActive = false;
            this.speak(this.getRandomMessage('combatModeDeactivate'));
            
            // Efektleri temizle
            const overlay = document.getElementById('war-mode-overlay');
            const style = document.getElementById('war-mode-animation');
            
            if (overlay) overlay.remove();
            if (style) style.remove();
        }
        toggleControlsPanel() {
            document.body.classList.toggle('header-collapsed');
            this.headerCollapsed = document.body.classList.contains('header-collapsed'); 
            setTimeout(() => { window.dispatchEvent(new Event('resize')); }, 360);
        }
        switchMainView(viewName) {
            this.currentMainView = viewName;
            const chartView = document.getElementById('chart-container-view');
            const heatmapView = document.getElementById('heatmap-container-view');
            const chartCountdownOverlay = document.getElementById('chart-countdown-overlay');

            if (viewName === 'chart') {
                chartView.classList.remove('hidden-view');
                heatmapView.classList.add('hidden-view');
                chartCountdownOverlay.classList.remove('hidden-view');
            } else {
                chartView.classList.add('hidden-view');
                heatmapView.classList.remove('hidden-view');
                chartCountdownOverlay.classList.add('hidden-view');
            }
            setTimeout(() => window.dispatchEvent(new Event('resize')), 50);
        }
        enterFullscreenChart() {
            document.body.classList.add('fullscreen-chart');
            document.getElementById('exit-fullscreen-btn').classList.remove('hidden-view');
            document.getElementById('chart-countdown-overlay').classList.remove('hidden-view');
            window.dispatchEvent(new Event('resize'));
        }
        exitFullscreenChart() {
            document.body.classList.remove('fullscreen-chart');
            document.getElementById('exit-fullscreen-btn').classList.add('hidden-view');
            if (this.currentMainView !== 'chart') {
                document.getElementById('chart-countdown-overlay').classList.add('hidden-view');
            }
            window.dispatchEvent(new Event('resize'));
        }

        openSettingsModal() { this.updateSettingsModalUI(); document.getElementById('settings-modal-overlay').classList.add('visible'); }
        closeSettingsModal() { document.getElementById('settings-modal-overlay').classList.remove('visible'); this.updateActiveStrategies(); this.calculateAllIndicators(); window.dispatchEvent(new Event('resize')); }

        resetAllSettings() {
            if (confirm('T√ºm ayarlarƒ± ve sinyal ge√ßmi≈üini sƒ±fƒ±rlamak istediƒüinizden emin misiniz? Bu i≈ülem geri alƒ±namaz.')) {
                localStorage.clear();
                window.location.reload();
            }
        }

        async start() {
            if (this.isRunning) return;
            this.isRunning = true; 
            document.getElementById('start-btn').disabled = true; 
            document.getElementById('stop-btn').disabled = false;
            
            // MultiTimeframeManager'ƒ± g√ºvenli bir ≈üekilde ba≈ülat
            if (this.settings.features.enableMtfConfirm && this.multiTimeframeManager) {
                try {
                    // √ñnce multiTimeframeManager'ƒ±n hazƒ±r olduƒüundan emin ol
                    if (typeof this.multiTimeframeManager.initialize === 'function') {
                        await this.multiTimeframeManager.initialize(this.currentSymbol, [this.settings.features.mtfTimeframe]);
                    } else if (typeof this.multiTimeframeManager.init === 'function') {
                        // initialize metodu yoksa init metodunu dene
                        await this.multiTimeframeManager.init();
                    }
                } catch (error) {
                    console.warn('MultiTimeframeManager ba≈ülatƒ±lƒ±rken hata:', error);
                    // Hata olsa bile sistem √ßalƒ±≈ümaya devam etsin
                }
            }
            
            this.showNotification('Sistem Ba≈ülatƒ±ldƒ±: Canlƒ± veri akƒ±≈üƒ± ba≈ülatƒ±lƒ±yor...', 'success');
            this.speak(this.getRandomMessage('systemStart'));
            await this.fetchInitialData(); 
            this.connectWebSockets();
            
            this.renderInterval = setInterval(() => this.render(), 250);
            this.analysisInterval = setInterval(() => this.runPeriodicAnalysis(), 5000);
            
            // Piyasa manip√ºlasyonu tespiti her 30 saniyede bir √ßalƒ±≈ütƒ±r
            this.manipulationDetectInterval = setInterval(() => this.detectMarketManipulation(), 30000);
            
            // Enerji Y√∂netim Sistemini ba≈ülat
            if (!this.energyManager) {
                this.energyManager = new EnergyManager(this);
            }
            
            // Rit√ºel Sistemini ba≈ülat
            if (!this.ritualManager) {
                this.ritualManager = new RitualManager(this);
            }
            
            if (this.settings.optimization.enabled) {
                this.cooldownTuneInterval = setInterval(() => this.autoTuneCooldowns(), 30000); 
                this.thresholdTuneInterval = setInterval(() => this.autoTuneThresholds(), 30000); 
                this.paramTuneInterval = setInterval(() => this.autoTuneStrategyParams(), 5 * 60 * 1000);
                this.autoToggleStrategiesInterval = setInterval(() => this.autoToggleStrategies(), 5 * 60 * 1000);
            }
        }

        stop() {
            if (!this.isRunning) return;
            this.isRunning = false; 
            document.getElementById('start-btn').disabled = false; 
            document.getElementById('stop-btn').disabled = true; 
            this.disconnectWebSockets();
            if (this.renderInterval) clearInterval(this.renderInterval); 
            if (this.analysisInterval) clearInterval(this.analysisInterval);
            if (this.manipulationDetectInterval) clearInterval(this.manipulationDetectInterval);
            if (this.cooldownTuneInterval) clearInterval(this.cooldownTuneInterval);
            if (this.thresholdTuneInterval) clearInterval(this.thresholdTuneInterval);
            if (this.paramTuneInterval) clearInterval(this.paramTuneInterval);
            if (this.autoToggleStrategiesInterval) clearInterval(this.autoToggleStrategiesInterval);
            
            this.multiTimeframeManager.cleanup();
            this.updateConnectionStatus(false, "BAƒûLANTI KESƒ∞LDƒ∞"); 
            if (this.combatModeActive) this.deactivateCombatMode();
            this.showNotification('Sistem Durduruldu.', 'danger');
            this.speak(this.getRandomMessage('systemStop'));
        }
        
        detectMarketManipulation() {
            if (!this.manipulationDetector) {
                this.manipulationDetector = new MarketManipulationDetector(this);
            }
            
            const detection = this.manipulationDetector.detect();
            
            if (detection) {
                // Manip√ºlasyon tespiti!
                this.showNotification(`Pƒ∞YASA MANƒ∞P√úLASYONU TESPƒ∞T EDƒ∞LDƒ∞: ${detection.message}`, 'warning');
                
                // Sava≈ü modunu etkinle≈ütir
                if (!this.combatModeActive) {
                    this.activateCombatMode();
                }
                
                // TTS ile sesli uyarƒ±
                this.speak(`Dikkat! Piyasa manip√ºlasyonu tespit edildi. ${detection.message} Koruyucu √∂nlemler alƒ±nƒ±yor.`);
                
                // D√º≈ü√ºk skora sahip √∂nerileri temizle ve y√ºksek risk i√ßeren i≈ülemleri filtrele
                this.confluenceEngine.proposals = this.confluenceEngine.proposals.filter(p => p.score >= 7);
                
                // Olay g√ºnl√ºƒü√ºne kaydet
                console.warn(`[Manip√ºlasyon Tespiti ${new Date().toLocaleTimeString()}] ${detection.message}`);
                
                return detection;
            }
            
            return false;
        }

        async changeSymbol(newSymbol) {
            if (this.currentSymbol === newSymbol) return;
            this.currentSymbol = newSymbol; 
            this.showNotification(`${this.currentSymbol.replace('USDT', '/USDT')} sembol√ºne ge√ßildi.`, 'info');
            this.speak(this.getRandomMessage('symbolChange', { 'Sembol': this.currentSymbol.replace('USDT', '') }));
            this.resetDataForNewSymbol();
            if (this.isRunning) { this.stop(); await this.start(); }
            this.updateSuperTopTicker(); 
        }
        async changeTimeframe(newTimeframe) {
            this.currentTimeframe = newTimeframe; 
            this.showNotification(`Zaman aralƒ±ƒüƒ± ${this.currentTimeframe} olarak deƒüi≈ütirildi.`, 'info');
            this.speak(this.getRandomMessage('timeframeChange', { 'Timeframe': this.currentTimeframe }));
            this.resetDataForNewSymbol();
            if (this.isRunning) { this.stop(); await this.start(); }
        }
                resetDataForNewSymbol() {
            // --- YENƒ∞: Grafik hafƒ±zasƒ±nƒ± temizle ---
            localStorage.removeItem('utc_chart_view');

            this.candles = []; this.aggTrades = []; this.marketData.price = 0; 
            this.orderBook = { bids: [], asks: [], lastUpdateId: null }; 
            this.indicators = { rsi: [], atr: null, sma20: null, sma50: null, volSma20: null, vwap: null, adx: null, bbands: null };
            this.pendingSignals = [];
            this.chartManager.setData([]); this.chartManager.clearMarkers(); this.render();
            this.heatmapManager.draw({bids:[], asks:[]}, 0);
        }


        async fetchInitialData() {
            try {
                this.logToJournal(`${this.currentSymbol} i√ßin ge√ßmi≈ü mum verileri √ßekiliyor...`);
                const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${this.currentSymbol}&interval=${this.currentTimeframe}&limit=500`;
                const response = await fetch(url); if (!response.ok) throw new Error(`API Hatasƒ±: ${response.statusText}`);
                const data = await response.json();
                this.candles = data.map(d => ({ time: d[0], open: parseFloat(d[1]), high: parseFloat(d[2]), low: parseFloat(d[3]), close: parseFloat(d[4]), volume: parseFloat(d[5]), }));
                this.chartManager.setData(this.candles); this.logToJournal(`${this.candles.length} adet mum y√ºklendi.`);
                this.calculateAllIndicators();
            } catch (error) { this.showNotification(`Ge√ßmi≈ü veri alƒ±namadƒ±: ${error.message}`, 'danger'); console.error("Ge√ßmi≈ü veri hatasƒ±:", error); }
        }

        connectWebSockets() {
            this.disconnectWebSockets(); 
            this.reconnectAttempts = 0;
            const symbolLower = this.currentSymbol.toLowerCase();
            const streams = [`${symbolLower}@ticker`, `${symbolLower}@depth20@100ms`, `${symbolLower}@aggTrade`, `${symbolLower}@kline_${this.currentTimeframe}`];
            const ws = new WebSocket(`wss://fstream.binance.com/stream?streams=${streams.join('/')}`); 
            this.sockets['main'] = ws;
            
            ws.onopen = () => { this.updateConnectionStatus(true); this.reconnectAttempts = 0; this.logToJournal("WebSocket baƒülantƒ±sƒ± ba≈üarƒ±yla kuruldu."); };
            ws.onmessage = (event) => { const message = JSON.parse(event.data); this.handleMarketData(message.stream, message.data); };
            ws.onerror = (error) => console.error('WebSocket Hatasƒ±:', error);
            ws.onclose = () => { 
                if (this.isRunning) { 
                    this.reconnectAttempts++;
                    this.reconnectDelay = Math.min(30000, 3000 * Math.pow(2, this.reconnectAttempts - 1));
                    const message = `YENƒ∞DEN BAƒûLANILIYOR... (${this.reconnectDelay / 1000}s)`;
                    this.updateConnectionStatus(false, message); 
                    this.logToJournal(`Baƒülantƒ± kapandƒ±. ${this.reconnectDelay/1000} saniye sonra yeniden denenecek. (Deneme: ${this.reconnectAttempts})`);
                    setTimeout(() => this.connectWebSockets(), this.reconnectDelay); 
                } 
            };
        }
        disconnectWebSockets() { 
            if (this.sockets['main']) { 
                this.sockets['main'].onclose = null;
                this.sockets['main'].close(1000, "ƒ∞stemci tarafƒ±ndan kapatƒ±ldƒ±"); 
                delete this.sockets['main'];
            }
        }

        handleMarketData(stream, data) {
            const streamType = stream.split('@')[1];
            if (streamType === 'ticker') {
                this.marketData.price = parseFloat(data.c);
                this.marketData.change24h = parseFloat(data.P);
                this.marketData.volume24h = parseFloat(data.q);
                this.marketData.symbol = data.s;
                if (data.s === 'BTCUSDT') this.marketData.btcPrice = parseFloat(data.c);
                this.manageOpenPositions();
                this.checkAutoCloseSignals();
            } 
            else if (streamType.startsWith('depth')) {
                this.orderBook = { 
                    bids: data.b.map(([p, q]) => [parseFloat(p), parseFloat(q)]), 
                    asks: data.a.map(([p, q]) => [parseFloat(p), parseFloat(q)]), 
                    lastUpdateId: data.u 
                };
                this.heatmapManager.draw(this.orderBook, this.marketData.price);
                if(this.settings.features.enableSpoofDetection) this.spoofDetector.trackOrderBook(this.orderBook);
                for (const key in this.strategies) {
                    if (this.strategies[key] && typeof this.strategies[key].analyzeOrderBook === 'function') {
                        this.strategies[key].analyzeOrderBook(this.orderBook);
                    }
                }
            } else if (streamType.startsWith('kline')) {
                if (this.candles.length > 0) {
                    const kline = data.k;
                    const lastCandleInArray = this.candles[this.candles.length - 1];
                    const currentCandleData = { time: kline.t, open: parseFloat(kline.o), high: parseFloat(kline.h), low: parseFloat(kline.l), close: parseFloat(kline.c), volume: parseFloat(kline.v) };
                    
                    if (lastCandleInArray && lastCandleInArray.time === currentCandleData.time) {
                        this.candles[this.candles.length - 1] = currentCandleData;
                    } else {
                         this.candles.push(currentCandleData);
                    }

                    this.chartManager.updateRealtime(kline);

                    if (kline.x) { // Mum kapandƒ±
                        if (this.candles[this.candles.length -1].time !== currentCandleData.time) {
                            this.candles.push(currentCandleData);
                        }
                        if (this.candles.length > 501) this.candles.shift(); 
                        
                        this.checkPendingSignals(currentCandleData);
                        this.calculateAllIndicators(); 
                    }
                    this.manageOpenPositions();
                    this.checkAutoCloseSignals();
                }
            } else if (streamType === 'aggTrade') {
                const trade = { price: parseFloat(data.p), quantity: parseFloat(data.q), isBuyerMaker: data.m, timestamp: data.T };
                for (const key in this.strategies) {
                    if (this.strategies[key] && typeof this.strategies[key].processTrade === 'function') {
                        this.strategies[key].processTrade(trade);
                    }
                }
            }
        }
        
                runPeriodicAnalysis() { 
            if (!this.isRunning) return; 
            try {
                for (const key in this.strategies) {
                    if (this.strategies[key] && typeof this.strategies[key].periodicAnalyze === 'function') {
                        this.strategies[key].periodicAnalyze(); 
                    }
                }
                if (this.settings.features.enableRiskGuardian) this.riskGuardian.checkKillSwitch();

                // --- YENƒ∞: SPOOF DETECTOR OPTƒ∞Mƒ∞ZASYONUNU √áAƒûIR ---
                if (this.settings.features.enableSpoofDetection) {
                    this.spoofDetector.checkConfirmations();
                    this.spoofDetector.autoOptimizeThreshold();
                }
                // --- Bƒ∞TTƒ∞ ---

            } catch (error) {
                console.error('Periodic analysis error:', error);
                this.showNotification('Analiz hatasƒ±! Loglara bakƒ±n.', 'danger');
            }
        }

        
                calculateAllIndicators() {
            if (this.candles.length === 0) return;
            const rsiPeriod = this.settings.params.rsiPeriod;
            const atrPeriod = this.settings.params.atrPeriod;
            const bbandsPeriod = 20;

            const closes = this.candles.map(c => c.close);
            const highs = this.candles.map(c => c.high);
            const lows = this.candles.map(c => c.low);
            const volumes = this.candles.map(c => c.volume);
            const candleTimes = this.candles.map(c => c.time);

            // RSI
            if (closes.length >= rsiPeriod) {
                this.indicators.rsi = this.calculateRSI(closes, rsiPeriod);
            } else { this.indicators.rsi = []; } 

            // ATR
            if (this.candles.length >= atrPeriod) {
                this.indicators.atr = this.calculateATR(this.candles, atrPeriod);
            } else { this.indicators.atr = null; }

            // Bollinger Bands (ORƒ∞Jƒ∞NAL HALƒ∞NE D√ñND√úR√úLD√ú)
            if (closes.length >= bbandsPeriod) {
                this.indicators.bbands = this.calculateBB(closes, candleTimes, bbandsPeriod, 2);
                this.chartManager.drawBollingerBands(this.indicators.bbands);
            } else { this.indicators.bbands = null; }

            const sma = (arr, n) => arr.length < n ? null : arr.slice(-n).reduce((a,b)=>a+b,0)/n;
            this.indicators.sma20 = sma(closes, 20);
            this.indicators.sma50 = sma(closes, 50);
            this.indicators.volSma20 = sma(volumes, 20);

            let cumPV = 0, cumV = 0;
            for (const k of this.candles) { const tp = (k.high + k.low + k.close)/3; cumPV += tp * k.volume; cumV += k.volume; }
            this.indicators.vwap = cumV ? (cumPV / cumV) : null;

            this.indicators.adx = this.calcADX(this.candles, atrPeriod);
            const adx = this.indicators.adx;
            if (adx) {
                if (adx.adx > 25) this.marketRegime = 'trend';
                else if (adx.adx < 20) this.marketRegime = 'range';
                else this.marketRegime = 'transition';
            } else { this.marketRegime = 'unknown'; }
        }


        calculateRSI(prices, period) {
            let gains = 0; let losses = 0;
            const rsi = [];
            let prevAvgGain = 0;
            let prevAvgLoss = 0;

            if (prices.length < period + 1) return [];

            for (let i = 1; i <= period; i++) {
                const diff = prices[i] - prices[i - 1];
                if (diff > 0) gains += diff; else losses -= diff;
            }
            prevAvgGain = gains / period;
            prevAvgLoss = losses / period;
            const initialRs = prevAvgLoss === 0 ? Infinity : prevAvgGain / prevAvgLoss;
            rsi.push(100 - (100 / (1 + initialRs))); 

            for (let i = period + 1; i < prices.length; i++) {
                const diff = prices[i] - prices[i - 1];
                const gain = diff > 0 ? diff : 0;
                const loss = diff < 0 ? -diff : 0;
                
                prevAvgGain = (prevAvgGain * (period - 1) + gain) / period;
                prevAvgLoss = (prevAvgLoss * (period - 1) + loss) / period;
                
                const rs = prevAvgLoss === 0 ? Infinity : prevAvgGain / prevAvgLoss;
                const rsiValue = 100 - (100 / (1 + rs));
                rsi.push(rsiValue);
            }
            return rsi;
        }

        calculateATR(candles, period) {
            if (candles.length < period + 1) return null;
            let trs = [];
            for (let i = 1; i < candles.length; i++) {
                const c = candles[i], p = candles[i - 1];
                trs.push(Math.max(c.high - c.low, Math.abs(c.high - p.close), Math.abs(c.low - p.close)));
            }
            if (trs.length < period) return null;
            
            let atr = trs.slice(0, period).reduce((a, b) => a + b, 0) / period;

            for (let i = period; i < trs.length; i++) {
                atr = (atr * (period - 1) + trs[i]) / period;
            }
            return atr;
        }

              calculateBB(prices, times, period, stdDev) {
            const result = { upper: [], middle: [], lower: [] };
            if (prices.length < period) return null;

            for (let i = period - 1; i < prices.length; i++) {
                const slice = prices.slice(i - period + 1, i + 1);
                const sma = slice.reduce((a, b) => a + b, 0) / period;
                const std = Math.sqrt(
                    slice.map(p => Math.pow(p - sma, 2)).reduce((a, b) => a + b, 0) / period
                );
                result.middle.push({ time: times[i], value: sma });
                result.upper.push({ time: times[i], value: sma + (std * stdDev) });
                result.lower.push({ time: times[i], value: sma - (std * stdDev) });
            }
            return result;
        }



        calcADX(candles, period = 14) {
            if (!candles || candles.length < period * 2) return null; 
            const trs = [], plusDMs = [], minusDMs = [];
            for (let i = 1; i < candles.length; i++) {
                const c = candles[i], p = candles[i-1];
                trs.push(Math.max(c.high - c.low, Math.abs(c.high - p.close), Math.abs(c.low - p.close)));
                const upMove = c.high - p.high;
                const downMove = p.low - c.low;
                plusDMs.push((upMove > downMove && upMove > 0) ? upMove : 0);
                minusDMs.push((downMove > upMove && downMove > 0) ? downMove : 0);
            }
            const smooth = (arr) => {
                const smoothed = [arr.slice(0, period).reduce((a, b) => a + b, 0) / period];
                for (let i = period; i < arr.length; i++) {
                    smoothed.push((smoothed[smoothed.length - 1] * (period - 1) + arr[i]) / period);
                }
                return smoothed;
            };
            const sTR = smooth(trs);
            const sPlusDM = smooth(plusDMs);
            const sMinusDM = smooth(minusDMs);

            if (sTR.length === 0 || sPlusDM.length === 0 || sMinusDM.length === 0) return null;

            const plusDIs = sPlusDM.map((val, idx) => 100 * (val / (sTR[idx] || 1e-8)));
            const minusDIs = sMinusDM.map((val, idx) => 100 * (val / (sTR[idx] || 1e-8)));
            
            const dxs = plusDIs.map((pdi, idx) => 100 * Math.abs(pdi - minusDIs[idx]) / ((pdi + minusDIs[idx]) || 1e-8));
            
            if (dxs.length < period) return null;

            const adxValues = smooth(dxs.slice(period - 1));
            
            if (!adxValues || adxValues.length === 0) return null;
            return {
                adx: adxValues[adxValues.length-1],
                pdi: plusDIs[plusDIs.length-1],
                mdi: minusDIs[minusDIs.length-1]
            };
        }

        getOrderBookSnapshotInfo() {
            const ob = this.orderBook;
            if (!ob || !ob.bids || ob.bids.length === 0 || !ob.asks || ob.asks.length === 0) return null;
            const bestBid = ob.bids[0][0], bestAsk = ob.asks[0][0];
            const mid = (bestAsk + bestBid)/2;
            const spreadPct = (bestAsk - bestBid) / mid;
            const topN = this.settings.optimization.gating.topN || 5;
            const sumUsd = (levels) => levels.slice(0, topN).reduce((s,[p,q])=> s + (p*q), 0);
            const topBidUsd = sumUsd(ob.bids);
            const topAskUsd = sumUsd(ob.asks);
            const minTopUsd = Math.min(topBidUsd, topAskUsd);
            return { spreadPct, minTopUsd };
        }
        marketGatingPenalty(direction) {
            const info = this.getOrderBookSnapshotInfo();
            if (!info || !this.settings.optimization.gating.enabled) return 0;
            const g = this.settings.optimization.gating;
            let penalty = 0;
            if (info.spreadPct > g.spreadMaxPct) penalty += 1.5; 
            if (info.minTopUsd < g.minDepthUsd) penalty += 1.5; 
            return penalty;
        }

        getEffectiveThreshold() { return (this.settings.confluenceThreshold || 3) + (this.runtimeThresholdOffset || 0); }

        calculateDynamicTpSl(signal) {
            const atr = this.indicators.atr;
            let rrRatioBase = this.settings.params.rrRatio;
            const minTh = this.getEffectiveThreshold();
            const over = Math.max(0, (signal.score - minTh));
            rrRatioBase *= (1 + Math.min(0.3, over / 10)); 

            if (this.marketRegime === 'trend') rrRatioBase *= 1.1;
            if (this.marketRegime === 'range') rrRatioBase *= 0.95;

            if (!atr || atr === 0) { 
                signal.tp = signal.direction === 'buy' ? signal.price * (1 + 0.005) : signal.price * (1 - 0.005);
                signal.sl = signal.direction === 'buy' ? signal.price * (1 - 0.005 / rrRatioBase) : signal.price * (1 + 0.005 / rrRatioBase);
            } else {
                const atrMultiplier = 1.5 - (Math.min(10, Math.max(0, signal.score)) / 20);
                const slDistance = atr * atrMultiplier;
                const tpDistance = slDistance * rrRatioBase;
                if (signal.direction === 'buy') { signal.sl = signal.price - slDistance; signal.tp = signal.price + tpDistance; }
                else { signal.sl = signal.price + slDistance; signal.tp = signal.price - tpDistance; }
                signal.entrySlDistance = slDistance;
                signal.entryTpDistance = tpDistance;
            }
        }

        manageOpenPositions() {
            if (!this.isRunning || !this.marketData.price || !this.settings.optimization.breakeven.enabled) return;
            const price = this.marketData.price;
            const atr = this.indicators.atr;
            if (!atr) return; 

            let changed = false;
            const activeSignals = this.signals.filter(s => s.status === 'active' && s.symbol === this.currentSymbol);
            for (const s of activeSignals) {
                if (!s.entrySlDistance || s.entrySlDistance <= 0) continue; 
                const rNow = s.direction === 'buy' ? (price - s.price) / s.entrySlDistance : (s.price - price) / s.entrySlDistance;
                s.mfeR = Math.max(s.mfeR || 0, rNow); 
                const settings = this.settings.optimization.breakeven;

                if (!s.beDone && s.mfeR >= (settings.beAtR || 0.8)) {
                    s.sl = s.price; 
                    s.beDone = true;
                    s.note = (s.note ? s.note + ' | ' : '') + 'SL->BE';
                    changed = true;
                    this.showNotification(`Sinyal ${s.id.substring(4,10)} i√ßin SL maliyete √ßekildi.`, 'info');
                }
                if (s.mfeR >= (settings.trailAfterR || 1.5) && (s.trailingStage || 0) < 1) {
                    let newSl;
                    if (s.direction === 'buy') {
                        newSl = price - (atr * settings.trailToR); 
                        s.sl = Math.min(s.tp, Math.max(s.sl, newSl)); 
                    } else { 
                        newSl = price + (atr * settings.trailToR); 
                        s.sl = Math.max(s.tp, Math.min(s.sl, newSl)); 
                    }
                    s.trailingStage = 1;
                    s.note = (s.note ? s.note + ' | ' : '') + 'Trail1';
                    changed = true;
                    this.showNotification(`Sinyal ${s.id.substring(4,10)} i√ßin SL g√ºncellendi (Trailing).`, 'info');
                }
            }
            if (changed) { this.saveData('utc_signals', this.signals); this.debouncedRender(); }
        }

        checkAutoCloseSignals() {
            if (!this.isRunning || !this.marketData.price) return;
            const price = this.marketData.price;
            const activeSignals = this.signals.filter(s => s.status === 'active' && s.symbol === this.currentSymbol);
            for (const s of activeSignals) {
                if (s.direction === 'buy') {
                    if (price >= s.tp) { this.updateSignalResult(s.id, 'tp'); }
                    else if (price <= s.sl) { this.updateSignalResult(s.id, 'sl'); }
                } else if (s.direction === 'sell') {
                    if (price <= s.tp) { this.updateSignalResult(s.id, 'tp'); }
                    else if (price >= s.sl) { this.updateSignalResult(s.id, 'sl'); }
                }
            }
        }

        render() { 
            this.renderPriceDisplay(); 
            this.updateSignalProgressBar(); 
        }
        renderPriceDisplay() {
            const priceEl = document.getElementById('current-price');
            const tickerPriceEl = document.getElementById('ticker-bar-price');
            const oldPriceText = tickerPriceEl ? tickerPriceEl.textContent.replace(/,/g, '') : '0';
            const oldPrice = parseFloat(oldPriceText);
            
            if (this.marketData.price) {
                const formattedPrice = this.formatPrice(this.marketData.price);
                if (priceEl) priceEl.textContent = formattedPrice;
                if(tickerPriceEl) tickerPriceEl.textContent = formattedPrice;

                if (!isNaN(oldPrice) && oldPrice !== 0) { 
                    const color = this.marketData.price > oldPrice ? 'var(--positive)' : (this.marketData.price < oldPrice ? 'var(--negative)' : '');
                    if (tickerPriceEl) {
                        tickerPriceEl.style.transition = 'none';
                        tickerPriceEl.style.color = color;
                        setTimeout(() => {
                           tickerPriceEl.style.transition = 'color 0.5s ease';
                           tickerPriceEl.style.color = '';
                        }, 100);
                    }
                }
            }
            const change = this.marketData.change24h || 0;
            const changeEl = document.getElementById('price-change-24h');
            if (changeEl) { changeEl.textContent = `${change.toFixed(2)}%`; changeEl.style.color = change >= 0 ? 'var(--positive)' : 'var(--negative)'; }
            const volumeEl = document.getElementById('volume-24h'); if(volumeEl) volumeEl.textContent = this.formatVolume(this.marketData.volume24h);
            const atrEl = document.getElementById('atr-value'); if(atrEl) atrEl.textContent = this.indicators.atr ? this.indicators.atr.toFixed(this.getDecimalPlaces(this.indicators.atr)) : '-';
        }

        updateCandleCountdown() {
            const headerCountdownEl = document.getElementById('candle-countdown');
            const chartCountdownEl = document.getElementById('chart-countdown-overlay');

            if (!this.isRunning || this.candles.length === 0) {
                headerCountdownEl.textContent = '--:--';
                chartCountdownEl.textContent = '--:--';
                return;
            }
            const now = Date.now();
            const lastCandleOpenTime = this.candles[this.candles.length - 1].time; 
            const timeframeMs = this._timeframeToMs(this.currentTimeframe);
            
            const nextCandleOpenTime = lastCandleOpenTime + timeframeMs;
            let remainingTime = nextCandleOpenTime - now;
            
            if (remainingTime < 0 || remainingTime > timeframeMs) {
                 remainingTime = timeframeMs - (now % timeframeMs);
            }

            remainingTime = Math.max(0, remainingTime); 
            const minutes = Math.floor(remainingTime / 60000);
            const seconds = Math.floor((remainingTime % 60000) / 1000);
            const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            headerCountdownEl.textContent = formattedTime;
            if (this.currentMainView === 'chart' || document.body.classList.contains('fullscreen-chart')) {
                chartCountdownEl.textContent = formattedTime;
                chartCountdownEl.classList.remove('hidden-view');
            } else {
                chartCountdownEl.classList.add('hidden-view');
            }
        }
         _timeframeToMs(tf) {
            const unit = tf.slice(-1);
            const val = parseInt(tf.slice(0, -1));
            if (unit === 'm') return val * 60 * 1000;
            if (unit === 'h') return val * 60 * 60 * 1000;
            if (unit === 'd') return val * 24 * 60 * 60 * 1000;
            return 60000;
        }

        updateSignalProgressBar() {
            const buyFill = document.getElementById('buy-signal-bar-fill');
            const sellFill = document.getElementById('sell-signal-bar-fill');
            const buyScoreText = document.getElementById('buy-signal-score-text');
            const sellScoreText = document.getElementById('sell-signal-score-text');
            if (!buyFill || !sellFill || !buyScoreText || !sellScoreText) return;

            const maxScoreForDisplay = 10; 
            const buyScore = this.confluenceEngine.buyScore || 0;
            const sellScore = this.confluenceEngine.sellScore || 0;

            const buyPercent = Math.min(100, Math.max(0, (buyScore / maxScoreForDisplay) * 100));
            const sellPercent = Math.min(100, Math.max(0, (sellScore / maxScoreForDisplay) * 100));

            buyFill.style.width = `${buyPercent}%`;
            sellFill.style.width = `${sellPercent}%`;

            buyScoreText.textContent = isFinite(buyScore) ? buyScore.toFixed(1) : '0.0';
            sellScoreText.textContent = isFinite(sellScore) ? sellScore.toFixed(1) : '0.0';
        }

        addPendingSignal(signal) {
            this.pendingSignals.push(signal);
            this.chartManager.addSignalMarker(signal);
            this.showNotification(`ADAY Sƒ∞NYAL: ${signal.direction.toUpperCase()} ${signal.symbol.replace('USDT', '/USDT')} | Skor: ${signal.score.toFixed(1)}. Mum kapanƒ±≈üƒ± bekleniyor.`, 'warning', 4000);
        }

        checkPendingSignals(closedCandle) {
            const signalsToActivate = [];
            this.pendingSignals = this.pendingSignals.filter(signal => {
                if (signal.timestamp < closedCandle.time) {
                    let isValid = false;
                    if (signal.direction === 'buy' && closedCandle.close > closedCandle.open) {
                        isValid = true;
                    } else if (signal.direction === 'sell' && closedCandle.close < closedCandle.open) {
                        isValid = true;
                    }
                    
                    if (isValid) {
                        signalsToActivate.push(signal);
                    } else {
                        this.showNotification(`ƒ∞PTAL: ${signal.direction.toUpperCase()} sinyali mum kapanƒ±≈üƒ±nda onaylanmadƒ±.`, 'danger', 3000);
                    }
                    return false;
                }
                return true;
            });
            signalsToActivate.forEach(signal => this.activateSignal(signal));
        }

        activateSignal(signal) {
            // Confluence Engine'den sinyali doƒürula
            if (this.confluenceEngine && !this.confluenceEngine.validateSignal(signal)) {
                this.showNotification(`Sƒ∞NYAL REDDEDƒ∞LDƒ∞: Confluence puanƒ± yetersiz`, 'warning', 3000);
                return;
            }
            
            signal.status = 'active';
            this.signals.unshift(signal); 
            if (this.signals.length > 200) this.signals.pop();
            
            // Verileri kaydet
            this.saveData('utc_signals', this.signals);
            
            // Veritabanƒ±na sinyali kaydet
            if (this.dbManager && this.dbManager.ready) {
                this.dbManager.put('signals', {
                    ...signal,
                    savedAt: Date.now()
                });
            }
            
            // UI'yi g√ºncelle
            this.debouncedRender();
            this.chartManager.addSignalMarker(signal);
            
            // Bildirim g√∂ster
            let sizeText = signal.recommendedSize ? ` | Boyut: ${signal.recommendedSize}` : '';
            this.showNotification(`AKTƒ∞F Sƒ∞NYAL: ${signal.direction.toUpperCase()} ${signal.symbol.replace('USDT', '/USDT')} | Skor: ${signal.score.toFixed(1)}${sizeText}`, signal.direction === 'buy' ? 'success' : 'danger');
            
            // Ses efektleri
            playSignal(signal.direction); 
            const messageKey = signal.direction === 'buy' ? 'buy' : 'sell';
            const message = this.getRandomMessage(messageKey, { 
                Sembol: signal.symbol.replace('USDT', ''), 
                Skor: signal.score.toFixed(1) 
            });
            this.speak(message);
            
            // Y√ºksek skorlu sinyal i√ßin sava≈ü modunu aktifle≈ütir
            if (signal.score >= 8 && !this.combatModeActive) { 
                this.activateCombatMode(); 
            }
            
            // G√∂rsel efektler
            if (this.effectsManager) {
                const pricePos = this.chartManager?.getPriceCoordinateForTimestamp(signal.timestamp) || {
                    x: window.innerWidth / 2,
                    y: window.innerHeight / 2
                };
                
                this.effectsManager.createExplosionEffect(
                    pricePos.x, 
                    pricePos.y, 
                    signal.direction === 'buy' ? '#00ff00' : '#ff0000',
                    signal.score * 3 // Skor ne kadar y√ºksekse, o kadar b√ºy√ºk patlama efekti
                );
            }
            
            // Panteon sistemine g√º√ß ekle
            if (this.panteonManager) {
                // Stratejiye g√∂re farklƒ± el√ßilere g√º√ß ekle
                this.panteonManager.awardPowerForSignal(signal);
            }
            
            // Event'i emit et
            this.emit('signal', signal);
            
            // Oracle ile entegrasyon - Mah≈üerin Atlƒ±larƒ± aktifse ek bildirim g√∂ster
            if (this.oracle && this.oracle.isAnyHorsemanActive()) {
                const activeHorsemen = this.oracle.getActiveHorsemen();
                const horsemanNames = activeHorsemen.map(key => this.oracle.getHorsemanName(key)).join(", ");
                
                setTimeout(() => {
                    this.showNotification(`Dƒ∞KKAT: Mah≈üerin ${activeHorsemen.length > 1 ? 'Atlƒ±larƒ±' : 'Atlƒ±sƒ±'} (${horsemanNames}) aktif! Risk y√ºksek olabilir.`, 'warning', 5000);
                }, 1000);
            }
        }

        getRecommendedPositionSize(score) {
            if(!this.settings.features.enableDynamicSizing) return null;
            if (score >= 7.5) return "2.0x Y√ºksek";
            if (score >= 6.0) return "1.5x Orta-Y√ºksek";
            if (score >= 4.5) return "1.0x Standart";
            return "0.5x D√º≈ü√ºk";
        }

        updateSignalResult(signalId, result) {
            const signalIndex = this.signals.findIndex(s => s.id === signalId);
            if(signalIndex !== -1 && this.signals[signalIndex].status === 'active') {
                const signal = this.signals[signalIndex];
                signal.status = result;
                signal.completedAt = Date.now();
                this.stats.total++;
                this.stats[result]++;
                
                // ƒ∞statistikleri g√ºncelle
                this.updateStrategyStats(signal);
                this.updateStrategyShadowStats(signal);
                this.evaluateShadowRehab();
                
                // Veritabanƒ±nda g√ºncelle
                if (this.dbManager && this.dbManager.ready) {
                    // Sinyali g√ºncelle
                    this.dbManager.put('signals', {
                        ...signal,
                        updatedAt: Date.now()
                    });
                    
                    // ƒ∞statistikleri g√ºncelle
                    this.dbManager.put('stats', {
                        id: 'global',
                        data: this.stats,
                        updatedAt: Date.now()
                    });
                }
                
                // Event'i emit et
                this.emit('signalResult', { signal, result });
                
                // Panteon sistemine sonu√ß bildir
                if (this.panteonManager) {
                    if (result === 'tp') {
                        // Ba≈üarƒ±lƒ± sinyal i√ßin daha fazla g√º√ß
                        this.panteonManager.increasePower('metatron', 10);
                        
                        // Ba≈üarƒ±lƒ± bir sinyal i√ßin efekt
                        if (this.effectsManager) {
                            this.effectsManager.createMatrixEffect();
                        }
                    } else if (result === 'sl') {
                        // Kaybedilen sinyal i√ßin ≈üifacƒ±ya g√º√ß
                        this.panteonManager.increasePower('raphael', 5);
                    }
                }

                if (this.settings.features.enableCUSUMDrift) {
                    const driftDetected = this.cusumDetector.update(result === 'tp');
                    if (driftDetected) {
                        this.showNotification('PERFORMANS SAPMASI!', 'Sinyal kazanma oranƒ±nda sapma tespit edildi. Ayarlar optimize ediliyor...', 'warning');
                        this.speak(this.getRandomMessage('cusumDriftDetected'));
                    }
                }

                this.saveData('utc_signals', this.signals);
                this.saveData('utc_stats', this.stats);
                this.debouncedRender();
                this.showNotification(`Sinyal ${signal.id.substring(4,10)} - ${result.toUpperCase()} olarak sonu√ßlandƒ±.`, 'info');
                const messageKey = result === 'tp' ? 'signalTP' : 'signalSL';
                this.speak(this.getRandomMessage(messageKey));
            }
        }

        updateStrategyStats(signal) {
            const isWin = signal.status === 'tp';
            const contributors = signal.contributors || [];
            if(contributors.length === 0) return;
            const totalEff = contributors.reduce((s, c) => s + (c.effScore || (c.baseScore * (c.weight||1))), 0) || 1;
            const decay = 0.995; 

            for (const c of contributors) {
                let stratStats = this.strategyStats[c.strategy];
                if (!stratStats) {
                    stratStats = this.initDefaultStrategyStats()[c.strategy];
                    this.strategyStats[c.strategy] = stratStats;
                }
                
                const updateStat = (statObj) => {
                    statObj.alpha = (statObj.alpha || 3) * decay; 
                    statObj.beta = (statObj.beta || 2) * decay;   
                    const credit = (c.effScore || (c.baseScore * (c.weight || 1))) / totalEff; 
                    statObj.contrib = (statObj.contrib || 0) + 1;
                    if (isWin) { statObj.wins = (statObj.wins || 0) + credit; statObj.alpha += credit; }
                    else { statObj.losses = (statObj.losses || 0) + credit; statObj.beta += credit; }
                    statObj.lastUpdate = Date.now();
                };

                updateStat(stratStats.overall);
                const currentRegimeStats = stratStats[this.marketRegime];
                if (currentRegimeStats) {
                    updateStat(currentRegimeStats);
                }
            }
            this.saveStrategyStats();
        }

        recordShadowProposal(strategy, direction, reason, score) {
            const now = Date.now();
            this.shadowProposals.push({ strategy, direction, reason, score, timestamp: now });
            if (this.shadowProposals.length > 2000) this.shadowProposals.splice(1500); 
        }

        updateStrategyShadowStats(signal) {
            const windowMs = (this.settings.cooldowns?.proposalTimeoutMs || 3000) * 2;
            const start = signal.timestamp - windowMs;
            const end = signal.timestamp;
            const creditBase = 0.5;

            const byStrat = {};
            for (const p of this.shadowProposals) {
                if (p.timestamp >= start && p.timestamp <= end && p.direction === signal.direction) {
                    byStrat[p.strategy] = p;
                }
            }
            for (const strat of Object.keys(byStrat)) {
                let stratStats = this.strategyStats[strat];
                if (!stratStats) {
                    stratStats = this.initDefaultStrategyStats()[strat];
                    this.strategyStats[strat] = stratStats;
                }
                
                const updateStat = (statObj) => {
                    statObj.shadowProposals = (statObj.shadowProposals || 0) + 1;
                    if (signal.status === 'tp') {
                        statObj.shadowWins = (statObj.shadowWins || 0) + 1;
                        statObj.alpha = (statObj.alpha || 3) + creditBase;
                    } else if (signal.status === 'sl') {
                        statObj.shadowLosses = (statObj.shadowLosses || 0) + 1;
                        statObj.beta = (statObj.beta || 2) + creditBase;
                    }
                    statObj.lastUpdate = Date.now();
                };
                
                updateStat(stratStats.overall);
                const currentRegimeStats = stratStats[this.marketRegime];
                if (currentRegimeStats) {
                    updateStat(currentRegimeStats);
                }
            }
            const keepAfter = Date.now() - 10 * 60 * 1000;
            this.shadowProposals = this.shadowProposals.filter(p => p.timestamp >= keepAfter);
            this.saveStrategyStats();
        }

                evaluateShadowRehab() {
            const pen = this.settings.penalties || {};
            if (!pen.shadowEnabled) return;

            for (const key of this.allStrategyKeys) {
                if (!this.settings.statusMaps.shadowBanned[key] || this.settings.statusMaps.hardBanned[key]) continue;

                const st = this.strategyStats[key]?.overall || {};
                const sw = st.shadowWins || 0,
                    sl = st.shadowLosses || 0,
                    sp = st.shadowProposals || 0;
                const total = sw + sl;
                const winRate = total > 0 ? sw / total : 0;

                if (sp >= (pen.minShadowProposals || 20) && winRate >= (pen.rehabWinRate || 0.58)) {
                    this.settings.activeStrategies[key] = true;
                    this.settings.statusMaps.shadowBanned[key] = false;
                    this.updateActiveStrategies();
                    this.saveSettings();
                    this.showNotification(`Rehabilite: ${this.strategies[key].displayName} tekrar canlƒ±! (g√∂lge WR=${(winRate*100).toFixed(0)}%)`, 'success');
                    
                    // --- EKSƒ∞K OLAN SATIR BURAYA EKLENDƒ∞ ---
                    this.speak(this.getRandomMessage('shadowRehab', { 'Strateji': this.strategies[key].displayName }));
                }
            }
        }


                autoToggleStrategies() {
            if (!this.settings.optimization.enabled || !this.settings.optimization.autoToggle) return;
            const now = Date.now();
            if (now - this.lastAutoToggleTs < 5 * 60 * 1000) return;
            this.lastAutoToggleTs = now;
            const minW = this.settings.optimization.minWeightToStay || 0.6;
            const minContrib = this.settings.optimization.minContribForToggle || 30;

            let changed = false;
            for (const key of this.allStrategyKeys) {
                const w = this.getStrategyWeight(key);
                const stat = this.strategyStats[key]?.overall || {};
                const active = !!this.settings.activeStrategies[key];

                if (active && !this.settings.statusMaps.hardBanned[key] && w < minW && (stat.contrib || 0) >= minContrib) {
                    this.settings.activeStrategies[key] = false;
                    this.settings.statusMaps.shadowBanned[key] = true;
                    this.showNotification(`Oto-optimizasyon: ${this.strategies[key].displayName} g√∂lgeye alƒ±ndƒ± (w=${w.toFixed(2)}).`, 'warning');
                    
                    // --- EKSƒ∞K OLAN SATIR BURAYA EKLENDƒ∞ ---
                    this.speak(this.getRandomMessage('shadowBan', { 'Strateji': this.strategies[key].displayName }));
                    
                    changed = true;
                }
            }
            if (changed) {
                this.updateActiveStrategies();
                this.saveSettings();
                this.updateSettingsModalUI();
            }
        }


        autoTuneCooldowns() {
            if (!this.isRunning || !this.settings.optimization.enabled) return;
            const now = Date.now();
            const WINDOW_MS = 5 * 60 * 1000; 
            const recentSignals = this.signals.filter(s => s.status !== 'active' && s.symbol === this.currentSymbol && now - s.timestamp <= WINDOW_MS).slice(0, 50).sort((a,b)=> a.timestamp - b.timestamp);
            let quickFlips = 0, totalPairs = 0;
            if (recentSignals.length >= 2) {
                for (let i = 1; i < recentSignals.length; i++) {
                    totalPairs++;
                    const dt = recentSignals[i].timestamp - recentSignals[i-1].timestamp;
                    if (recentSignals[i-1].direction !== recentSignals[i].direction && dt <= 15000) { 
                        quickFlips++;
                    }
                }
            }
            const flipRatio = totalPairs ? (quickFlips / totalPairs) : 0;
            const volPct = (this.indicators.atr && this.marketData.price) ? (this.indicators.atr / this.marketData.price) : 0.001;

            const cd = this.settings.cooldowns;
            const baseSame = this.loadSettings().cooldowns.sameDirectionMs;
            const baseOpp = this.loadSettings().cooldowns.oppositeDirectionMs;
            const baseSignal = this.loadSettings().cooldowns.signalMs;
            const baseProposalTimeout = this.loadSettings().cooldowns.proposalTimeoutMs;

            const newSame = Math.max(10000, Math.min(120000, Math.round(baseSame * (1 + flipRatio * 0.8))));
            const newOpp  = Math.max(5000, Math.min(120000, Math.round(baseOpp  * (1 + flipRatio * 1.2))));
            const volFactor = volPct < 0.005 ? 1.2 : (volPct > 0.02 ? 0.8 : 1.0);
            const newSignal = Math.max(3000, Math.min(60000, Math.round(baseSignal * volFactor)));
            const newProposalTimeout = Math.max(1500, Math.min(8000, Math.round(baseProposalTimeout * volFactor)));

            let changed = false;
            if (Math.abs(newSame - cd.sameDirectionMs) / cd.sameDirectionMs > 0.05) { cd.sameDirectionMs = newSame; changed = true; }
            if (Math.abs(newOpp - cd.oppositeDirectionMs) / cd.oppositeDirectionMs > 0.05) { cd.oppositeDirectionMs = newOpp; changed = true; }
            if (Math.abs(newSignal - cd.signalMs) / cd.signalMs > 0.05) { cd.signalMs = newSignal; changed = true; }
            if (Math.abs(newProposalTimeout - cd.proposalTimeoutMs) / cd.proposalTimeoutMs > 0.05) { cd.proposalTimeoutMs = newProposalTimeout; changed = true; }

            if (changed) {
                this.saveSettings();
                this.updateSettingsModalUI(); 
                this.showNotification(`Cooldown optimize edildi (flip: ${(flipRatio*100).toFixed(0)}%, vol: ${(volPct*100).toFixed(2)}%).`, 'info');
                this.speak(this.getRandomMessage('cooldownOptimize'));
            }
        }

        autoTuneThresholds() {
            if (!this.isRunning || !this.settings.optimization.enabled) return;
            const now = Date.now();
            const WINDOW_MS = 10 * 60 * 1000;
            const recentSignals = this.signals.filter(s => s.status !== 'active' && s.symbol === this.currentSymbol && now - s.timestamp <= WINDOW_MS).slice(0, 100);
            
            let winRate = recentSignals.length > 5 ? (recentSignals.filter(s => s.status === 'tp').length / recentSignals.length) : 0.55;
            let currentOffset = this.runtimeThresholdOffset || 0;
            let newOffset = currentOffset;

            if (winRate < 0.50) newOffset += 0.1;
            else if (winRate > 0.65) newOffset -= 0.1;
            
            newOffset = Math.max(-1.0, Math.min(2.0, newOffset));

            if (Math.abs(newOffset - currentOffset) > 0.05) {
                this.runtimeThresholdOffset = parseFloat(newOffset.toFixed(1));
                this.showNotification(`Sinyal e≈üiƒüi optimize edildi: Yeni Ofset ${this.runtimeThresholdOffset.toFixed(1)} (WR: ${(winRate*100).toFixed(1)}%).`, 'info');
            }
        }

        autoTuneStrategyParams() {
            if (!this.settings.optimization.enabled) return;
            const step = 0.05;
            const meta = {
                wallBounce: { DISTANCE_THRESHOLD_PERCENT: {min:0.0001,max:0.001, strict:'down'} },
                velocityScalping: { VELOCITY_THRESHOLD_PERCENT:{min:0.0005,max:0.003, strict:'up'} },
                liquidityGaps: { GAP_THRESHOLD_PERCENT:{min:0.0003,max:0.003, strict:'up'} },
                breakoutPattern: { BREAK_PCT:{min:0.0001,max:0.001, strict:'up'}, VOL_SPIKE:{min:1.0,max:3.0, strict:'up'} },
                supportResistance: { THRESH:{min:0.0005,max:0.005, strict:'down'} },
                fibonacciRetracement: { TOL:{min:0.0005,max:0.005, strict:'down'} },
                vwapReversion: { MULT:{min:0.6,max:2.0, strict:'up'} },
                superTrend: { MULT:{min:1.0,max:6.0, strict:'up'} },
                marketStructure: { SWING:{min:2,max:7, strict:'up'} },
                institutionalOrderFlow: { IMB_THRESHOLD:{min:1.2,max:4.0, strict:'up'} },
                microSpreadArbitrage: { SPREAD_PCT:{min:0.0003,max:0.003, strict:'up'} },
                volumeProfile: { PERIOD: 20, SPIKE: 2.0, CLOSE_POS: 0.7 },
                divergenceDetection: { SWING_PERIOD:{min:2,max:5, strict:'up'} },
                volatilityBreakout: { SQUEEZE_MULT: {min:0.5,max:2.0, strict:'up'}, BREAKOUT_VOL_MULT: {min:1.0,max:3.0, strict:'up'} },
                candleCharacter: { MIN_BODY_TO_WICK_RATIO: {min:0.4,max:0.8, strict:'up'}, ANALYSIS_WINDOW_PERCENT: {min:0.1,max:0.3, strict:'down'} },
                fundingRateReversal: { EXTREME_FUNDING_THRESHOLD: {min:0.0005,max:0.002, strict:'up'} }
            };

            const p = this.settings.strategyParams;
            let changed = false;

            for (const key of Object.keys(this.strategies)) {
                const w = this.getStrategyWeight(key);
                const defs = meta[key]; if (!defs) continue;
                const currentParams = p[key] || {}; 
                let localChanged = false;
                const direction = (w < 0.7) ? 'moreStrict' : (w > 1.3 ? 'lessStrict' : 'keep');
                if (direction === 'keep') continue;

                for (const par of Object.keys(defs)) {
                    const conf = defs[par]; 
                    const val = currentParams[par] ?? this.strategies[key][par];
                    if (val == null) continue;

                    let newVal = val;
                    if (direction === 'moreStrict') {
                        if (conf.strict === 'up') newVal = val * (1 + step);
                        else if (conf.strict === 'down') newVal = val * (1 - step);
                    } else if (direction === 'lessStrict') {
                        if (conf.strict === 'up') newVal = val * (1 - step);
                        else if (conf.strict === 'down') newVal = val * (1 + step);
                    }
                    newVal = Math.max(conf.min, Math.min(conf.max, newVal));
                    
                    if (Math.abs(newVal - val) / Math.max(1e-8, val) > 0.001) {
                        currentParams[par] = Number.isInteger(val) ? Math.round(newVal) : parseFloat(newVal.toPrecision(4));
                        localChanged = true;
                    }
                }
                if (localChanged) { 
                    p[key] = currentParams; 
                    changed = true; 
                }
            }

            if (changed) {
                this.saveSettings();
                this.applyStrategyParamOverrides();
                this.showNotification('Strateji parametreleri mikro-optimize edildi (ameliyat).', 'warning');
            }
        }

        // D√úZELTME: Render fonksiyonlarƒ± debounce ile √ßaƒürƒ±lacak
        debouncedRender() {
            clearTimeout(this.renderTimeout);
            this.renderTimeout = setTimeout(() => {
                this.renderSignals(true);
                this.renderStats(true);
            }, 200);
        }

        renderSignals(fullRender = false) {
            const tbody = document.getElementById('modal-signals-body');
            if (!tbody) return;
            if (fullRender) tbody.innerHTML = '';
            
            const signalsToRender = this.signals;

            signalsToRender.forEach((signal, index) => {
                const rowId = `signal-row-${signal.id}`;
                let row = document.getElementById(rowId);
                if(fullRender || !row) { 
                    if (row) row.remove();
                    row = tbody.insertRow(fullRender ? -1 : 0); // Tam render ise sona, deƒüilse ba≈üa ekle
                    row.id = rowId;
                    for(let i=0; i<11; i++) row.insertCell();
                }

                row.className = signal.status === 'tp' ? 'signal-tp' : (signal.status === 'sl' ? 'signal-sl' : (signal.status === 'pending' ? 'signal-pending' : ''));
                row.cells[0].textContent = new Date(signal.timestamp).toLocaleTimeString();
                row.cells[1].textContent = signal.symbol.replace('USDT', '');
                row.cells[2].textContent = signal.direction.toUpperCase();
                row.cells[3].textContent = this.formatPrice(signal.price);
                row.cells[4].textContent = signal.tp ? this.formatPrice(signal.tp) : '-';
                row.cells[5].textContent = signal.sl ? this.formatPrice(signal.sl) : '-';
                row.cells[6].textContent = typeof signal.score === 'number' ? signal.score.toFixed(1) : signal.score;
                row.cells[7].textContent = signal.reason;
                row.cells[8].textContent = signal.recommendedSize || '-';
                row.cells[9].textContent = signal.status.toUpperCase();
                row.cells[10].textContent = signal.note || '';
            });
        }

        renderStats() {
            const statsContainer = document.getElementById('modal-stats-container');
            if (!statsContainer) return;

            const total = this.stats.total;
            const tp = this.stats.tp;
            const winRate = total > 0 ? ((tp / total) * 100).toFixed(1) : '0.0';

            const getWR = (stat) => {
                if (!stat) return '-';
                const totalObs = (stat.wins || 0) + (stat.losses || 0);
                if (totalObs === 0) return '-';
                return (((stat.wins || 0) / totalObs) * 100).toFixed(0);
            };

            const renderRegimeStats = (regime) => {
                let regimeTotal = 0, regimeWins = 0;
                Object.values(this.strategyStats).forEach(s => {
                    const stat = s[regime]; 
                    if(stat && (stat.wins !== undefined || stat.losses !== undefined)) { 
                        regimeWins += (stat.wins || 0);
                        regimeTotal += ((stat.wins || 0) + (stat.losses || 0));
                    }
                });
                const wr = regimeTotal > 0 ? (regimeWins / regimeTotal * 100).toFixed(0) : 'N/A';
                return `<div class="stat-item"><span class="stat-label">${regime.charAt(0).toUpperCase() + regime.slice(1)} WR:</span><span class="stat-value">${wr}%</span></div>`;
            };

            const html = `
                <div class="panel-title" style="margin-bottom: 10px;">Genel Sinyal ƒ∞statistikleri</div>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 0 15px;">
                    <div class="stat-item"><span class="stat-label">Toplam Sinyal:</span><span class="stat-value">${total}</span></div>
                    <div class="stat-item"><span class="stat-label">TP (Kazanƒ±lan):</span><span class="stat-value" style="color:var(--positive);">${tp}</span></div>
                    <div class="stat-item"><span class="stat-label">SL (Kaybedilen):</span><span class="stat-value" style="color:var(--negative);">${this.stats.sl}</span></div>
                    <div class="stat-item"><span class="stat-label">Kazanma Oranƒ±:</span><span class="stat-value" style="color:${winRate >= 50 ? 'var(--positive)' : 'var(--negative)'};">${winRate}%</span></div>
                    ${renderRegimeStats('trend')}
                    ${renderRegimeStats('range')}
                </div>
                <div class="panel-title" style="margin-top: 15px; margin-bottom: 10px;">Strateji Performansƒ± (Rejime G√∂re)</div>
                <div class="data-table-container" style="max-height: 250px;">
                    <table class="data-table">
                        <thead><tr><th>Strateji</th><th>Aƒüƒ±rlƒ±k</th><th>Genel WR%</th><th>Trend WR%</th><th>Range WR%</th><th>Katkƒ±</th></tr></thead>
                        <tbody>
                            ${Object.keys(this.strategyStats).sort((a,b) => this.getStrategyWeight(b) - this.getStrategyWeight(a)).map(key => {
                                const s = this.strategyStats[key]; 
                                if (!s) return ''; 
                                const overallWR = getWR(s.overall);
                                const trendWR = getWR(s.trend);
                                const rangeWR = getWR(s.range);
                                return `
                                    <tr>
                                        <td>${this.strategies[key]?.displayName || key}</td>
                                        <td>${this.getStrategyWeight(key).toFixed(2)}</td>
                                        <td style="color:${overallWR >= 50 ? 'var(--positive)' : 'var(--negative)'}">${overallWR}</td>
                                        <td style="color:${trendWR >= 50 ? 'var(--positive)' : 'var(--negative)'}">${trendWR}</td>
                                        <td style="color:${rangeWR >= 50 ? 'var(--positive)' : 'var(--negative)'}">${rangeWR}</td>
                                        <td>${(s.overall?.contrib || 0)}</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            statsContainer.innerHTML = html;
        }

        clearAllSignals() {
            if (confirm('T√ºm sinyal ge√ßmi≈üini temizlemek istediƒüinizden emin misiniz?')) {
                this.signals = [];
                this.pendingSignals = [];
                this.stats = { total: 0, tp: 0, sl: 0 };
                this.saveData('utc_signals', this.signals);
                this.saveData('utc_stats', this.stats);
                this.debouncedRender();
                this.chartManager.clearMarkers();
                this.showNotification('Sinyal ge√ßmi≈üi temizlendi!', 'info');
            }
        }
        clearChartMarkers() { this.chartManager.clearMarkers(); this.showNotification('Grafik sinyalleri temizlendi.', 'info'); }

        formatPrice(price) { return price.toLocaleString('en-US', { minimumFractionDigits: this.getDecimalPlaces(price), maximumFractionDigits: this.getDecimalPlaces(price) }); }
        formatVolume(volume) { if (volume >= 1e9) return (volume / 1e9).toFixed(2) + 'B'; if (volume >= 1e6) return (volume / 1e6).toFixed(2) + 'M'; if (volume >= 1e3) return (volume / 1e3).toFixed(2) + 'K'; return volume.toFixed(2); }
        getDecimalPlaces(price) { if (!price) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
        
        showNotification(message, type = 'info', timeout = 5000) {
            // Map traditional notification types to new categories
            let category = 'system';
            let priority = 2;
            
            switch(type) {
                case 'success':
                    category = 'success';
                    priority = 3;
                    break;
                case 'danger':
                    category = 'error';
                    priority = 4;
                    break;
                case 'warning':
                    category = 'alert';
                    priority = 3;
                    break;
                case 'info':
                    if (message.toLowerCase().includes('sinyal')) {
                        category = 'trade';
                        priority = 3;
                    }
                    break;
            }
            
            // Detect important notifications
            if (message.toLowerCase().includes('tehlike') || 
                message.toLowerCase().includes('kritik') ||
                message.toLowerCase().includes('uyarƒ±') ||
                message.toLowerCase().includes('dikkat') ||
                message.toLowerCase().includes('durdur')) {
                priority = 4;
            }
            
            // Use the new notification center if available
            if (this.notificationCenter) {
                return this.notificationCenter.notify(message, category, priority, timeout);
            } else {
                // Legacy fallback
                const container = document.getElementById('notifications-container');
                if (!container) return;
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                container.appendChild(notification);
                setTimeout(() => { notification.remove(); }, timeout);
                return notification;
            }
        }
                logToJournal(message, level = 'log') {
            const timestamp = new Date().toLocaleTimeString();
            const formattedMessage = `[${timestamp}] ${message}`;
            console.log(formattedMessage); // Konsola yazdƒ±rmaya devam et

            const logOutput = document.getElementById('log-output');
            if (logOutput) {
                const logEntry = document.createElement('div');
                logEntry.textContent = formattedMessage;
                if (level === 'error') logEntry.className = 'log-error';
                if (level === 'warn') logEntry.className = 'log-warn';
                if (level === 'info') logEntry.className = 'log-info';
                
                const isScrolledToBottom = logOutput.scrollHeight - logOutput.clientHeight <= logOutput.scrollTop + 1;
                logOutput.appendChild(logEntry);
                if (isScrolledToBottom) {
                    logOutput.scrollTop = logOutput.scrollHeight;
                }
            }
        }
        // YENƒ∞: Loglarƒ± dƒ±≈üa aktarma fonksiyonu
        exportLogs() {
            const logOutput = document.getElementById('log-output');
            if (!logOutput || !logOutput.textContent.trim()) {
                this.showNotification('Dƒ±≈üa aktarƒ±lacak log bulunmuyor.', 'warning');
                return;
            }
            const blob = new Blob([logOutput.textContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `utc_logs_${new Date().toISOString().slice(0,10)}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            this.showNotification('Loglar ba≈üarƒ±yla dƒ±≈üa aktarƒ±ldƒ±.', 'success');
        }

        updateConnectionStatus(isConnected, message = '') {
            const statusDot = document.getElementById('connection-status');
            const statusText = document.getElementById('connection-text');
            if (isConnected) {
                statusDot.classList.add('online');
                statusText.textContent = 'BAƒûLI';
                statusText.style.color = 'var(--positive)';
            } else {
                statusDot.classList.remove('online');
                statusText.textContent = message || 'BAƒûLANTI YOK';
                statusText.style.color = 'var(--negative)';
            }
        }

        updateSession() {
            this.sessionState = this.sessionProfiler.getCurrentSession();
        }

        activateCombatMode() {
            if (this.combatModeActive) return;
            this.combatModeActive = true;
            document.documentElement.setAttribute('data-theme', 'war');
            this.chartManager.updateTheme();
            this.heatmapManager.updateTheme();
            this.showNotification('SAVA≈û MODU AKTƒ∞F EDƒ∞LDƒ∞!', 'danger');
            this.speak(this.getRandomMessage('combatModeActivate'));
            playSignal('combat');
        }

        deactivateCombatMode() {
            if (!this.combatModeActive) return;
            this.combatModeActive = false;
            const savedTheme = localStorage.getItem('utc_theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            this.chartManager.updateTheme();
            this.heatmapManager.updateTheme();
            this.showNotification('SAVA≈û MODU DEVRE DI≈ûI BIRAKILDI.', 'success');
            this.speak(this.getRandomMessage('combatModeDeactivate'));
        }

        loadVoices() {
            this.voices = this.synth.getVoices();
            this.updateTTSVoiceSelectUI();
        }

        updateTTSVoiceSelectUI() {
            const selectEl = document.getElementById('modal-tts-voice-select');
            if (!selectEl) return;
            const currentVoice = this.settings.features.preferredVoiceName;
            selectEl.innerHTML = '<option value="">Otomatik Se√ß</option>';
            if (this.voices.length > 0) {
                 this.voices.forEach(voice => {
                    if (voice.lang.startsWith('tr')) {
                        const option = document.createElement('option');
                        option.value = voice.name;
                        option.textContent = `${voice.name} (${voice.lang})`;
                        if (currentVoice === voice.name) {
                            option.selected = true;
                        }
                        selectEl.appendChild(option);
                    }
                });
            }
        }
        getRandomMessage(key, replacements = {}) {
            const messages = this.speechTexts[key];
            if (!messages || messages.length === 0) {
                console.warn(`'${key}' i√ßin konu≈üma metni bulunamadƒ±.`);
                return `Varsayƒ±lan mesaj: ${key}`;
            }
            let message = messages[Math.floor(Math.random() * messages.length)];

            for (const placeholder in replacements) {
                const regex = new RegExp(`\\[${placeholder}\\]`, 'g');
                message = message.replace(regex, replacements[placeholder]);
            }
            return message;
        }

        // D√úZELTME: TTS Kuyruk Mekanizmasƒ±
        speak(text, options = {}) {
            if (!this.synth || !this.settings.features.enableTTS) return;
            this.speechQueue.push({ text, options });
            if (!this.isSpeaking) {
                this.processSpeechQueue();
            }
        }

        processSpeechQueue() {
            if (this.speechQueue.length === 0) {
                this.isSpeaking = false;
                return;
            }
            this.isSpeaking = true;
            const { text, options } = this.speechQueue.shift();
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = options.rate || 1.1; 
            utterance.pitch = options.pitch || 1.0; 
            utterance.volume = options.volume || 0.8; 
            utterance.lang = options.lang || 'tr-TR'; 

            const preferredVoice = this.voices.find(v => v.name === this.settings.features.preferredVoiceName);
            if (preferredVoice) {
                utterance.voice = preferredVoice;
            } else {
                const turkishVoice = this.voices.find(v => v.lang.startsWith('tr-'));
                if (turkishVoice) utterance.voice = turkishVoice;
            }
            
            utterance.onend = () => {
                setTimeout(() => this.processSpeechQueue(), 300); // Sesler arasƒ± kƒ±sa bir bekleme
            };
            
            utterance.onerror = (event) => {
                console.error('SpeechSynthesis Hata:', event.error);
                this.isSpeaking = false; // Hata durumunda kuyruƒüu serbest bƒ±rak
                this.processSpeechQueue(); // Bir sonraki √∂ƒüeyi dene
            };

            this.synth.speak(utterance);
        }

        openHonorModal(filter = 'all') {
            const el = document.getElementById('honor-modal-body');
            const honor = [], shame = [], banned = [];
            const minContrib = 10; 

            for (const key of this.allStrategyKeys) {
                const st = this.strategyStats[key]?.overall || {};
                const w = this.getStrategyWeight(key);
                const active = !!this.settings.activeStrategies[key];
                const isShadow = !!this.settings.statusMaps.shadowBanned[key];
                const isHard = !!this.settings.statusMaps.hardBanned[key];
                const contrib = (st.contrib || 0);
                const totalObs = (st.wins || 0) + (st.losses || 0);
                const wr = totalObs > 0 ? ((st.wins || 0) / totalObs * 100) : 0;

                const row = {
                    key, name: this.strategies[key]?.displayName || key, w, wr, contrib, status: isHard ? 'HARDBAN' : (isShadow ? 'G√ñLGE' : (active ? 'CANLI' : 'PASƒ∞F'))
                };

                if (isHard || isShadow) banned.push(row);
                if (!isShadow && !isHard) {
                    if (w >= 1.1 && totalObs >= minContrib) honor.push(row);
                    else if (w <= 0.8 && totalObs >= minContrib) shame.push(row);
                }
            }
            
            const pickRogue = shame.sort((a,b) => a.w - b.w)[0];

            const renderList = (title, arr, empty = '-') => `
                <div class="panel-title" style="margin:6px 0;">${title}</div>
                <div class="data-table-container" style="max-height:240px;">
                <table class="data-table">
                    <thead><tr><th>Strateji</th><th>w</th><th>WR%</th><th>Katkƒ±</th><th>Durum</th><th>Aksiyon</th></tr></thead>
                    <tbody>
                    ${arr.length ? arr.map(r => `
                        <tr>
                        <td>${r.name}</td><td>${r.w.toFixed(2)}</td><td>${r.wr.toFixed(0)}</td><td>${r.contrib}</td><td>${r.status}</td>
                        <td>
                            <button class="btn btn-tiny" onclick="window.app.toggleShadow('${r.key}')">${this.settings.statusMaps.shadowBanned[r.key] ? 'G√∂lgeden Al' : 'G√∂lgeye Al'}</button>
                            <button class="btn btn-tiny ${this.settings.statusMaps.hardBanned[r.key] ? 'btn-danger' : ''}" onclick="window.app.toggleHardBan('${r.key}')">${this.settings.statusMaps.hardBanned[r.key] ? 'Unban' : 'HardBan'}</button>
                        </td>
                        </tr>
                    `).join('') : `<tr><td colspan="6">${empty}</td></tr>`}
                    </tbody>
                </table></div>`;

            let html = '';
            if (filter === 'banned') {
                html += renderList('Banlƒ±lar (G√∂lge/HardBan)', banned, 'Kimse banlƒ± deƒüil.');
            } else {
                if (pickRogue) {
                    html += `<div class="notification danger" style="position:relative; margin-bottom:10px;">G√ºn√ºn ≈üerefsizi: <b>${pickRogue.name}</b> (w=${pickRogue.w.toFixed(2)})</div>`;
                    this.speak(this.getRandomMessage('rogueOfDay', { 'Strateji': pickRogue.name }));
                }
                html += renderList('≈ûerefli (g√º√ßl√ºler)', honor.sort((a,b)=>b.w-a.w));
                html += renderList('≈ûerefsizler (zayƒ±flar)', shame.sort((a,b)=>a.w-b.w));
                html += renderList('Banlƒ±lar (G√∂lge/HardBan)', banned);
            }

            el.innerHTML = html;
            document.getElementById('honor-modal-overlay').style.display = 'flex';
            this.lastHonorModalFilter = filter;
        }

        closeHonorModal() { document.getElementById('honor-modal-overlay').style.display = 'none'; }

        toggleShadow(key) {
            const cur = !!this.settings.statusMaps.shadowBanned[key];
            this.settings.statusMaps.shadowBanned[key] = !cur;
            if (cur) {
                if (!this.settings.statusMaps.hardBanned[key]) {
                    this.settings.activeStrategies[key] = true;
                }
            } else {
                this.settings.activeStrategies[key] = false;
            }
            this.updateActiveStrategies();
            this.saveSettings();
            this.openHonorModal(this.lastHonorModalFilter);
            this.showNotification(`${this.strategies[key].displayName} ${cur ? 'g√∂lgeden alƒ±ndƒ±' : 'g√∂lgeye alƒ±ndƒ±'}.`, 'info');
            this.speak(this.getRandomMessage(cur ? 'shadowRehab' : 'shadowBan', { 'Strateji': this.strategies[key].displayName }));
        }

        toggleHardBan(key) {
            const cur = !!this.settings.statusMaps.hardBanned[key];
            this.settings.statusMaps.hardBanned[key] = !cur;
            if (this.settings.statusMaps.hardBanned[key]) {
                this.settings.statusMaps.shadowBanned[key] = true;
                this.settings.activeStrategies[key] = false;
            } else {
                this.settings.statusMaps.shadowBanned[key] = false;
            }
            this.updateActiveStrategies();
            this.saveSettings();
            this.openHonorModal(this.lastHonorModalFilter);
            this.showNotification(`${this.strategies[key].displayName} ${cur ? 'hardbandan √ßƒ±karƒ±ldƒ±' : 'hardban edildi'}.`, cur ? 'success' : 'danger');
        }

        // D√úZELTME: Performans izleme fonksiyonu
        startPerformanceMonitor() {
            this.performanceMonitorInterval = setInterval(() => {
                if (performance.memory) {
                    const memUsage = (performance.memory.usedJSHeapSize / 1048576).toFixed(2);
                    this.logToJournal(`Performans: Bellek=${memUsage}MB, Sinyaller=${this.signals.length}, Bekleyenler=${this.pendingSignals.length}`);
                }
            }, 30000);
        }
    }

    // Uygulamayƒ± ba≈ülat
    window.app = new UltimateTradingCommandCenter();

    /* =================================================================
       PANTEON SISTEMI VE G√ñRSEL EFEKTLER
       ================================================================= */
    /* =================================================================
       ADVANCED VISUALIZATION TOOLS
       ================================================================= */
    class AdvancedTradingVisualizer {
        constructor(app) {
            this.app = app;
            this.isInitialized = false;
            this.heatmapEnabled = false;
            this.volumeProfileEnabled = false;
            this.liquidityHeatmapEnabled = false;
            this.orderFlowEnabled = false;
            this.marketStructureVisualization = false;
            this.optionsOverlayEnabled = false;
            this.supportResistanceLevels = [];
            this.fibonacciLevels = [];
            this.pivotPoints = [];
            this.init();
        }
        
        init() {
            if (this.isInitialized) return;
            
            // Initialize visualization components
            this.addVisualizationButtons();
            
            // Create necessary canvas layers
            this.createAdditionalCanvasLayers();
            
            // Bind events
            this.bindEvents();
            
            this.isInitialized = true;
            console.log('Advanced Trading Visualization Tools initialized');
        }
        
        createAdditionalCanvasLayers() {
            // Create order flow canvas layer
            const orderFlowCanvas = document.createElement('canvas');
            orderFlowCanvas.id = 'order-flow-canvas';
            orderFlowCanvas.style.position = 'absolute';
            orderFlowCanvas.style.top = '0';
            orderFlowCanvas.style.left = '0';
            orderFlowCanvas.style.width = '100%';
            orderFlowCanvas.style.height = '100%';
            orderFlowCanvas.style.pointerEvents = 'none';
            orderFlowCanvas.style.display = 'none';
            orderFlowCanvas.style.zIndex = '5';
            
            // Create volume profile canvas
            const volumeProfileCanvas = document.createElement('canvas');
            volumeProfileCanvas.id = 'volume-profile-canvas';
            volumeProfileCanvas.style.position = 'absolute';
            volumeProfileCanvas.style.top = '0';
            volumeProfileCanvas.style.right = '0';
            volumeProfileCanvas.style.width = '80px';
            volumeProfileCanvas.style.height = '100%';
            volumeProfileCanvas.style.pointerEvents = 'none';
            volumeProfileCanvas.style.display = 'none';
            volumeProfileCanvas.style.zIndex = '6';
            
            // Add to chart container
            const chartContainer = document.getElementById('live-chart');
            if (chartContainer) {
                chartContainer.style.position = 'relative';
                chartContainer.appendChild(orderFlowCanvas);
                chartContainer.appendChild(volumeProfileCanvas);
            }
        }
        
        addVisualizationButtons() {
            // Create visualization controls container
            const controlsContainer = document.createElement('div');
            controlsContainer.className = 'visualization-controls';
            controlsContainer.style.position = 'absolute';
            controlsContainer.style.top = '50px';
            controlsContainer.style.right = '10px';
            controlsContainer.style.display = 'flex';
            controlsContainer.style.flexDirection = 'column';
            controlsContainer.style.gap = '5px';
            controlsContainer.style.zIndex = '100';
            
            // Add buttons
            const buttons = [
                { id: 'toggle-heatmap-btn', icon: 'üî•', title: 'Toggle Heatmap' },
                { id: 'toggle-volume-profile-btn', icon: 'üìä', title: 'Toggle Volume Profile' },
                { id: 'toggle-liquidity-btn', icon: 'üíß', title: 'Toggle Liquidity Visualization' },
                { id: 'toggle-order-flow-btn', icon: 'üìà', title: 'Toggle Order Flow' },
                { id: 'toggle-market-structure-btn', icon: 'üîç', title: 'Toggle Market Structure' },
                { id: 'toggle-options-overlay-btn', icon: 'üîÑ', title: 'Toggle Options Overlay' }
            ];
            
            buttons.forEach(btn => {
                const button = document.createElement('button');
                button.id = btn.id;
                button.className = 'btn-tiny visualization-btn';
                button.innerHTML = btn.icon;
                button.title = btn.title;
                button.style.width = '28px';
                button.style.height = '28px';
                button.style.padding = '2px';
                button.style.fontSize = '14px';
                button.style.background = 'rgba(1, 4, 9, 0.7)';
                button.style.backdropFilter = 'blur(2px)';
                button.style.border = '1px solid var(--border-color)';
                button.style.borderRadius = '4px';
                button.style.color = 'var(--text-main)';
                button.style.cursor = 'pointer';
                button.style.display = 'flex';
                button.style.alignItems = 'center';
                button.style.justifyContent = 'center';
                controlsContainer.appendChild(button);
            });
            
            // Add to chart container
            const chartContainer = document.getElementById('live-chart');
            if (chartContainer) {
                chartContainer.style.position = 'relative';
                chartContainer.appendChild(controlsContainer);
            }
        }
        
        bindEvents() {
            // Bind click events to visualization buttons
            document.getElementById('toggle-heatmap-btn')?.addEventListener('click', () => this.toggleHeatmap());
            document.getElementById('toggle-volume-profile-btn')?.addEventListener('click', () => this.toggleVolumeProfile());
            document.getElementById('toggle-liquidity-btn')?.addEventListener('click', () => this.toggleLiquidityHeatmap());
            document.getElementById('toggle-order-flow-btn')?.addEventListener('click', () => this.toggleOrderFlow());
            document.getElementById('toggle-market-structure-btn')?.addEventListener('click', () => this.toggleMarketStructure());
            document.getElementById('toggle-options-overlay-btn')?.addEventListener('click', () => this.toggleOptionsOverlay());
            
            // Resize event
            window.addEventListener('resize', () => this.handleResize());
        }
        
        toggleHeatmap() {
            this.heatmapEnabled = !this.heatmapEnabled;
            document.getElementById('toggle-heatmap-btn')?.classList.toggle('active', this.heatmapEnabled);
            if (this.heatmapEnabled) {
                this.app.switchMainView('heatmap');
            } else {
                this.app.switchMainView('chart');
            }
        }
        
        toggleVolumeProfile() {
            this.volumeProfileEnabled = !this.volumeProfileEnabled;
            document.getElementById('toggle-volume-profile-btn')?.classList.toggle('active', this.volumeProfileEnabled);
            const volumeProfileCanvas = document.getElementById('volume-profile-canvas');
            if (volumeProfileCanvas) {
                volumeProfileCanvas.style.display = this.volumeProfileEnabled ? 'block' : 'none';
            }
            if (this.volumeProfileEnabled) {
                this.drawVolumeProfile();
            }
        }
        
        toggleLiquidityHeatmap() {
            this.liquidityHeatmapEnabled = !this.liquidityHeatmapEnabled;
            document.getElementById('toggle-liquidity-btn')?.classList.toggle('active', this.liquidityHeatmapEnabled);
            // Implementation of liquidity heatmap visualization
            if (this.liquidityHeatmapEnabled) {
                this.app.showNotification('Liquidity heatmap activated', 'info');
                this.analyzeLiquidity();
            }
        }
        
        toggleOrderFlow() {
            this.orderFlowEnabled = !this.orderFlowEnabled;
            document.getElementById('toggle-order-flow-btn')?.classList.toggle('active', this.orderFlowEnabled);
            const orderFlowCanvas = document.getElementById('order-flow-canvas');
            if (orderFlowCanvas) {
                orderFlowCanvas.style.display = this.orderFlowEnabled ? 'block' : 'none';
            }
            if (this.orderFlowEnabled) {
                this.drawOrderFlow();
            }
        }
        
        toggleMarketStructure() {
            this.marketStructureVisualization = !this.marketStructureVisualization;
            document.getElementById('toggle-market-structure-btn')?.classList.toggle('active', this.marketStructureVisualization);
            if (this.marketStructureVisualization) {
                this.app.showNotification('Market structure visualization activated', 'info');
                this.analyzeMarketStructure();
            } else {
                // Clear market structure markers
                if (this.app.chartManager && this.app.chartManager.chart) {
                    // Remove market structure lines
                }
            }
        }
        
        toggleOptionsOverlay() {
            this.optionsOverlayEnabled = !this.optionsOverlayEnabled;
            document.getElementById('toggle-options-overlay-btn')?.classList.toggle('active', this.optionsOverlayEnabled);
            if (this.optionsOverlayEnabled) {
                this.app.showNotification('Options data overlay activated', 'info');
                this.fetchOptionsData();
            }
        }
        
        handleResize() {
            if (this.volumeProfileEnabled) {
                this.drawVolumeProfile();
            }
            if (this.orderFlowEnabled) {
                this.drawOrderFlow();
            }
        }
        
        drawVolumeProfile() {
            const canvas = document.getElementById('volume-profile-canvas');
            if (!canvas || !this.app.candles || this.app.candles.length < 10) return;
            
            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            
            // Resize canvas to match its display size
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Get price range from visible candles
            const candles = this.app.candles;
            const minPrice = Math.min(...candles.map(c => c.low));
            const maxPrice = Math.max(...candles.map(c => c.high));
            const priceRange = maxPrice - minPrice;
            
            // Calculate volume at different price levels
            const priceLevels = 40; // Number of price levels
            const volumeByPrice = new Array(priceLevels).fill(0);
            
            candles.forEach(candle => {
                const priceRange = candle.high - candle.low;
                if (priceRange === 0) return;
                
                // Distribute volume across price range
                for (let i = 0; i < priceLevels; i++) {
                    const levelPrice = minPrice + (i / priceLevels) * (maxPrice - minPrice);
                    if (levelPrice >= candle.low && levelPrice <= candle.high) {
                        // Weight by proximity to close price
                        const weight = 1 - Math.abs(levelPrice - candle.close) / priceRange;
                        volumeByPrice[i] += candle.volume * weight;
                    }
                }
            });
            
            // Find max volume for scaling
            const maxVolume = Math.max(...volumeByPrice);
            
            // Draw volume profile
            ctx.fillStyle = 'rgba(100, 100, 255, 0.5)';
            ctx.strokeStyle = 'rgba(100, 100, 255, 0.8)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < priceLevels; i++) {
                const y = canvas.height - (i / priceLevels) * canvas.height;
                const volumeWidth = (volumeByPrice[i] / maxVolume) * canvas.width;
                
                ctx.fillRect(0, y, volumeWidth, canvas.height / priceLevels);
                ctx.strokeRect(0, y, volumeWidth, canvas.height / priceLevels);
            }
            
            // Draw POC (Point of Control) - highest volume level
            const pocIndex = volumeByPrice.indexOf(maxVolume);
            if (pocIndex >= 0) {
                const pocY = canvas.height - (pocIndex / priceLevels) * canvas.height;
                ctx.strokeStyle = 'rgba(255, 255, 0, 1)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, pocY);
                ctx.lineTo(canvas.width, pocY);
                ctx.stroke();
            }
        }
        
        drawOrderFlow() {
            const canvas = document.getElementById('order-flow-canvas');
            if (!canvas || !this.app.aggTrades || this.app.aggTrades.length < 10) return;
            
            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            
            // Resize canvas to match its display size
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Get recent trades
            const trades = this.app.aggTrades.slice(-50);
            if (trades.length === 0) return;
            
            // Draw trade flow
            let x = 50;
            const spacing = (canvas.width - 100) / trades.length;
            
            for (let i = 0; i < trades.length - 1; i++) {
                const trade = trades[i];
                const nextTrade = trades[i + 1];
                
                // Calculate y position based on price (normalized to canvas height)
                const minPrice = Math.min(...trades.map(t => t.price));
                const maxPrice = Math.max(...trades.map(t => t.price));
                const priceRange = maxPrice - minPrice;
                
                if (priceRange === 0) continue;
                
                const y1 = canvas.height - ((trade.price - minPrice) / priceRange) * (canvas.height - 40);
                const y2 = canvas.height - ((nextTrade.price - minPrice) / priceRange) * (canvas.height - 40);
                
                // Draw line connecting trades
                ctx.beginPath();
                ctx.moveTo(x, y1);
                ctx.lineTo(x + spacing, y2);
                
                // Color based on whether it's a buy or sell
                if (trade.isBuyerMaker) {
                    ctx.strokeStyle = 'rgba(220, 53, 69, 0.7)'; // Red for sells
                } else {
                    ctx.strokeStyle = 'rgba(40, 167, 69, 0.7)'; // Green for buys
                }
                
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw circle for trade point with size based on quantity
                const radius = Math.min(10, Math.max(3, Math.sqrt(trade.quantity) * 0.5));
                ctx.beginPath();
                ctx.arc(x, y1, radius, 0, Math.PI * 2);
                
                if (trade.isBuyerMaker) {
                    ctx.fillStyle = 'rgba(220, 53, 69, 0.7)'; // Red for sells
                } else {
                    ctx.fillStyle = 'rgba(40, 167, 69, 0.7)'; // Green for buys
                }
                
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                x += spacing;
            }
        }
        
        analyzeMarketStructure() {
            if (!this.app.candles || this.app.candles.length < 50) return;
            
            const candles = this.app.candles;
            
            // Find swing highs and lows
            const swingHighs = [];
            const swingLows = [];
            
            const lookback = 3; // Number of candles to look back and forward
            
            for (let i = lookback; i < candles.length - lookback; i++) {
                // Check for swing high
                let isSwingHigh = true;
                for (let j = i - lookback; j <= i + lookback; j++) {
                    if (j === i) continue;
                    if (candles[j].high >= candles[i].high) {
                        isSwingHigh = false;
                        break;
                    }
                }
                
                if (isSwingHigh) {
                    swingHighs.push({ time: candles[i].time, price: candles[i].high });
                }
                
                // Check for swing low
                let isSwingLow = true;
                for (let j = i - lookback; j <= i + lookback; j++) {
                    if (j === i) continue;
                    if (candles[j].low <= candles[i].low) {
                        isSwingLow = false;
                        break;
                    }
                }
                
                if (isSwingLow) {
                    swingLows.push({ time: candles[i].time, price: candles[i].low });
                }
            }
            
            // Draw swing points on chart
            if (this.app.chartManager && this.app.chartManager.series && this.app.chartManager.series.candles) {
                const markers = [];
                
                swingHighs.forEach(high => {
                    markers.push({
                        time: high.time / 1000,
                        position: 'aboveBar',
                        color: 'rgba(220, 53, 69, 0.7)',
                        shape: 'arrowDown',
                        text: 'H'
                    });
                });
                
                swingLows.forEach(low => {
                    markers.push({
                        time: low.time / 1000,
                        position: 'belowBar',
                        color: 'rgba(40, 167, 69, 0.7)',
                        shape: 'arrowUp',
                        text: 'L'
                    });
                });
                
                this.app.chartManager.series.candles.setMarkers(markers);
            }
        }
        
        analyzeLiquidity() {
            if (!this.app.orderBook || !this.app.orderBook.bids || !this.app.orderBook.asks) return;
            
            const { bids, asks } = this.app.orderBook;
            
            // Find liquidity clusters
            const bidClusters = this.findLiquidityClusters(bids);
            const askClusters = this.findLiquidityClusters(asks);
            
            // Add horizontal lines at major liquidity levels
            if (this.app.chartManager && this.app.chartManager.chart) {
                // Implementation depends on your charting library
                console.log('Liquidity clusters identified:', { bidClusters, askClusters });
            }
        }
        
        findLiquidityClusters(levels) {
            if (!levels || levels.length === 0) return [];
            
            // Sort levels by price
            const sortedLevels = [...levels].sort((a, b) => a[0] - b[0]);
            
            // Group nearby levels
            const clusters = [];
            let currentCluster = { price: sortedLevels[0][0], volume: sortedLevels[0][1] };
            
            for (let i = 1; i < sortedLevels.length; i++) {
                const [price, volume] = sortedLevels[i];
                const prevPrice = sortedLevels[i-1][0];
                
                // If close to previous level, add to cluster
                if (Math.abs(price - prevPrice) / prevPrice < 0.001) { // 0.1% threshold
                    currentCluster.price = (currentCluster.price * currentCluster.volume + price * volume) / 
                                          (currentCluster.volume + volume); // Volume-weighted average price
                    currentCluster.volume += volume;
                } else {
                    // Start new cluster
                    clusters.push(currentCluster);
                    currentCluster = { price, volume };
                }
            }
            
            clusters.push(currentCluster);
            
            // Sort by volume and take top clusters
            return clusters.sort((a, b) => b.volume - a.volume).slice(0, 5);
        }
        
        fetchOptionsData() {
            // Simulate options data fetch
            setTimeout(() => {
                this.app.showNotification('Options data fetched successfully', 'success');
                // Process options data
                this.processOptionsData({
                    callsOpenInterest: [/* mock data */],
                    putsOpenInterest: [/* mock data */],
                    maxPain: 45000,
                    putCallRatio: 0.85
                });
            }, 1000);
        }
        
        processOptionsData(optionsData) {
            // Add options-related indicators to chart
            console.log('Processing options data:', optionsData);
            
            // Show max pain line on chart
            if (this.app.chartManager && this.app.chartManager.chart && optionsData.maxPain) {
                // Implementation depends on your charting library
                this.app.showNotification(`Max pain level: ${optionsData.maxPain}`, 'info');
            }
        }
    }
    
    // NOT: PantheonSystem sƒ±nƒ±fƒ± artƒ±k dok√ºmanƒ±n ba≈üƒ±nda tanƒ±mlƒ±
    
    // Eski sƒ±nƒ±fƒ±n yerine bo≈ü bir sƒ±nƒ±f tanƒ±mƒ± ekliyorum, √ß√ºnk√º
    // sƒ±nƒ±f metod ve deƒüi≈ükenlerine hala bazƒ± yerlerden eri≈üim var
    class PantheonSystemLegacy {
        constructor() {
            console.log("Bu sƒ±nƒ±f artƒ±k kullanƒ±lmƒ±yor. Dok√ºmanƒ±n ba≈üƒ±ndaki PantheonSystem sƒ±nƒ±fƒ± kullanƒ±lmalƒ±.");
        }
        
        init() { }
        bindEvents() { }
        loadPowers() { }
        savePowers() { }
        increasePantheonPower() { }
        checkSpecialAbilities() { }
        triggerElciSpecialAbility() { }
        activateRevelation() { }
        activateValor() { }
        activateRestoration() { }
        activateCommunication() { }
        activateJudgment() { }
        activateAbility() { }
        startCooldown() { }
        onGodClick() { }
        getGodDisplayName() { return ""; }
        updateUI() { }
        updateAbilityStates() { }
        decayLoop() { }
        createPowerEffect() { }
        initEffects() { }
        showNotification() { }
    }
    
    // Yardƒ±mcƒ± Panteon sƒ±nƒ±fƒ±mƒ±z
    class AdvancedPantheonUtil {
        // Sƒ±nƒ±f √∂zellikleri
        static gods = {};
        static abilities = {};
        static effects = [];
        static lastDecayTime = Date.now();
        static powerDecayRate = 0.1; // Saniye ba≈üƒ±na g√º√ß azalmasƒ±
        
        constructor() {
            console.log("Yardƒ±mcƒ± Panteon sƒ±nƒ±fƒ± olu≈üturuldu");
        }
        
        static init() {
            console.log("AdvancedPantheonUtil init");
            // Gerekirse tanrƒ±larƒ± ve yetenekleri burada ba≈ülatabiliriz
            this.lastDecayTime = Date.now();
        }
        
        static bindEvents() {
            console.log("AdvancedPantheonUtil bindEvents √ßaƒürƒ±ldƒ±");
            
            // Yetenek butonlarƒ±
            if (this.abilities) {
                Object.keys(this.abilities).forEach(abilityId => {
                    const abilityEl = document.querySelector(`.ability[data-ability="${abilityId}"]`);
                    if (abilityEl) {
                        abilityEl.addEventListener('click', () => this.activateAbility(abilityId));
                    }
                });
            }
            
            // Tanrƒ± etkile≈üimleri
            if (this.gods) {
                document.querySelectorAll('.god').forEach(godEl => {
                    const godName = godEl.dataset.god;
                    if (godName && this.gods[godName]) {
                        godEl.addEventListener('click', () => this.onGodClick(godName));
                    }
                });
            }
        }
        
        static setupUI() {
            const shouldHideContent = localStorage.getItem('pantheonContentVisible') === 'false';
            if (shouldHideContent) {
                const content = document.querySelector('.pantheon-content');
                const btn = document.querySelector('.pantheon-toggle-btn');
                if (content && btn) {
                    content.style.display = 'none';
                    btn.textContent = '‚ñ≤';
                }
            }
        }
        
        static loadPowers() {
            try {
                const savedPowers = JSON.parse(localStorage.getItem('pantheonPowers') || '{}');
                Object.keys(this.gods).forEach(godName => {
                    if (savedPowers[godName] !== undefined) {
                        this.gods[godName].power = Math.min(savedPowers[godName], this.gods[godName].maxPower);
                    }
                });
                this.updateUI();
            } catch (e) {
                console.error('G√º√ß deƒüerleri y√ºklenirken hata:', e);
            }
        }
        
        static savePowers() {
            try {
                const powersToSave = {};
                Object.keys(this.gods).forEach(godName => {
                    powersToSave[godName] = this.gods[godName].power;
                });
                localStorage.setItem('pantheonPowers', JSON.stringify(powersToSave));
            } catch (e) {
                console.error('G√º√ß deƒüerleri kaydedilirken hata:', e);
            }
        }
        
        static increasePantheonPower(godName, amount = 1) {
            if (!this.gods[godName]) return;
            
            const god = this.gods[godName];
            god.power = Math.min(god.power + amount, god.maxPower);
            
            // √ñzel efektler
            this.createPowerEffect(godName);
            
            // UI g√ºncelle
            this.updateUI();
            
            // Kaydet
            this.savePowers();
            
            // √ñzel yetenekler
            this.checkSpecialAbilities(godName);
            
            return god.power;
        }
        
        static checkSpecialAbilities(godName) {
            const god = this.gods[godName];
            if (!god) return;
            
            // %100 g√º√ß √∂zel yeteneƒüi
            if (god.power >= god.maxPower) {
                this.triggerElciSpecialAbility(godName);
                god.power = 0; // G√ºc√º sƒ±fƒ±rla
                this.updateUI();
                this.savePowers();
            }
        }
        
        static triggerElciSpecialAbility(godName) {
            const abilities = {
                metatron: () => this.activateRevelation(),
                uriel: () => this.activateValor(),
                raphael: () => this.activateRestoration(),
                gabriel: () => this.activateCommunication(),
                michael: () => this.activateJudgment()
            };
            
            if (abilities[godName]) {
                abilities[godName]();
                this.showNotification(`${this.getGodDisplayName(godName)} √∂zel yeteneƒüi aktive edildi!`, 'success');
            }
        }
        
        static activateRevelation() {
            // T√ºm stratejilerin doƒüruluk oranƒ±nƒ± ge√ßici olarak artƒ±r
            this.showNotification('Vahiy: Stratejilerin doƒüruluk oranƒ± arttƒ±!', 'info');
        }
        
        static activateValor() {
            // Risk almayƒ± artƒ±ran cesaret bonusu
            this.showNotification('Cesaret: Risk limitleri artƒ±rƒ±ldƒ±!', 'info');
        }
        
        static activateRestoration() {
            // Kayƒ±plarƒ± telafi etme
            this.showNotification('≈ûifa: Kayƒ±plar telafi ediliyor...', 'info');
        }
        
        static activateCommunication() {
            // Haber ve veri akƒ±≈üƒ±nƒ± iyile≈ütir
            this.showNotification('ƒ∞leti≈üim: Veri akƒ±≈üƒ± optimize edildi!', 'info');
        }
        
        static activateJudgment() {
            // D√º≈üman pozisyonlarƒ±nƒ± ortaya √ßƒ±kar
            this.showNotification('Yargƒ±: D√º≈üman pozisyonlarƒ± tespit edildi!', 'warning');
        }
        
        static activateAbility(abilityId) {
            const ability = this.abilities[abilityId];
            if (!ability) return;
            
            const now = Date.now();
            const cooldownLeft = (ability.lastUsed + ability.cooldown) - now;
            
            if (cooldownLeft > 0) {
                this.showNotification(`Bekleyin: ${(cooldownLeft/1000).toFixed(1)} saniye kaldƒ±`, 'warning');
                return;
            }
            
            // Yeteneƒüi etkinle≈ütir
            ability.lastUsed = now;
            this.startCooldown(abilityId, ability.cooldown);
            
            // Yeteneƒüe √∂zel i≈ülemler
            switch(abilityId) {
                case 'revelation':
                    this.activateRevelation();
                    break;
                case 'valor':
                    this.activateValor();
                    break;
                case 'restoration':
                    this.activateRestoration();
                    break;
            }
        }
        
        static startCooldown(abilityId, duration) {
            const abilityEl = document.querySelector(`.ability[data-ability="${abilityId}"]`);
            if (!abilityEl) return;
            
            const cooldownEl = abilityEl.querySelector('.ability-cooldown');
            if (!cooldownEl) return;
            
            abilityEl.classList.add('on-cooldown');
            cooldownEl.style.transition = `transform ${duration}ms linear`;
            cooldownEl.style.transform = 'scaleX(0)';
            
            // Animasyon bittiƒüinde sƒ±nƒ±fƒ± kaldƒ±r
            setTimeout(() => {
                abilityEl.classList.remove('on-cooldown');
                cooldownEl.style.transition = 'none';
                cooldownEl.style.transform = 'scaleX(1)';
                // Tarayƒ±cƒ±ya stil deƒüi≈üikliƒüini i≈ülemesi i√ßin kƒ±sa bir gecikme
                setTimeout(() => {
                    cooldownEl.style.transition = '';
                }, 10);
            }, duration);
        }
        
        static onGodClick(godName) {
            // Tanrƒ±ya tƒ±klandƒ±ƒüƒ±nda √∂zel bir ≈üeyler yap
            this.showNotification(`${this.getGodDisplayName(godName)} dinleniyor...`, 'info');
        }
        
        static getGodDisplayName(godName) {
            const names = {
                metatron: 'Metatron',
                uriel: 'Uriel',
                raphael: 'Raphael',
                gabriel: 'Gabriel',
                michael: 'Michael'
            };
            return names[godName] || godName;
        }
        
        static updateUI() {
            // G√º√ß √ßubuklarƒ±nƒ± g√ºncelle
            Object.entries(this.gods).forEach(([godName, god]) => {
                const powerEl = document.querySelector(`.god[data-god="${godName}"] .god-power`);
                const progressEl = document.querySelector(`.god[data-god="${godName}"] .god-progress-fill`);
                
                if (powerEl) {
                    powerEl.textContent = `${Math.round(god.power)}%`;
                }
                
                if (progressEl) {
                    const percentage = (god.power / god.maxPower) * 100;
                    progressEl.style.width = `${percentage}%`;
                    
                    // G√º√ß seviyesine g√∂re renk yoƒüunluƒüunu ayarla
                    const opacity = 0.3 + (percentage / 100 * 0.7);
                    progressEl.style.opacity = opacity;
                }
            });
            
            // √ñzel yetenek durumlarƒ±nƒ± g√ºncelle
            this.updateAbilityStates();
        }
        
        static updateAbilityStates() {
            const now = Date.now();
            
            Object.entries(this.abilities).forEach(([abilityId, ability]) => {
                const abilityEl = document.querySelector(`.ability[data-ability="${abilityId}"]`);
                if (!abilityEl) return;
                
                const cooldownLeft = (ability.lastUsed + ability.cooldown) - now;
                const statusEl = abilityEl.querySelector('.ability-status');
                
                if (cooldownLeft > 0) {
                    // Bekleme s√ºresi devam ediyor
                    abilityEl.classList.add('on-cooldown');
                    
                    // Update status text with remaining time
                    if (statusEl) {
                        const secondsLeft = Math.ceil(cooldownLeft / 1000);
                        statusEl.textContent = `${secondsLeft}s`;
                    }
                    
                    // ƒ∞lerleme √ßubuƒüunu g√ºncelle
                    const progress = 1 - (cooldownLeft / ability.cooldown);
                    const cooldownEl = abilityEl.querySelector('.ability-cooldown');
                    if (cooldownEl) {
                        cooldownEl.style.transform = `scaleX(${progress})`;
                    }
                } else {
                    // Hazƒ±r
                    abilityEl.classList.remove('on-cooldown');
                    if (statusEl) {
                        statusEl.textContent = 'Ready';
                    }
                }
            });
        }
        
        static decayLoop() {
            const now = Date.now();
            const deltaTime = (now - this.lastDecayTime) / 1000; // Saniye cinsinden
            
            // G√º√ß azalt
            Object.values(this.gods).forEach(god => {
                const decayAmount = this.powerDecayRate * deltaTime;
                god.power = Math.max(0, god.power - decayAmount);
            });
            
            this.lastDecayTime = now;
            this.updateUI();
            this.savePowers();
            
            // Her saniye g√ºncelle
            setTimeout(() => this.decayLoop(), 1000);
        }
        
        static createPowerEffect(godName) {
            const god = this.gods[godName];
            if (!god) return;
            
            const effect = {
                type: 'power-up',
                god: godName,
                x: Math.random() * window.innerWidth,
                y: window.innerHeight,
                size: 5 + Math.random() * 10,
                alpha: 0.8,
                speed: 1 + Math.random() * 3,
                life: 100,
                update: function() {
                    this.y -= this.speed;
                    this.life--;
                    return this.life > 0;
                },
                draw: function(ctx) {
                    ctx.save();
                    ctx.globalAlpha = this.alpha * (this.life / 100);
                    ctx.fillStyle = god.color;
                    
                    // Par√ßacƒ±k efekti
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // I≈üƒ±k efekti
                    const gradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, this.size * 3
                    );
                    gradient.addColorStop(0, `${god.color}80`);
                    gradient.addColorStop(1, `${god.color}00`);
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(this.x - this.size * 3, this.y - this.size * 3, this.size * 6, this.size * 6);
                    
                    ctx.restore();
                }
            };
            
            this.effects.push(effect);
            
            // Maksimum efekt sayƒ±sƒ±nƒ± sƒ±nƒ±rla
            if (this.effects.length > 100) {
                this.effects.shift();
            }
        }
        
        static initEffects() {
            const canvas = document.getElementById('effects-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            
            // Canvas boyutunu ayarla
            const resizeCanvas = () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            };
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // Animasyon d√∂ng√ºs√º
            const animate = () => {
                // Temizle
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Efektleri g√ºncelle ve √ßiz
                this.effects = this.effects.filter(effect => {
                    const isAlive = effect.update();
                    if (isAlive) {
                        effect.draw(ctx);
                    }
                    return isAlive;
                });
                
                requestAnimationFrame(animate);
            };
            
            animate();
        }
        
        static showNotification(message, type = 'info') {
            // Mevcut bildirim sisteminizi kullanarak g√∂sterin
            console.log(`[${type.toUpperCase()}] ${message}`);
            
            // √ñrnek bildirim olu≈üturma (mevcut sisteminize g√∂re)
            if (window.app && typeof window.app.showNotification === 'function') {
                window.app.showNotification(message, type);
            } else {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                
                const container = document.getElementById('notifications-container') || document.body;
                container.appendChild(notification);
                
                // Otomatik kaldƒ±r
                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => notification.remove(), 300);
                }, 5000);
            }
        }
    }
    
    /* =================================================================
       RITUAL SYSTEM
       ================================================================= */
    class RitualManager {
        constructor(app) {
            this.app = app;
            this.rituals = [
                {
                    id: 'marketHarmony',
                    name: 'Piyasa Uyumu',
                    description: 'Piyasa akƒ±≈üƒ± ile uyumlanma rit√ºeli. Trend y√∂n√ºn√º daha net g√∂sterir ve ge√ßi≈üleri erken yakalar.',
                    effect: 'Trend analiz doƒüruluƒüu +25%, trend ge√ßi≈ü tespiti +30%',
                    duration: 15 * 60 * 1000, // 15 dakika
                    preparationTime: 60 * 1000, // 1 dakika
                    energyCost: 15,
                    type: 'trend',
                    active: false,
                    prepared: false,
                    prepProgress: 0,
                    remainingTime: 0,
                    activatedAt: null
                },
                {
                    id: 'confluenceRitual',
                    name: 'Uyum Noktasƒ± Rit√ºeli',
                    description: '√áoklu zaman dilimlerindeki fiyat uyumlarƒ±nƒ± g√∂rme yeteneƒüini artƒ±rƒ±r.',
                    effect: 'Uyum skorlarƒ± +35%, √ßoklu zaman dilimi doƒüruluƒüu +25%',
                    duration: 20 * 60 * 1000, // 20 dakika
                    preparationTime: 90 * 1000, // 1.5 dakika
                    energyCost: 20,
                    type: 'confluence',
                    active: false,
                    prepared: false,
                    prepProgress: 0,
                    remainingTime: 0,
                    activatedAt: null
                },
                {
                    id: 'liquidityVision',
                    name: 'Likidite G√∂r√º≈ü√º',
                    description: 'Piyasadaki b√ºy√ºk likidite havuzlarƒ±nƒ± ve emir duvarlarƒ±nƒ± daha net g√∂rmenizi saƒülar.',
                    effect: 'Likidite tespiti +40%, b√ºy√ºk emirlerin tespiti +30%',
                    duration: 10 * 60 * 1000, // 10 dakika
                    preparationTime: 45 * 1000, // 45 saniye
                    energyCost: 12,
                    type: 'liquidity',
                    active: false,
                    prepared: false,
                    prepProgress: 0,
                    remainingTime: 0,
                    activatedAt: null
                },
                {
                    id: 'orderFlowInsight',
                    name: 'Emir Akƒ±≈üƒ± ƒ∞√ßg√∂r√ºs√º',
                    description: 'Piyasa katƒ±lƒ±mcƒ±larƒ±nƒ±n davranƒ±≈ülarƒ±nƒ± daha iyi anlama ve emir akƒ±≈üƒ±nƒ± derinlemesine g√∂rme yeteneƒüi.',
                    effect: 'Emir akƒ±≈üƒ± analizi +30%, piyasa katƒ±lƒ±mcƒ± analizi +25%',
                    duration: 12 * 60 * 1000, // 12 dakika
                    preparationTime: 75 * 1000, // 1.25 dakika
                    energyCost: 18,
                    type: 'orderflow',
                    active: false,
                    prepared: false,
                    prepProgress: 0,
                    remainingTime: 0,
                    activatedAt: null
                },
                {
                    id: 'divineProtection',
                    name: 'ƒ∞lahi Koruma',
                    description: 'Piyasa manip√ºlasyonlarƒ±na kar≈üƒ± koruma saƒülar ve ani fiyat hareketlerinden sizi korur.',
                    effect: 'Manip√ºlasyon tespiti +40%, ani hareket korumasƒ± +35%',
                    duration: 30 * 60 * 1000, // 30 dakika
                    preparationTime: 120 * 1000, // 2 dakika
                    energyCost: 25,
                    type: 'protection',
                    active: false,
                    prepared: false,
                    prepProgress: 0,
                    remainingTime: 0,
                    activatedAt: null
                }
            ];
            
            this.selectedRitualId = null;
            this.isContainerVisible = false;
            this.prepInterval = null;
            this.ritualIntervals = {};
            
            // UI elemanlarƒ±
            this.container = document.getElementById('ritual-container');
            this.ritualList = document.getElementById('ritual-list');
            this.ritualStatus = document.getElementById('ritual-status');
            
            // G√∂r√ºn√ºrl√ºk durumunu y√ºkle
            this.loadVisibilityState();
            
            // Rit√ºelleri listele
            this.renderRituals();
            
            // Aktif rit√ºelleri kontrol et
            this.checkActiveRituals();
            
            // Event listeners
            window.addEventListener('beforeunload', () => {
                this.saveRitualStates();
            });
        }
        
        loadVisibilityState() {
            const visible = localStorage.getItem('utc_ritual_visible');
            if (visible === 'true') {
                this.toggleRitualContainer(true);
            }
            
            // Kayƒ±tlƒ± rit√ºel durumlarƒ±nƒ± y√ºkle
            const savedRituals = localStorage.getItem('utc_ritual_states');
            if (savedRituals) {
                try {
                    const ritualStates = JSON.parse(savedRituals);
                    ritualStates.forEach(state => {
                        const ritual = this.rituals.find(r => r.id === state.id);
                        if (ritual) {
                            ritual.active = state.active;
                            ritual.prepared = state.prepared;
                            ritual.prepProgress = state.prepProgress;
                            ritual.activatedAt = state.activatedAt ? new Date(state.activatedAt) : null;
                            
                            if (ritual.active && ritual.activatedAt) {
                                // Kalan s√ºreyi hesapla
                                const elapsedTime = Date.now() - ritual.activatedAt;
                                ritual.remainingTime = Math.max(0, ritual.duration - elapsedTime);
                                
                                // Eƒüer s√ºre dolmadƒ±ysa, rit√ºeli aktifle≈ütir
                                if (ritual.remainingTime > 0) {
                                    this.applyRitualEffects(ritual);
                                    this.startRitualTimer(ritual);
                                } else {
                                    ritual.active = false;
                                    ritual.activatedAt = null;
                                }
                            }
                        }
                    });
                } catch (e) {
                    console.error('Rit√ºel durumlarƒ± y√ºklenirken hata:', e);
                }
            }
        }
        
        saveRitualStates() {
            // Sadece ID, active, prepared, prepProgress ve activatedAt verilerini kaydet
            const ritualStates = this.rituals.map(ritual => ({
                id: ritual.id,
                active: ritual.active,
                prepared: ritual.prepared,
                prepProgress: ritual.prepProgress,
                activatedAt: ritual.activatedAt
            }));
            
            localStorage.setItem('utc_ritual_states', JSON.stringify(ritualStates));
        }
        
        toggleRitualContainer(show) {
            if (show === undefined) {
                this.isContainerVisible = !this.isContainerVisible;
            } else {
                this.isContainerVisible = show;
            }
            
            if (this.container) {
                this.container.classList.toggle('hidden', !this.isContainerVisible);
            }
            
            // G√∂r√ºn√ºrl√ºk durumunu kaydet
            localStorage.setItem('utc_ritual_visible', this.isContainerVisible);
        }
        
        renderRituals() {
            if (!this.ritualList) return;
            
            this.ritualList.innerHTML = '';
            
            this.rituals.forEach(ritual => {
                const ritualElement = document.createElement('div');
                ritualElement.className = `ritual-item ${ritual.active ? 'active' : ''} ${ritual.prepared ? 'prepared' : ''}`;
                ritualElement.dataset.ritualId = ritual.id;
                
                // Aktif etiketini ekle
                if (ritual.active) {
                    const activeLabel = document.createElement('span');
                    activeLabel.className = 'ritual-active-label';
                    activeLabel.textContent = 'AKTƒ∞F';
                    ritualElement.appendChild(activeLabel);
                    ritualElement.classList.add('ritual-active');
                }
                
                let durationText = this.formatTime(ritual.duration);
                if (ritual.active && ritual.remainingTime) {
                    durationText = this.formatTime(ritual.remainingTime);
                }
                
                ritualElement.innerHTML += `
                    <div class="ritual-item-header">
                        <div class="ritual-item-title">${ritual.name}</div>
                        <div class="ritual-item-duration">‚è±Ô∏è ${durationText}</div>
                    </div>
                    <div class="ritual-item-description">${ritual.description}</div>
                    <div class="ritual-item-effect">${ritual.effect}</div>
                    <div class="ritual-item-cost">Enerji: ${ritual.energyCost}%</div>
                    <div class="ritual-item-progress">
                        <div class="ritual-item-progress-bar" style="width: ${ritual.prepProgress}%"></div>
                    </div>
                `;
                
                // Tƒ±klama olayƒ± ekle
                ritualElement.addEventListener('click', () => {
                    this.selectRitual(ritual.id);
                });
                
                this.ritualList.appendChild(ritualElement);
            });
            
            // Status metnini g√ºncelle
            this.updateStatusText();
        }
        
        selectRitual(ritualId) {
            this.selectedRitualId = ritualId;
            
            // Se√ßili rit√ºeli vurgula
            const ritualItems = this.ritualList.querySelectorAll('.ritual-item');
            ritualItems.forEach(item => {
                if (item.dataset.ritualId === ritualId) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
            
            // Status metnini g√ºncelle
            this.updateStatusText();
        }
        
        updateStatusText() {
            if (!this.ritualStatus) return;
            
            const selectedRitual = this.rituals.find(r => r.id === this.selectedRitualId);
            
            if (!selectedRitual) {
                this.ritualStatus.textContent = 'Aktif rit√ºel yok. Bir rit√ºel se√ßip hazƒ±rlayƒ±n.';
                return;
            }
            
            if (selectedRitual.active) {
                const remainingText = this.formatTime(selectedRitual.remainingTime);
                this.ritualStatus.textContent = `${selectedRitual.name} aktif. Kalan s√ºre: ${remainingText}`;
            } else if (selectedRitual.prepared) {
                this.ritualStatus.textContent = `${selectedRitual.name} hazƒ±r. Aktifle≈ütirmek i√ßin tƒ±klayƒ±n.`;
            } else if (this.prepInterval && selectedRitual.prepProgress > 0) {
                this.ritualStatus.textContent = `${selectedRitual.name} hazƒ±rlanƒ±yor... (${Math.round(selectedRitual.prepProgress)}%)`;
            } else {
                this.ritualStatus.textContent = `${selectedRitual.name} se√ßildi. Hazƒ±rlamak i√ßin tƒ±klayƒ±n.`;
            }
        }
        
        prepareSelectedRitual() {
            if (!this.selectedRitualId) {
                this.app.showNotification('L√ºtfen √∂nce bir rit√ºel se√ßin!', 'warning');
                return;
            }
            
            const ritual = this.rituals.find(r => r.id === this.selectedRitualId);
            
            if (!ritual) return;
            
            // Zaten hazƒ±rlanmƒ±≈üsa veya aktifse
            if (ritual.prepared) {
                this.app.showNotification(`${ritual.name} zaten hazƒ±r!`, 'info');
                return;
            }
            
            if (ritual.active) {
                this.app.showNotification(`${ritual.name} zaten aktif!`, 'info');
                return;
            }
            
            // Enerji kontrol√º
            if (!this.app.energyManager || this.app.energyManager.currentEnergy < ritual.energyCost) {
                this.app.showNotification(`Yeterli enerji yok! ${ritual.energyCost}% enerji gerekiyor.`, 'danger');
                if (this.app.speak) {
                    this.app.speak(`Rit√ºeli hazƒ±rlamak i√ßin yeterli enerji yok. ${ritual.energyCost} birim enerji gerekiyor.`);
                }
                return;
            }
            
            // Hazƒ±rlanmaya ba≈üla
            ritual.prepProgress = 0;
            
            // Sesli bildirim
            if (this.app.speak) {
                this.app.speak(`${ritual.name} rit√ºeli hazƒ±rlanƒ±yor. L√ºtfen bekleyin.`);
            }
            
            this.app.showNotification(`${ritual.name} rit√ºeli hazƒ±rlanmaya ba≈üladƒ±...`, 'info');
            
            // Enerji t√ºketimi
            this.app.energyManager.useEnergy(ritual.energyCost / 2); // Yarƒ±sƒ±nƒ± ≈üimdi kullan
            
            // Hazƒ±rlanma zamanlayƒ±cƒ±sƒ±
            if (this.prepInterval) {
                clearInterval(this.prepInterval);
            }
            
            const updateInterval = 100; // 100ms'de bir g√ºncelle
            const progressStep = (updateInterval / ritual.preparationTime) * 100;
            
            this.prepInterval = setInterval(() => {
                ritual.prepProgress += progressStep;
                
                // ƒ∞lerlemeyi UI'da g√ºncelle
                const progressBar = this.ritualList.querySelector(`[data-ritual-id="${ritual.id}"] .ritual-item-progress-bar`);
                if (progressBar) {
                    progressBar.style.width = `${ritual.prepProgress}%`;
                }
                
                this.updateStatusText();
                
                // Hazƒ±rlƒ±k tamamlandƒ± mƒ±?
                if (ritual.prepProgress >= 100) {
                    ritual.prepProgress = 100;
                    ritual.prepared = true;
                    clearInterval(this.prepInterval);
                    this.prepInterval = null;
                    
                    // Diƒüer yarƒ± enerjiyi kullan
                    this.app.energyManager.useEnergy(ritual.energyCost / 2);
                    
                    this.app.showNotification(`${ritual.name} rit√ºeli hazƒ±rlandƒ±! Aktifle≈ütirmek i√ßin tƒ±klayƒ±n.`, 'success');
                    
                    if (this.app.speak) {
                        this.app.speak(`${ritual.name} rit√ºeli hazƒ±r. Aktifle≈ütirmek i√ßin rit√ºel aktifle≈ütir butonuna tƒ±klayƒ±n.`);
                    }
                    
                    // Rit√ºel listesini yenile
                    this.renderRituals();
                }
            }, updateInterval);
        }
        
        activateSelectedRitual() {
            if (!this.selectedRitualId) {
                this.app.showNotification('L√ºtfen √∂nce bir rit√ºel se√ßin!', 'warning');
                return;
            }
            
            const ritual = this.rituals.find(r => r.id === this.selectedRitualId);
            
            if (!ritual) return;
            
            // Aktifse zaten
            if (ritual.active) {
                this.app.showNotification(`${ritual.name} zaten aktif!`, 'info');
                return;
            }
            
            // Hazƒ±r deƒüilse
            if (!ritual.prepared) {
                this.app.showNotification(`${ritual.name} hen√ºz hazƒ±r deƒüil! √ñnce hazƒ±rlayƒ±n.`, 'warning');
                return;
            }
            
            // Rit√ºeli aktifle≈ütir
            ritual.active = true;
            ritual.prepared = false; // Hazƒ±rlƒ±k durumunu sƒ±fƒ±rla
            ritual.activatedAt = new Date();
            ritual.remainingTime = ritual.duration;
            
            // Rit√ºel efektlerini uygula
            this.applyRitualEffects(ritual);
            
            // Zamanlayƒ±cƒ±yƒ± ba≈ülat
            this.startRitualTimer(ritual);
            
            // Sesli bildirim
            if (this.app.speak) {
                this.app.speak(`${ritual.name} rit√ºeli aktifle≈ütirildi. T√ºm gizli g√º√ßler artƒ±k emrinde. S√ºre: ${this.formatTime(ritual.duration)}.`);
            }
            
            // Bildirim
            this.app.showNotification(`${ritual.name} rit√ºeli aktifle≈ütirildi! S√ºre: ${this.formatTime(ritual.duration)}.`, 'success');
            
            // G√∂rsel efekt
            const ritualElement = this.ritualList.querySelector(`[data-ritual-id="${ritual.id}"]`);
            if (ritualElement) {
                ritualElement.classList.add('ritual-activate-effect');
                setTimeout(() => {
                    ritualElement.classList.remove('ritual-activate-effect');
                }, 500);
            }
            
            // Rit√ºel listesini yenile
            this.renderRituals();
            
            // Rit√ºel durumlarƒ±nƒ± kaydet
            this.saveRitualStates();
        }
        
        startRitualTimer(ritual) {
            // √ñnceki zamanlayƒ±cƒ±yƒ± temizle
            if (this.ritualIntervals[ritual.id]) {
                clearInterval(this.ritualIntervals[ritual.id]);
            }
            
            const updateInterval = 1000; // 1 saniyede bir g√ºncelle
            
            this.ritualIntervals[ritual.id] = setInterval(() => {
                ritual.remainingTime -= updateInterval;
                
                // ƒ∞lerlemeyi UI'da g√ºncelle
                this.updateStatusText();
                
                // S√ºre doldu mu?
                if (ritual.remainingTime <= 0) {
                    ritual.active = false;
                    ritual.activatedAt = null;
                    clearInterval(this.ritualIntervals[ritual.id]);
                    delete this.ritualIntervals[ritual.id];
                    
                    // Efektleri kaldƒ±r
                    this.removeRitualEffects(ritual);
                    
                    this.app.showNotification(`${ritual.name} rit√ºeli sona erdi.`, 'info');
                    
                    if (this.app.speak) {
                        this.app.speak(`${ritual.name} rit√ºeli sona erdi. Gizli g√º√ßler artƒ±k eri≈üilebilir deƒüil.`);
                    }
                    
                    // Rit√ºel listesini yenile
                    this.renderRituals();
                    
                    // Rit√ºel durumlarƒ±nƒ± kaydet
                    this.saveRitualStates();
                }
                
                // Her 10 saniyede bir rit√ºel durumlarƒ±nƒ± kaydet
                if (ritual.remainingTime % 10000 === 0) {
                    this.saveRitualStates();
                }
            }, updateInterval);
        }
        
        applyRitualEffects(ritual) {
            if (!this.app) return;
            
            switch (ritual.type) {
                case 'trend':
                    // Trend analiz hassasiyetini artƒ±r
                    if (this.app.marketStructureAnalyzer) {
                        this.app._originalMarketStructureThreshold = this.app.marketStructureAnalyzer.trendThreshold || 0.5;
                        this.app.marketStructureAnalyzer.trendThreshold = this.app._originalMarketStructureThreshold * 0.75;
                    }
                    // Trend g√∂rselle≈ütirmesini geli≈ütir
                    if (this.app.chartManager) {
                        this.app.chartManager.trendVisualizationEnhanced = true;
                    }
                    break;
                
                case 'confluence':
                    // Uyum skorlarƒ±nƒ± artƒ±r
                    if (this.app.confluenceEngine) {
                        this.app._originalConfluenceMultiplier = this.app.confluenceEngine.confluenceMultiplier || 1.0;
                        this.app.confluenceEngine.confluenceMultiplier = this.app._originalConfluenceMultiplier * 1.35;
                    }
                    // √áoklu zaman dilimi doƒüruluƒüunu artƒ±r
                    if (this.app.multiTimeframeManager) {
                        this.app._originalMtfAccuracyFactor = this.app.multiTimeframeManager.accuracyFactor || 1.0;
                        this.app.multiTimeframeManager.accuracyFactor = this.app._originalMtfAccuracyFactor * 1.25;
                    }
                    break;
                
                case 'liquidity':
                    // Likidite tespitini geli≈ütir
                    if (this.app.heatmapManager) {
                        this.app._originalLiquiditySensitivity = this.app.heatmapManager.liquiditySensitivity || 1.0;
                        this.app.heatmapManager.liquiditySensitivity = this.app._originalLiquiditySensitivity * 1.4;
                    }
                    // Emir duvarƒ± tespitini geli≈ütir
                    if (this.app.spoofDetector) {
                        this.app._originalSpoofThreshold = this.app.spoofDetector.threshold || 20;
                        this.app.spoofDetector.threshold = this.app._originalSpoofThreshold * 0.7;
                    }
                    break;
                
                case 'orderflow':
                    // Emir akƒ±≈üƒ± analizini geli≈ütir
                    this.app._originalOrderFlowSensitivity = this.app.settings?.orderFlowSensitivity || 1.0;
                    if (this.app.settings) {
                        this.app.settings.orderFlowSensitivity = this.app._originalOrderFlowSensitivity * 1.3;
                    }
                    // Piyasa katƒ±lƒ±mcƒ± analizini geli≈ütir
                    this.app._originalParticipantDetection = this.app.settings?.participantDetection || 1.0;
                    if (this.app.settings) {
                        this.app.settings.participantDetection = this.app._originalParticipantDetection * 1.25;
                    }
                    break;
                
                case 'protection':
                    // Manip√ºlasyon tespitini geli≈ütir
                    if (this.app.manipulationDetector) {
                        this.app._originalManipulationThreshold = this.app.manipulationDetector.threshold || 0.5;
                        this.app.manipulationDetector.threshold = this.app._originalManipulationThreshold * 0.6;
                    }
                    // Risk koruma fakt√∂r√ºn√º geli≈ütir
                    this.app._originalRiskFactor = this.app.settings?.riskFactor || 1.0;
                    if (this.app.settings) {
                        this.app.settings.riskFactor = this.app._originalRiskFactor * 1.35;
                    }
                    break;
            }
            
            // Rit√ºel aktif edildiƒüini bildir
            this.app.emit('ritualActivated', {
                ritualId: ritual.id,
                ritualName: ritual.name,
                ritualType: ritual.type,
                duration: ritual.duration
            });
            
            // Aktif g√∂rsel efekt
            const chartElement = document.getElementById('live-chart');
            if (chartElement) {
                chartElement.classList.add(`ritual-effect-${ritual.type}`);
            }
        }
        
        removeRitualEffects(ritual) {
            if (!this.app) return;
            
            switch (ritual.type) {
                case 'trend':
                    if (this.app.marketStructureAnalyzer && this.app._originalMarketStructureThreshold !== undefined) {
                        this.app.marketStructureAnalyzer.trendThreshold = this.app._originalMarketStructureThreshold;
                    }
                    if (this.app.chartManager) {
                        this.app.chartManager.trendVisualizationEnhanced = false;
                    }
                    break;
                
                case 'confluence':
                    if (this.app.confluenceEngine && this.app._originalConfluenceMultiplier !== undefined) {
                        this.app.confluenceEngine.confluenceMultiplier = this.app._originalConfluenceMultiplier;
                    }
                    if (this.app.multiTimeframeManager && this.app._originalMtfAccuracyFactor !== undefined) {
                        this.app.multiTimeframeManager.accuracyFactor = this.app._originalMtfAccuracyFactor;
                    }
                    break;
                
                case 'liquidity':
                    if (this.app.heatmapManager && this.app._originalLiquiditySensitivity !== undefined) {
                        this.app.heatmapManager.liquiditySensitivity = this.app._originalLiquiditySensitivity;
                    }
                    if (this.app.spoofDetector && this.app._originalSpoofThreshold !== undefined) {
                        this.app.spoofDetector.threshold = this.app._originalSpoofThreshold;
                    }
                    break;
                
                case 'orderflow':
                    if (this.app.settings && this.app._originalOrderFlowSensitivity !== undefined) {
                        this.app.settings.orderFlowSensitivity = this.app._originalOrderFlowSensitivity;
                    }
                    if (this.app.settings && this.app._originalParticipantDetection !== undefined) {
                        this.app.settings.participantDetection = this.app._originalParticipantDetection;
                    }
                    break;
                
                case 'protection':
                    if (this.app.manipulationDetector && this.app._originalManipulationThreshold !== undefined) {
                        this.app.manipulationDetector.threshold = this.app._originalManipulationThreshold;
                    }
                    if (this.app.settings && this.app._originalRiskFactor !== undefined) {
                        this.app.settings.riskFactor = this.app._originalRiskFactor;
                    }
                    break;
            }
            
            // Rit√ºel sonlandƒ±ƒüƒ±nƒ± bildir
            this.app.emit('ritualDeactivated', {
                ritualId: ritual.id,
                ritualName: ritual.name,
                ritualType: ritual.type
            });
            
            // G√∂rsel efekti kaldƒ±r
            const chartElement = document.getElementById('live-chart');
            if (chartElement) {
                chartElement.classList.remove(`ritual-effect-${ritual.type}`);
            }
        }
        
        checkActiveRituals() {
            // Aktif rit√ºelleri kontrol et ve gerekirse zamanlayƒ±cƒ±yƒ± yeniden ba≈ülat
            this.rituals.forEach(ritual => {
                if (ritual.active && ritual.activatedAt) {
                    const elapsedTime = Date.now() - ritual.activatedAt;
                    ritual.remainingTime = Math.max(0, ritual.duration - elapsedTime);
                    
                    if (ritual.remainingTime > 0) {
                        this.applyRitualEffects(ritual);
                        this.startRitualTimer(ritual);
                    } else {
                        ritual.active = false;
                        ritual.activatedAt = null;
                    }
                }
            });
        }
        
        formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
        
        getActiveRituals() {
            return this.rituals.filter(r => r.active);
        }
    }
    
    /* =================================================================
       ENERGY MANAGEMENT SYSTEM
       ================================================================= */
    class EnergyManager {
        constructor(app) {
            this.app = app;
            this.currentEnergy = 80; // Ba≈ülangƒ±√ß deƒüeri %80
            this.maxEnergy = 100;
            this.minEnergy = 10;
            this.decayRate = 0.05; // Saniyede %0.05 azalma
            this.lastUpdateTime = Date.now();
            this.isVisible = true;
            this.criticalThreshold = 20; // %20'nin altƒ± kritik seviye
            
            // Enerji optimizasyonu i√ßin sƒ±caklƒ±k deƒüeri
            this.systemHeat = 0; // 0-100 arasƒ±
            this.coolingRate = 0.1; // Saniyede %0.1 soƒüuma
            
            // UI elemanlarƒ±
            this.energyBox = document.getElementById('energy-box');
            this.energyFill = document.getElementById('energy-fill');
            this.energyLevel = document.getElementById('energy-level');
            this.energyTime = document.getElementById('energy-time');
            this.energyStatus = document.getElementById('energy-status');
            
            // Event'larƒ± baƒüla
            this.bindEvents();
            
            // Zamanlayƒ±cƒ±yƒ± ba≈ülat
            this.startTimer();
            
            // Sayfanƒ±n y√ºklenmesinde g√∂r√ºn√ºrl√ºƒü√º kontrol et
            this.loadVisibilityState();
        }
        
        bindEvents() {
            // Event binding i≈ülemleri
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    // Sayfa arka planda, enerji t√ºketimini azalt
                    this.decayRate = 0.02;
                } else {
                    // Sayfa aktif, enerji t√ºketimini normale d√∂nd√ºr
                    this.decayRate = 0.05;
                    this.updateUI(); // UI'ƒ± g√ºncelle
                }
            });
            
            // Sistemdeki olaylarƒ±n enerji √ºzerindeki etkilerini izle
            if (this.app) {
                // Sinyal olu≈ütuƒüunda
                this.app.on('signal', () => {
                    this.useEnergy(5); // Sinyal olu≈üturma %5 enerji t√ºketir
                });
                
                // Analiz yapƒ±ldƒ±ƒüƒ±nda
                this.app.on('analysis', () => {
                    this.useEnergy(2); // Analiz %2 enerji t√ºketir
                });
                
                // Sava≈ü modu aktifle≈ütiƒüinde
                this.app.on('combatMode', (isActive) => {
                    if (isActive) {
                        this.decayRate = 0.1; // Sava≈ü modunda enerji 2 kat hƒ±zlƒ± t√ºkenir
                    } else {
                        this.decayRate = 0.05; // Normal moda d√∂n√ºnce eski hƒ±zƒ±na d√∂ner
                    }
                });
            }
        }
        
        startTimer() {
            // Her saniye enerjiyi g√ºncelle
            setInterval(() => {
                this.updateEnergy();
            }, 1000);
        }
        
        updateEnergy() {
            const now = Date.now();
            const deltaTime = (now - this.lastUpdateTime) / 1000; // Saniye cinsinden ge√ßen s√ºre
            this.lastUpdateTime = now;
            
            // Enerjiyi azalt
            const decayAmount = this.decayRate * deltaTime;
            this.currentEnergy = Math.max(this.minEnergy, this.currentEnergy - decayAmount);
            
            // Sistem ƒ±sƒ±sƒ±nƒ± soƒüut
            this.systemHeat = Math.max(0, this.systemHeat - this.coolingRate * deltaTime);
            
            // UI'ƒ± g√ºncelle
            this.updateUI();
            
            // Kritik enerji seviyesi kontrol√º
            this.checkCriticalEnergy();
            
            // Enerji deƒüerini kaydet
            localStorage.setItem('utc_energy_level', this.currentEnergy);
        }
        
        updateUI() {
            if (!this.energyFill || !this.energyLevel || !this.energyTime || !this.energyStatus) return;
            
            // Enerji √ßubuƒüunu g√ºncelle
            this.energyFill.style.width = `${this.currentEnergy}%`;
            this.energyLevel.textContent = `${Math.round(this.currentEnergy)}%`;
            
            // Saat bilgisini g√ºncelle
            const now = new Date();
            this.energyTime.textContent = now.toLocaleTimeString();
            
            // Durum metnini g√ºncelle
            this.updateStatusText();
            
            // D√º≈ü√ºk enerji g√∂rsel uyarƒ±sƒ±
            if (this.currentEnergy < this.criticalThreshold) {
                this.energyBox.classList.add('energy-low');
            } else {
                this.energyBox.classList.remove('energy-low');
            }
        }
        
        updateStatusText() {
            if (!this.energyStatus) return;
            
            if (this.currentEnergy < this.criticalThreshold) {
                this.energyStatus.textContent = 'KRƒ∞Tƒ∞K: Enerji seviyesi d√º≈ü√ºk!';
            } else if (this.currentEnergy < 50) {
                this.energyStatus.textContent = 'Enerji seviyesi azalƒ±yor';
            } else if (this.systemHeat > 70) {
                this.energyStatus.textContent = 'Sistem sƒ±caklƒ±ƒüƒ± y√ºksek';
            } else {
                this.energyStatus.textContent = 'Normal i≈üleyi≈ü s√ºr√ºyor';
            }
        }
        
        checkCriticalEnergy() {
            // Enerji kritik seviyenin altƒ±na d√º≈üt√ºƒü√ºnde uyarƒ± ver ve i≈ülemleri optimize et
            if (this.currentEnergy < this.criticalThreshold && !this._warnedAboutEnergy) {
                this._warnedAboutEnergy = true;
                this.app.showNotification('KRƒ∞Tƒ∞K ENERJƒ∞ SEVƒ∞YESƒ∞! Sistem performansƒ± d√º≈ü√ºr√ºl√ºyor.', 'danger');
                
                // TTS ile uyarƒ±
                if (this.app && this.app.speak) {
                    this.app.speak('Dikkat! Kritik enerji seviyesi. Sistem performansƒ± d√º≈ü√ºr√ºl√ºyor. L√ºtfen enerji seviyesini optimize edin.');
                }
                
                // Performansƒ± d√º≈ü√ºr ve enerji tasarruf moduna ge√ß
                if (this.app) {
                    // Analiz aralƒ±ƒüƒ±nƒ± uzat
                    if (this.app.analysisInterval) {
                        clearInterval(this.app.analysisInterval);
                        this.app.analysisInterval = setInterval(() => this.app.runPeriodicAnalysis(), 10000); // 5s yerine 10s
                    }
                    
                    // Render aralƒ±ƒüƒ±nƒ± uzat
                    if (this.app.renderInterval) {
                        clearInterval(this.app.renderInterval);
                        this.app.renderInterval = setInterval(() => this.app.render(), 500); // 250ms yerine 500ms
                    }
                }
            } else if (this.currentEnergy >= 30 && this._warnedAboutEnergy) {
                this._warnedAboutEnergy = false;
                
                // Enerji normal seviyeye d√∂nd√º, performansƒ± normale getir
                if (this.app) {
                    // Analiz aralƒ±ƒüƒ±nƒ± normale getir
                    if (this.app.analysisInterval) {
                        clearInterval(this.app.analysisInterval);
                        this.app.analysisInterval = setInterval(() => this.app.runPeriodicAnalysis(), 5000);
                    }
                    
                    // Render aralƒ±ƒüƒ±nƒ± normale getir
                    if (this.app.renderInterval) {
                        clearInterval(this.app.renderInterval);
                        this.app.renderInterval = setInterval(() => this.app.render(), 250);
                    }
                }
            }
        }
        
        useEnergy(amount) {
            this.currentEnergy = Math.max(this.minEnergy, this.currentEnergy - amount);
            this.systemHeat = Math.min(100, this.systemHeat + amount * 1.5);
            this.updateUI();
        }
        
        addEnergy(amount) {
            this.currentEnergy = Math.min(this.maxEnergy, this.currentEnergy + amount);
            this.updateUI();
        }
        
        boostEnergy() {
            // Enerjiyi %15 artƒ±r ancak sistem ƒ±sƒ±sƒ±nƒ± %10 artƒ±r (yan etki)
            this.addEnergy(15);
            this.systemHeat = Math.min(100, this.systemHeat + 10);
            this.updateStatusText();
            
            this.app.showNotification('Sistem enerjisi g√º√ßlendirildi! Sistem ƒ±sƒ±sƒ± arttƒ±.', 'success');
            if (this.app && this.app.speak) {
                this.app.speak('Sistem enerjisi g√º√ßlendirildi. Performans artƒ±≈üƒ± saƒülandƒ±. Sistem ƒ±sƒ±sƒ± y√ºkseliyor.');
            }
        }
        
        optimizeEnergy() {
            // Sistem ƒ±sƒ±sƒ±nƒ± %20 d√º≈ü√ºr ve enerji t√ºketim oranƒ±nƒ± %20 azalt
            this.systemHeat = Math.max(0, this.systemHeat - 20);
            const originalDecayRate = this.decayRate;
            this.decayRate *= 0.8; // %20 daha az enerji t√ºketimi
            
            // 30 saniye sonra normal deƒüere d√∂n
            setTimeout(() => {
                this.decayRate = originalDecayRate;
            }, 30000);
            
            this.app.showNotification('Sistem enerjisi optimize edildi. T√ºketim 30 saniyeliƒüine azaltƒ±ldƒ±.', 'info');
            if (this.app && this.app.speak) {
                this.app.speak('Enerji optimizasyonu ba≈üarƒ±lƒ±. Sistem ƒ±sƒ±sƒ± d√º≈ü√ºr√ºld√º ve enerji t√ºketimi ge√ßici olarak azaltƒ±ldƒ±.');
            }
        }
        
        recycleEnergy() {
            // Kullanƒ±lmayan i≈ülemleri temizle ve o enerjiyi geri kazan
            let recycledAmount = 5;
            
            // Eski sinyalleri temizle
            if (this.app && this.app.signals && this.app.signals.length > 50) {
                // 50'den fazla sinyal varsa, en eski 10 tanesini temizle
                this.app.signals = this.app.signals.slice(-50);
                recycledAmount += 5;
            }
            
            // Kullanƒ±lmayan √∂nerileri temizle
            if (this.app && this.app.confluenceEngine && this.app.confluenceEngine.proposals) {
                const oldLength = this.app.confluenceEngine.proposals.length;
                // 5 dakikadan eski √∂nerileri temizle
                const fiveMinutesAgo = Date.now() - 5 * 60 * 1000;
                this.app.confluenceEngine.proposals = this.app.confluenceEngine.proposals.filter(p => p.timestamp > fiveMinutesAgo);
                
                const removedCount = oldLength - this.app.confluenceEngine.proposals.length;
                recycledAmount += removedCount;
            }
            
            // Bellekteki b√ºy√ºk verileri temizle (olmayan seriler gibi)
            if (window.gc) { // JavaScript'in garbage collector'ƒ± varsa √ßaƒüƒ±r (√ßoƒüu tarayƒ±cƒ±da yok)
                try {
                    window.gc();
                    recycledAmount += 3;
                } catch (e) {}
            }
            
            this.addEnergy(recycledAmount);
            this.app.showNotification(`Enerji geri d√∂n√º≈ü√ºm√º tamamlandƒ±. ${recycledAmount}% enerji kazanƒ±ldƒ±.`, 'success');
            if (this.app && this.app.speak) {
                this.app.speak(`Enerji geri d√∂n√º≈ü√ºm√º ba≈üarƒ±lƒ±. Kullanƒ±lmayan kaynaklar temizlendi ve y√ºzde ${recycledAmount} enerji geri kazanƒ±ldƒ±.`);
            }
        }
        
        toggleEnergyBox(show) {
            if (show === undefined) {
                this.isVisible = !this.isVisible;
            } else {
                this.isVisible = show;
            }
            
            if (this.energyBox) {
                this.energyBox.style.display = this.isVisible ? 'block' : 'none';
            }
            
            // G√∂r√ºn√ºrl√ºk durumunu kaydet
            localStorage.setItem('utc_energy_box_visible', this.isVisible);
        }
        
        loadVisibilityState() {
            const savedEnergy = parseFloat(localStorage.getItem('utc_energy_level'));
            if (!isNaN(savedEnergy)) {
                this.currentEnergy = savedEnergy;
            }
            
            const visible = localStorage.getItem('utc_energy_box_visible');
            if (visible === 'false') {
                this.toggleEnergyBox(false);
            }
            
            this.updateUI();
        }
    }
    
    /* =================================================================
       MARKET MANIPULATION DETECTION
       ================================================================= */
    class MarketManipulationDetector {
        constructor(app) {
            this.app = app;
            this.thresholds = {
                volumeSpike: 3.0,   // Normal hacmin 3 katƒ±
                priceJump: 0.025,   // %2.5'luk ani fiyat deƒüi≈üimi
                orderBookImbalance: 0.7  // %70 tek y√∂nde dengesizlik
            };
            this.detectionWindow = 10;  // Son 10 mum
            this.lastAlert = 0;
            this.alertCooldown = 300000;  // 5 dakika
        }
        
        // Hacim anomalilerini tespit et
        detectVolumeAnomalies(candles) {
            if (candles.length < 30) return false;
            
            // Son 20 mumu analiz et
            const recentCandles = candles.slice(-30);
            const volumes = recentCandles.map(c => c.volume);
            
            // Ortalama ve standart sapma hesapla (son 30 mumdan)
            const avgVolume = volumes.reduce((sum, vol) => sum + vol, 0) / volumes.length;
            const stdDev = Math.sqrt(volumes.reduce((sum, vol) => sum + Math.pow(vol - avgVolume, 2), 0) / volumes.length);
            
            // Son 3 mum i√ßin kontrol et
            const latestVolumes = volumes.slice(-3);
            
            for (const volume of latestVolumes) {
                // Z-skoru hesapla
                const zScore = (volume - avgVolume) / stdDev;
                
                if (zScore > this.thresholds.volumeSpike) {
                    return {
                        type: 'volumeSpike',
                        value: volume,
                        avg: avgVolume,
                        zScore: zScore
                    };
                }
            }
            
            return false;
        }
        
        // Ani fiyat hareketlerini tespit et
        detectPriceJumps(candles) {
            if (candles.length < 10) return false;
            
            const recentCandles = candles.slice(-10);
            
            for (let i = 1; i < recentCandles.length; i++) {
                const prevClose = recentCandles[i-1].close;
                const currentClose = recentCandles[i].close;
                
                const priceChange = Math.abs((currentClose - prevClose) / prevClose);
                
                if (priceChange > this.thresholds.priceJump) {
                    return {
                        type: 'priceJump',
                        from: prevClose,
                        to: currentClose,
                        change: priceChange
                    };
                }
            }
            
            return false;
        }
        
        // Emir defteri dengesizliƒüini tespit et (bakiyelerinizi kullanarak)
        detectOrderBookImbalance() {
            if (!this.app || !this.app.marketData || !this.app.marketData.orderBook) return false;
            
            const orderBook = this.app.marketData.orderBook;
            
            // Toplam alƒ±m ve satƒ±m miktarƒ±nƒ± hesapla
            const totalBids = orderBook.bids.reduce((sum, [price, amount]) => sum + amount, 0);
            const totalAsks = orderBook.asks.reduce((sum, [price, amount]) => sum + amount, 0);
            
            // Oran hesapla
            const totalOrders = totalBids + totalAsks;
            if (totalOrders === 0) return false;
            
            const bidRatio = totalBids / totalOrders;
            const askRatio = totalAsks / totalOrders;
            
            // Dengesizliƒüi kontrol et
            if (bidRatio > this.thresholds.orderBookImbalance) {
                return {
                    type: 'buyImbalance',
                    ratio: bidRatio
                };
            } else if (askRatio > this.thresholds.orderBookImbalance) {
                return {
                    type: 'sellImbalance',
                    ratio: askRatio
                };
            }
            
            return false;
        }
        
        // Ana algƒ±lama metodu
        detect() {
            if (!this.app || !this.app.candles) return false;
            
            const now = Date.now();
            if (now - this.lastAlert < this.alertCooldown) return false;  // √áok sƒ±k uyarƒ± verme
            
            // Hacim anomalilerini kontrol et
            const volumeAnomaly = this.detectVolumeAnomalies(this.app.candles);
            
            // Ani fiyat hareketlerini kontrol et
            const priceJump = this.detectPriceJumps(this.app.candles);
            
            // Emir defteri dengesizliƒüini kontrol et
            const orderBookImbalance = this.detectOrderBookImbalance();
            
            // Herhangi bir manip√ºlasyon tespit edildi mi?
            if (volumeAnomaly || priceJump || orderBookImbalance) {
                this.lastAlert = now;
                
                let alertType = '';
                let alertMessage = '';
                
                if (volumeAnomaly) {
                    alertType = 'volumeSpike';
                    alertMessage = `Anormal i≈ülem hacmi tespit edildi! Normal hacmin ${volumeAnomaly.zScore.toFixed(1)} katƒ±.`;
                } else if (priceJump) {
                    alertType = 'priceJump';
                    alertMessage = `Ani fiyat hareketi tespit edildi! ${(priceJump.change * 100).toFixed(2)}% deƒüi≈üim.`;
                } else if (orderBookImbalance) {
                    alertType = orderBookImbalance.type;
                    alertMessage = `Emir defteri dengesizliƒüi tespit edildi! ${(orderBookImbalance.ratio * 100).toFixed(0)}% ${orderBookImbalance.type === 'buyImbalance' ? 'alƒ±m' : 'satƒ±m'} hakimiyeti.`;
                }
                
                return {
                    type: alertType,
                    message: alertMessage,
                    timestamp: now
                };
            }
            
            return false;
        }
    }
    
    /* =================================================================
       ENHANCED RISK MANAGEMENT SYSTEM
       ================================================================= */
    class EnhancedRiskManagement {
        constructor(app) {
            this.app = app;
            this.maxDrawdown = 0;
            this.historicalVolatility = 0;
            this.valueAtRisk = 0;
            this.riskAnalysisEnabled = false;
            this.dynamicPositionSizing = true;
            this.correlationMatrix = {};
            this.optimalLeverage = 1.0;
            this.volatilityThresholds = {
                low: 0.5,
                medium: 1.0,
                high: 2.0,
                extreme: 3.0
            };
            this.riskMetrics = {
                sharpeRatio: 0,
                sortinoRatio: 0,
                calmarRatio: 0,
                maxDrawdown: 0,
                winRate: 0,
                profitFactor: 0
            };
            
            this.init();
        }
        
        init() {
            this.calculateHistoricalMetrics();
            this.scheduleRiskUpdates();
            this.bindControls();
            
            console.log('Enhanced Risk Management System initialized');
        }
        
        bindControls() {
            // Add risk controls to settings panel
            const settingsContainer = document.getElementById('modal-features');
            
            if (settingsContainer) {
                const riskControlsHTML = `
                    <div class="settings-item">
                        <label for="dynamic-position-sizing">Dynamic Position Sizing</label>
                        <div class="toggle-switch">
                            <input type="checkbox" id="dynamic-position-sizing" ${this.dynamicPositionSizing ? 'checked' : ''}>
                            <span class="toggle-slider"></span>
                        </div>
                    </div>
                    <div class="settings-item">
                        <label for="risk-analysis">Advanced Risk Analysis</label>
                        <div class="toggle-switch">
                            <input type="checkbox" id="risk-analysis" ${this.riskAnalysisEnabled ? 'checked' : ''}>
                            <span class="toggle-slider"></span>
                        </div>
                    </div>
                `;
                
                const riskDiv = document.createElement('div');
                riskDiv.className = 'settings-group';
                riskDiv.innerHTML = `<div class="panel-title">Risk Management</div>${riskControlsHTML}`;
                
                settingsContainer.appendChild(riskDiv);
                
                // Add event listeners
                document.getElementById('dynamic-position-sizing')?.addEventListener('change', (e) => {
                    this.dynamicPositionSizing = e.target.checked;
                    this.app.showNotification(`Dynamic position sizing ${e.target.checked ? 'enabled' : 'disabled'}`, 'info');
                });
                
                document.getElementById('risk-analysis')?.addEventListener('change', (e) => {
                    this.riskAnalysisEnabled = e.target.checked;
                    if (e.target.checked) {
                        this.calculateRiskMetrics();
                        this.app.showNotification('Advanced risk analysis enabled', 'info');
                    } else {
                        this.app.showNotification('Advanced risk analysis disabled', 'info');
                    }
                });
            }
        }
        
        calculateHistoricalMetrics() {
            if (!this.app.candles || this.app.candles.length < 30) return;
            
            const candles = this.app.candles;
            const returns = [];
            
            // Calculate daily returns
            for (let i = 1; i < candles.length; i++) {
                const prevClose = candles[i-1].close;
                const currentClose = candles[i].close;
                returns.push((currentClose - prevClose) / prevClose);
            }
            
            // Calculate historical volatility
            this.historicalVolatility = this.calculateStandardDeviation(returns) * Math.sqrt(365); // Annualized
            
            // Calculate maximum drawdown
            let peak = -Infinity;
            let maxDrawdown = 0;
            
            for (let i = 0; i < candles.length; i++) {
                if (candles[i].close > peak) {
                    peak = candles[i].close;
                } else {
                    const drawdown = (peak - candles[i].close) / peak;
                    maxDrawdown = Math.max(maxDrawdown, drawdown);
                }
            }
            
            this.maxDrawdown = maxDrawdown;
            
            // Calculate VaR (Value at Risk)
            returns.sort((a, b) => a - b);
            const varIndex = Math.floor(returns.length * 0.05);
            this.valueAtRisk = Math.abs(returns[varIndex]);
            
            // Calculate optimal leverage based on volatility
            this.optimalLeverage = this.calculateOptimalLeverage();
        }
        
        calculateRiskMetrics() {
            if (!this.app.signals || this.app.signals.length < 5) return;
            
            const signals = this.app.signals;
            const returns = [];
            let wins = 0;
            let grossProfit = 0;
            let grossLoss = 0;
            
            // Process completed signals
            signals.filter(s => s.status === 'tp' || s.status === 'sl').forEach(signal => {
                const entryPrice = signal.price;
                const exitPrice = signal.exitPrice || entryPrice;
                const direction = signal.type === 'buy' ? 1 : -1;
                const returnPct = direction * (exitPrice - entryPrice) / entryPrice;
                
                returns.push(returnPct);
                
                if (returnPct > 0) {
                    wins++;
                    grossProfit += returnPct;
                } else {
                    grossLoss += Math.abs(returnPct);
                }
            });
            
            // Calculate metrics
            this.riskMetrics.winRate = signals.length > 0 ? wins / signals.length : 0;
            this.riskMetrics.profitFactor = grossLoss > 0 ? grossProfit / grossLoss : 0;
            
            // Calculate Sharpe Ratio
            const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;
            const stdDev = this.calculateStandardDeviation(returns);
            this.riskMetrics.sharpeRatio = stdDev > 0 ? avgReturn / stdDev : 0;
            
            // Calculate Sortino Ratio (only negative returns for denominator)
            const negativeReturns = returns.filter(r => r < 0);
            const downside = this.calculateStandardDeviation(negativeReturns);
            this.riskMetrics.sortinoRatio = downside > 0 ? avgReturn / downside : 0;
            
            // Calculate Calmar Ratio
            this.riskMetrics.calmarRatio = this.maxDrawdown > 0 ? avgReturn / this.maxDrawdown : 0;
            
            console.log('Risk metrics calculated:', this.riskMetrics);
        }
        
        calculateStandardDeviation(array) {
            const n = array.length;
            if (n === 0) return 0;
            
            const mean = array.reduce((sum, val) => sum + val, 0) / n;
            const variance = array.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / n;
            
            return Math.sqrt(variance);
        }
        
        calculateOptimalLeverage() {
            // Using Kelly Criterion for optimal leverage
            if (this.riskMetrics.winRate === 0) return 1.0;
            
            const winRate = this.riskMetrics.winRate;
            const avgWin = this.riskMetrics.profitFactor * (1 - winRate) / winRate;
            const avgLoss = 1;
            
            const kellyFraction = (winRate / avgLoss) - ((1 - winRate) / avgWin);
            return Math.max(0.5, Math.min(2.0, kellyFraction)); // Limit between 0.5x and 2x
        }
        
        getPositionSizing(baseSize) {
            if (!this.dynamicPositionSizing) return baseSize;
            
            // Adjust position size based on volatility and risk metrics
            let volatilityFactor = 1.0;
            
            if (this.historicalVolatility < this.volatilityThresholds.low) {
                volatilityFactor = 1.2; // Increase position size in low volatility
            } else if (this.historicalVolatility > this.volatilityThresholds.high) {
                volatilityFactor = 0.8; // Decrease position size in high volatility
            } else if (this.historicalVolatility > this.volatilityThresholds.extreme) {
                volatilityFactor = 0.5; // Significantly reduce position size in extreme volatility
            }
            
            // Adjust by win rate and profit factor
            let performanceFactor = 1.0;
            if (this.riskMetrics.winRate > 0.6 && this.riskMetrics.profitFactor > 1.5) {
                performanceFactor = 1.1; // Increase size when performing well
            } else if (this.riskMetrics.winRate < 0.4 || this.riskMetrics.profitFactor < 1.0) {
                performanceFactor = 0.9; // Decrease size when performing poorly
            }
            
            // Apply Kelly-based optimal leverage
            const leverageFactor = this.optimalLeverage;
            
            // Calculate final position size
            const adjustedSize = baseSize * volatilityFactor * performanceFactor * leverageFactor;
            
            return Math.max(baseSize * 0.5, Math.min(baseSize * 2.0, adjustedSize)); // Limit between 50%-200% of base size
        }
        
        scheduleRiskUpdates() {
            // Update risk metrics every 15 minutes
            setInterval(() => {
                if (this.riskAnalysisEnabled) {
                    this.calculateHistoricalMetrics();
                    this.calculateRiskMetrics();
                }
            }, 15 * 60 * 1000);
        }
        
        getCurrentRiskLevel() {
            // Determine current risk level based on volatility and metrics
            if (this.historicalVolatility > this.volatilityThresholds.extreme) {
                return 'extreme';
            } else if (this.historicalVolatility > this.volatilityThresholds.high) {
                return 'high';
            } else if (this.historicalVolatility > this.volatilityThresholds.medium) {
                return 'medium';
            } else {
                return 'low';
            }
        }
        
        getRiskReport() {
            return {
                riskLevel: this.getCurrentRiskLevel(),
                historicalVolatility: this.historicalVolatility,
                valueAtRisk: this.valueAtRisk,
                maxDrawdown: this.maxDrawdown,
                sharpeRatio: this.riskMetrics.sharpeRatio,
                sortinoRatio: this.riskMetrics.sortinoRatio,
                winRate: this.riskMetrics.winRate,
                profitFactor: this.riskMetrics.profitFactor,
                optimalLeverage: this.optimalLeverage
            };
        }
    }

</script>
<!-- === AI/ML Prediction Engine === -->
<script>
// --- LSTM Price Prediction (TensorFlow.js) ---
class LSTMPricePredictor {
    constructor() {
        this.model = null;
    }
    async buildModel(inputShape) {
        this.model = tf.sequential();
        this.model.add(tf.layers.lstm({units: 32, inputShape: inputShape, returnSequences: false}));
        this.model.add(tf.layers.dense({units: 1}));
        this.model.compile({optimizer: 'adam', loss: 'meanSquaredError'});
    }
    async train(prices, epochs=30) {
        // prices: [p1, p2, ...]
        const seqLen = 10;
        const xs = [], ys = [];
        for (let i = 0; i < prices.length - seqLen; i++) {
            xs.push(prices.slice(i, i+seqLen));
            ys.push(prices[i+seqLen]);
        }
        const xsTensor = tf.tensor3d(xs.map(x => x.map(v => [v])), [xs.length, seqLen, 1]);
        const ysTensor = tf.tensor2d(ys, [ys.length, 1]);
        await this.buildModel([seqLen, 1]);
        await this.model.fit(xsTensor, ysTensor, {epochs});
        xsTensor.dispose(); ysTensor.dispose();
    }
    predictNext(prices) {
        // prices: [p1, ..., p10]
        const input = tf.tensor3d([prices.map(v => [v])], [1, prices.length, 1]);
        const pred = this.model.predict(input);
        const val = pred.dataSync()[0];
        input.dispose(); pred.dispose();
        return val;
    }
}

// --- Random Forest Trend Classifier (ml.js) ---
class TrendRandomForest {
    constructor() {
        this.model = null;
    }
    train(features, labels) {
        // features: [[f1, f2, ...], ...], labels: [0,1,...]
        this.model = new ML.RandomForestClassifier({nEstimators: 20});
        this.model.train(features, labels);
    }
    predict(feature) {
        return this.model.predict([feature])[0];
    }
}

// --- SVM Support/Resistance Detector (ml.js) ---
class SupportResistanceSVM {
    constructor() {
        this.model = null;
    }
    train(features, labels) {
        // features: [[price, volume, ...]], labels: [0/1]
        this.model = new ML.SVM({kernel: 'rbf', c: 1.0});
        this.model.train(features, labels);
    }
    predict(feature) {
        return this.model.predict([feature])[0];
    }
}

// --- AI Prediction Engine ---
class AIPredictionEngine {
    constructor(app) {
        this.app = app;
        this.lstm = new LSTMPricePredictor();
        this.rf = new TrendRandomForest();
        this.svm = new SupportResistanceSVM();
        this.isTrained = false;
    }
    async trainAll() {
        // Fiyat verisiyle LSTM eƒüit
        const candles = this.app.candles || [];
        if (candles.length < 50) return;
        const prices = candles.map(c => c.close);
        await this.lstm.train(prices);
        // Trend i√ßin Random Forest eƒüit
        const features = [], labels = [];
        for (let i = 20; i < candles.length; i++) {
            const window = candles.slice(i-20, i);
            const mean = window.reduce((a,b)=>a+b.close,0)/20;
            const std = Math.sqrt(window.reduce((a,b)=>a+Math.pow(b.close-mean,2),0)/20);
            features.push([mean, std, window[19].volume]);
            labels.push(window[19].close > window[0].close ? 1 : 0); // 1: uptrend, 0: downtrend
        }
        this.rf.train(features, labels);
        // SVM ile destek/diren√ß eƒüit
        const srFeatures = [], srLabels = [];
        for (let i = 20; i < candles.length; i++) {
            const window = candles.slice(i-20, i);
            const max = Math.max(...window.map(c=>c.high));
            const min = Math.min(...window.map(c=>c.low));
            srFeatures.push([window[19].close, window[19].volume]);
            srLabels.push(Math.abs(window[19].close-max)<Math.abs(window[19].close-min)?1:0); // 1: resistance, 0: support
        }
        this.svm.train(srFeatures, srLabels);
        this.isTrained = true;
    }
    async predictAll() {
        if (!this.isTrained) return null;
        const candles = this.app.candles;
        if (!candles || candles.length < 30) return null;
        const lastPrices = candles.slice(-10).map(c=>c.close);
        const lstmPred = this.lstm.predictNext(lastPrices);
        const last = candles[candles.length-1];
        const mean = lastPrices.reduce((a,b)=>a+b,0)/lastPrices.length;
        const std = Math.sqrt(lastPrices.reduce((a,b)=>a+Math.pow(b-mean,2),0)/lastPrices.length);
        const rfPred = this.rf.predict([mean, std, last.volume]);
        const svmPred = this.svm.predict([last.close, last.volume]);
        return {
            pricePrediction: lstmPred,
            trend: rfPred ? 'Y√úKSELƒ∞≈û' : 'D√ú≈û√ú≈û',
            supportOrResistance: svmPred ? 'Dƒ∞REN√á' : 'DESTEK',
        };
    }
}

// --- Kehanet Paneli AI Entegrasyonu ---
window.addEventListener('DOMContentLoaded', async ()=>{
    if (!window.app) return;
    window.app.aiPredictionEngine = new AIPredictionEngine(window.app);
    await window.app.aiPredictionEngine.trainAll();
    // Kehanet Paneli butonuna tƒ±klandƒ±ƒüƒ±nda AI tahminlerini g√∂ster
    const fab = document.getElementById('kehanet-fab');
    if (fab) {
        fab.addEventListener('click', async ()=>{
            const ai = window.app.aiPredictionEngine;
            if (!ai.isTrained) return;
            const pred = await ai.predictAll();
            if (!pred) return;
            
            // Chart √ºzerinde sinyalleri g√∂ster
            updateChartSignals(
                `${pred.pricePrediction.toFixed(2)}`,
                'ACTIVE',
                pred.trend
            );
            
            renderKehanetForecasts([
                {title:'BTC/USDT',desc:'AI LSTM fiyat tahmini',prediction:pred.pricePrediction.toFixed(2),confidence:80},
                {title:'Trend',desc:'Random Forest trend sƒ±nƒ±flandƒ±rƒ±cƒ±',prediction:pred.trend,confidence:75},
                {title:'Destek/Diren√ß',desc:'SVM ile tespit',prediction:pred.supportOrResistance,confidence:70}
            ]);
        });
    }
});
</script>

<!-- D√ñRT ATLI (FOUR HORSEMEN) MARKET REGIME Sƒ∞STEMƒ∞ ve PANTEON ENTEGRASYONU -->
<script>
// Four Horsemen Market Regime Detection System
class FourHorsemenSystem {
    constructor(app) {
        this.app = app;
        this.horsemen = { war: false, famine: false, pestilence: false, death: false };
        this.averageVolume = 0;
        this.averageRange = 0;
        this.trendStrength = 0;
        this.volatilityThreshold = 1.5;
        this.liquidityThreshold = 0.7;
        this.trendThreshold = 2.0;
        this.dropThreshold = -3.0;
        this.updateInterval = 60000;
        this.lastUpdate = 0;
        this.listeners = { regimeChange: [] };
    }
    async init() {
        if (!this.app || !this.app.candles) return;
        this.calculateBaseMetrics();
        this.updateHorsemen();
        setInterval(() => this.update(), this.updateInterval);
    }
    async update() {
        try {
            const now = Date.now();
            const elapsed = now - this.lastUpdate;
            if (elapsed < this.updateInterval * 0.9) return;
            this.lastUpdate = now;
            this.calculateBaseMetrics();
            this.updateHorsemen();
        } catch (error) { console.error("Four Horsemen g√ºncelleme hatasƒ±:", error); }
    }
    calculateBaseMetrics() {
        if (!this.app.candles || this.app.candles.length < 20) return;
        const candles = this.app.candles.slice(-20);
        let totalVolume = 0;
        candles.forEach(candle => { totalVolume += candle.volume; });
        this.averageVolume = totalVolume / candles.length;
        let totalRange = 0;
        candles.forEach(candle => { totalRange += Math.abs(candle.high - candle.low); });
        this.averageRange = totalRange / candles.length;
        const prices = candles.map(c => c.close);
        this.trendStrength = this.calculateTrendStrength(prices);
    }
    calculateTrendStrength(prices) {
        const n = prices.length;
        let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
        for (let i = 0; i < n; i++) {
            sumX += i;
            sumY += prices[i];
            sumXY += i * prices[i];
            sumX2 += i * i;
        }
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        const normalizedSlope = (slope / prices[0]) * 100;
        return normalizedSlope;
    }
    updateHorsemen() {
        if (!this.app.candles || this.app.candles.length < 20) return;
        const candles = this.app.candles;
        const recent = candles.slice(-5);
        const current = candles[candles.length - 1];
        const previous = candles[candles.length - 2];
        const prevHorsemen = { ...this.horsemen };
        Object.keys(this.horsemen).forEach(key => { this.horsemen[key] = false; });
        const recentVolatility = this.calculateVolatility(recent.map(c => c.close));
        if (recentVolatility > this.volatilityThreshold) this.horsemen.war = true;
        const currentVolume = current.volume;
        if (currentVolume < this.averageVolume * this.liquidityThreshold) this.horsemen.famine = true;
        const recentTrendStrength = this.calculateTrendStrength(recent.map(c => c.close));
        if (Math.abs(recentTrendStrength) > Math.abs(this.trendStrength) * this.trendThreshold) this.horsemen.pestilence = true;
        const priceChange = ((current.close - previous.close) / previous.close) * 100;
        if (priceChange < this.dropThreshold) this.horsemen.death = true;
        if (this.hasRegimeChanged(prevHorsemen)) this.notifyRegimeChange();
        this.updateUI();
    }
    hasRegimeChanged(prevHorsemen) {
        for (const [key, value] of Object.entries(this.horsemen)) {
            if (prevHorsemen[key] !== value) return true;
        }
        return false;
    }
    notifyRegimeChange() {
        this.listeners.regimeChange.forEach(callback => { callback(this.getActiveRegime()); });
        const activeHorsemen = this.getActiveHorsemen();
        if (activeHorsemen.length > 0) {
            const message = `Mah≈üerin ${activeHorsemen.length > 1 ? "Atlƒ±larƒ±" : "Atlƒ±sƒ±"} g√∂r√ºld√º: ${activeHorsemen.map(key => this.getHorsemanName(key)).join(", ")}`;
            if (this.app.notificationManager) {
                this.app.notificationManager.notify(message, 'warning', 3);
            } else {
                console.log(message);
            }
        }
    }
    calculateVolatility(prices) {
        const n = prices.length;
        if (n < 2) return 0;
        const avg = prices.reduce((sum, price) => sum + price, 0) / n;
        const variance = prices.reduce((sum, price) => sum + Math.pow(price - avg, 2), 0) / (n - 1);
        const stdDev = Math.sqrt(variance);
        return (stdDev / avg) * 100;
    }
    updateUI() {
        const container = document.getElementById('horsemen-container');
        if (!container) return;
        Object.entries(this.horsemen).forEach(([horseman, active]) => {
            const element = container.querySelector(`.horseman[data-type="${horseman}"]`);
            if (element) {
                element.classList.toggle('active', active);
                const icon = element.querySelector('.horseman-icon');
                if (icon) icon.style.opacity = active ? '1' : '0.3';
            }
        });
        const regimeElement = document.getElementById('current-regime');
        if (regimeElement) {
            const activeRegime = this.getActiveRegime();
            regimeElement.textContent = `Aktif Rejim: ${activeRegime}`;
            regimeElement.className = 'regime-indicator';
            regimeElement.classList.add(`regime-${activeRegime.toLowerCase()}`);
        }
    }
    getHorsemanName(key) {
        const names = { war: "Sava≈ü", famine: "Kƒ±tlƒ±k", pestilence: "Veba", death: "√ñl√ºm" };
        return names[key] || key;
    }
    getActiveHorsemen() {
        return Object.entries(this.horsemen).filter(([_, active]) => active).map(([key, _]) => key);
    }
    isAnyHorsemanActive() {
        return Object.values(this.horsemen).some(active => active);
    }
    getActiveRegime() {
        const active = this.getActiveHorsemen();
        if (active.length === 0) return "Normal";
        if (active.includes("death")) return "√ñl√ºm";
        if (active.includes("war")) return "Sava≈ü";
        if (active.includes("pestilence")) return "Veba";
        if (active.includes("famine")) return "Kƒ±tlƒ±k";
        return "Karƒ±≈üƒ±k";
    }
    onRegimeChange(callback) {
        if (typeof callback === 'function') this.listeners.regimeChange.push(callback);
    }
    updateThresholds(thresholds) {
        if (!thresholds) return;
        if (thresholds.volatility !== undefined) this.volatilityThreshold = thresholds.volatility;
        if (thresholds.liquidity !== undefined) this.liquidityThreshold = thresholds.liquidity;
        if (thresholds.trend !== undefined) this.trendThreshold = thresholds.trend;
        if (thresholds.drop !== undefined) this.dropThreshold = thresholds.drop;
        this.updateHorsemen();
    }
}

// Panteon ve Four Horsemen entegrasyonu
class PanteonHorsemenIntegration {
    constructor(app) {
        this.app = app;
        this.horsemenSystem = null;
        this.regimeHistory = [];
        this.maxHistorySize = 10;
    }
    async init() {
        this.horsemenSystem = new FourHorsemenSystem(this.app);
        this.horsemenSystem.init();
        this.horsemenSystem.onRegimeChange(regime => { this.recordRegimeChange(regime); });
        this.setupUIUpdater();
    }
    setupUIUpdater() {
        this.horsemenSystem.onRegimeChange(regime => {
            const regimeElement = document.getElementById('current-regime');
            if (regimeElement) {
                regimeElement.textContent = `Aktif Rejim: ${regime}`;
                regimeElement.className = 'regime-indicator';
                regimeElement.classList.add(`regime-${regime.toLowerCase()}`);
            }
        });
    }
    recordRegimeChange(regime) {
        const timestamp = new Date();
        this.regimeHistory.push({
            regime,
            timestamp,
            activeHorsemen: this.horsemenSystem ? this.horsemenSystem.getActiveHorsemen() : []
        });
        if (this.regimeHistory.length > this.maxHistorySize) this.regimeHistory.shift();
        // Rejim ge√ßmi≈üi tabloya yazƒ±labilir
    }
    getRegimeHistory() { return this.regimeHistory; }
    getCurrentRegime() { return this.horsemenSystem ? this.horsemenSystem.getActiveRegime() : "Normal"; }
}

// DOM y√ºklendiƒüinde otomatik ba≈ülatmak i√ßin √∂rnek entegrasyon
document.addEventListener('DOMContentLoaded', function() {
    if (!window.app) window.app = {};
    if (!window.app.candles) {
        // Basit √∂rnek veri (ger√ßek sistemde canlƒ± veri ile deƒüi≈ütirin)
        window.app.candles = Array.from({length: 100}, (_, i) => {
            const price = 100 + Math.sin(i/10)*5 + Math.random()*2;
            return {
                time: Date.now() - (100-i)*60000,
                open: price,
                close: price + (Math.random()-0.5),
                high: price * (1 + Math.random()*0.01),
                low: price * (1 - Math.random()*0.01),
                volume: 1000 + Math.random()*500
            };
        });
    }
    if (!window.app.notificationManager) {
        window.app.notificationManager = {
            notify: function(message, type, duration) {
                console.log(`[${type}] ${message}`);
            }
        };
    }
    // UI'da horsemen-container yoksa ekle
    if (!document.getElementById('horsemen-container')) {
        const container = document.createElement('div');
        container.id = 'horsemen-container';
        container.className = 'horsemen-container';
        container.style.cssText = 'display: flex; justify-content: space-around; padding: 10px; background-color: #1a1a1a; border-radius: 8px; margin: 10px 0;';
        const icons = { war: '‚öîÔ∏è', famine: 'üçû', pestilence: 'ü¶†', death: 'üíÄ' };
        const labels = { war: 'Sava≈ü', famine: 'Kƒ±tlƒ±k', pestilence: 'Veba', death: '√ñl√ºm' };
        Object.keys(icons).forEach(type => {
            const horseman = document.createElement('div');
            horseman.className = 'horseman';
            horseman.dataset.type = type;
            horseman.style.cssText = 'text-align: center; padding: 5px 15px; border-radius: 5px; transition: all 0.3s ease;';
            const icon = document.createElement('div');
            icon.className = 'horseman-icon';
            icon.textContent = icons[type];
            icon.style.cssText = 'font-size: 24px; opacity: 0.3; transition: opacity 0.3s;';
            const label = document.createElement('div');
            label.className = 'horseman-label';
            label.textContent = labels[type];
            label.style.cssText = 'font-size: 12px; margin-top: 5px;';
            horseman.appendChild(icon);
            horseman.appendChild(label);
            container.appendChild(horseman);
        });
        // Aktif rejim g√∂stergesi
        const regimeIndicator = document.createElement('div');
        regimeIndicator.id = 'current-regime';
        regimeIndicator.className = 'regime-indicator';
        regimeIndicator.textContent = 'Aktif Rejim: Normal';
        regimeIndicator.style.cssText = 'text-align: center; margin-top: 10px; font-weight: bold; padding: 5px; border-radius: 3px;';
        container.appendChild(regimeIndicator);
        // Panteon paneline veya body'ye ekle
        const panteonPanel = document.getElementById('panteon-panel') || document.body;
        panteonPanel.appendChild(container);
    }
    // Entegrasyonu ba≈ülat
    window.panteonHorsemenIntegration = new PanteonHorsemenIntegration(window.app);
    window.panteonHorsemenIntegration.init();
});
</script>
<script>
    // NOT: Bu event listener artƒ±k kullanƒ±lmƒ±yor, ana event listener'a ta≈üƒ±ndƒ±
    // Eski kodlar referans olarak silindi
    console.log('Ek sistemler ana event listener\'a ta≈üƒ±ndƒ±.');
</script>

<!-- Advanced Notification Container -->
<div id="notifications-container" class="notifications"></div>

<!-- Notification History Modal -->
<div id="notification-history-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Bildirim Ge√ßmi≈üi</h3>
            <span class="close-modal">&times;</span>
        </div>
        <div class="modal-body">
            <div class="notification-filters">
                <button class="filter active" data-filter="all">T√ºm√º</button>
                <button class="filter" data-filter="trade">ƒ∞≈ülem</button>
                <button class="filter" data-filter="alert">Uyarƒ±</button>
                <button class="filter" data-filter="success">Ba≈üarƒ±lƒ±</button>
                <button class="filter" data-filter="error">Hata</button>
                <button class="filter" data-filter="system">Sistem</button>
            </div>
            <div id="notification-history-list"></div>
        </div>
        <div class="modal-footer">
            <button id="clear-notifications-history" class="btn btn-danger">Ge√ßmi≈üi Temizle</button>
        </div>
    </div>
</div>
</body>
<!-- Kehanet Paneli (Piyasa Tahminleri ve AI √ñng√∂r√ºleri) -->
<div id="kehanet-panel" style="position:fixed;bottom:20px;right:20px;z-index:1400;width:240px;max-width:90vw;background:rgba(18,22,34,0.92);border-radius:8px;box-shadow:0 4px 24px #0008;padding:0;display:none;flex-direction:column;overflow:hidden;font-family:'Roboto Mono',monospace;transition:all 0.3s ease;">
    <div style="display:flex;align-items:center;justify-content:space-between;padding:10px 12px;background:rgba(255,215,0,0.08);border-bottom:1px solid #333;cursor:pointer;" onclick="toggleKehanetContent()">
        <span style="font-weight:700;font-size:14px;letter-spacing:1px;color:#ffd700;">üîÆ Kehanet Paneli</span>
        <span id="kehanet-toggle-icon" style="color:#ffd700;font-size:16px;">‚àí</span>
    </div>
    <div id="kehanet-content" style="padding:12px;max-height:200px;overflow-y:auto;transition:all 0.3s ease;">
        <div style="font-size:11px;opacity:0.8;margin-bottom:8px;">AI destekli piyasa √∂ng√∂r√ºleri ve stratejik tahminler</div>
        <div id="kehanet-forecast-list">
            <!-- √ñrnek tahminler -->
        </div>
        <button id="kehanet-refresh" style="margin-top:8px;background:#ffd700;color:#222;font-weight:600;padding:4px 12px;border:none;border-radius:4px;cursor:pointer;font-size:10px;">G√ºncelle</button>
    </div>
</div>
<button id="kehanet-fab" title="Kehanet Paneli" style="position:fixed;bottom:24px;right:24px;z-index:1399;width:44px;height:44px;border-radius:50%;background:linear-gradient(135deg,#ffd700 60%,#ba68c8 100%);box-shadow:0 2px 12px #0007;border:none;display:flex;align-items:center;justify-content:center;font-size:20px;color:#222;cursor:pointer;transition:background 0.2s;">üîÆ</button>

<script>
// Kehanet Paneli UI ve √∂rnek tahminler
function showKehanetPanel(show=true){
    document.getElementById('kehanet-panel').style.display=show?'flex':'none';
    document.getElementById('kehanet-fab').style.display=show?'none':'flex';
}

// Toggle content
function toggleKehanetContent() {
    const content = document.getElementById('kehanet-content');
    const toggle = document.getElementById('kehanet-toggle-icon');
    
    if (content.style.maxHeight === '0px') {
        content.style.maxHeight = '200px';
        content.style.opacity = '1';
        toggle.textContent = '‚àí';
    } else {
        content.style.maxHeight = '0px';
        content.style.opacity = '0';
        toggle.textContent = '+';
    }
}

document.getElementById('kehanet-fab').onclick=()=>showKehanetPanel(true);

function renderKehanetForecasts(forecasts){
    const list=document.getElementById('kehanet-forecast-list');
    if(!forecasts||!forecasts.length){list.innerHTML='<div style="opacity:0.7;">Tahmin bulunamadƒ±.</div>';return;}
    list.innerHTML=forecasts.map(f=>`<div style="margin-bottom:10px;padding:10px 8px;background:rgba(255,255,255,0.03);border-radius:6px;">
        <div style="font-size:14px;font-weight:600;color:#ffd700;">${f.title}</div>
        <div style="font-size:12px;opacity:0.85;margin:4px 0 0 0;">${f.desc}</div>
        <div style="font-size:11px;opacity:0.6;margin-top:2px;">Tahmin: <b>${f.prediction}</b> &nbsp;|&nbsp; G√ºven: <b>${f.confidence}%</b></div>
    </div>`).join('');
}

function getSampleForecasts(){
    // Burada ger√ßek AI/ML entegrasyonu yapƒ±labilir
    return [
        {title:'BTC/USDT',desc:'√ñn√ºm√ºzdeki 4 saatlik periyotta y√ºkseli≈ü bekleniyor.',prediction:'Y√úKSELƒ∞≈û',confidence:78},
        {title:'ETH/USDT',desc:'Kƒ±sa vadede yatay hareket olasƒ±lƒ±ƒüƒ± y√ºksek.',prediction:'YATAY',confidence:62},
        {title:'Piyasa Rejimi',desc:'D√∂rt Atlƒ± motoruna g√∂re: SAVA≈û (Trend) rejimi aktif.',prediction:'SAVA≈û',confidence:85},
        {title:'AI Sinyal',desc:'AI modeline g√∂re volatilite artƒ±≈üƒ± bekleniyor.',prediction:'VOLATƒ∞Lƒ∞TE',confidence:70}
    ];
}

function refreshKehanetForecasts(){
    // Gelecekte async API/ML entegrasyonu yapƒ±labilir
    renderKehanetForecasts(getSampleForecasts());
}
document.getElementById('kehanet-refresh').onclick=refreshKehanetForecasts;
// Panel a√ßƒ±ldƒ±ƒüƒ±nda otomatik y√ºkle
document.getElementById('kehanet-fab').addEventListener('click',refreshKehanetForecasts);

// Sayfa y√ºklenince FAB g√∂r√ºn√ºr olsun
window.addEventListener('DOMContentLoaded',()=>{
    document.getElementById('kehanet-fab').style.display='flex';
});
</script>

<!-- === OSIRIS SENTINEL SYSTEM === -->
<script>
// --- OSIRIS Core Engine ---
class OSIRISCore {
    constructor(app) {
        this.app = app;
        this.isActive = false;
        this.threats = [];
        this.alerts = [];
        this.cyberBees = [];
        this.sentinels = {};
        this.riskLevel = 'LOW';
        this.lastScan = 0;
        this.scanInterval = 5000; // 5 saniye
        this.initSentinels();
    }
    
    initSentinels() {
        this.sentinels = {
            marketAnomalyDetector: new MarketAnomalyDetector(this),
            liquidityMonitor: new LiquidityMonitor(this),
            volatilityWatcher: new VolatilityWatcher(this),
            orderBookAnalyzer: new OrderBookAnalyzer(this),
            riskAssessment: new RiskAssessment(this)
        };
    }
    
    async activate() {
        if (this.isActive) return;
        this.isActive = true;
        
        // Cyber Bee Network ba≈ülat
        await this.initCyberBeeNetwork();
        
        // Sentinel sistemlerini ba≈ülat
        Object.values(this.sentinels).forEach(sentinel => sentinel.activate());
        
        // Ana tarama d√∂ng√ºs√ºn√º ba≈ülat
        this.mainLoop = setInterval(() => this.scanForThreats(), this.scanInterval);
        
        this.app.showNotification('OSIRIS SENTINEL Sistemi aktif edildi', 'info');
        console.log('üõ°Ô∏è OSIRIS SENTINEL SYSTEM ACTIVATED');
    }
    
    async deactivate() {
        this.isActive = false;
        clearInterval(this.mainLoop);
        Object.values(this.sentinels).forEach(sentinel => sentinel.deactivate());
        this.cyberBees.forEach(bee => bee.terminate());
        this.cyberBees = [];
    }
    
    async initCyberBeeNetwork() {
        // 5 farklƒ± tipte Cyber Bee olu≈ütur
        const beeTypes = ['scout', 'guardian', 'analyzer', 'hunter', 'coordinator'];
        
        for (const type of beeTypes) {
            const bee = new CyberBee(type, this);
            await bee.initialize();
            this.cyberBees.push(bee);
        }
    }
    
    async scanForThreats() {
        if (!this.isActive) return;
        
        const now = Date.now();
        this.lastScan = now;
        
        // Her sentinel'den threat taramasƒ± al
        const threatReports = await Promise.all(
            Object.values(this.sentinels).map(sentinel => sentinel.scan())
        );
        
        // Cyber bee aƒüƒ±ndan intelligence topla
        const beeIntelligence = await this.gatherBeeIntelligence();
        
        // Tehditleri analiz et ve risk seviyesini g√ºncelle
        this.analyzeThreats([...threatReports.flat(), ...beeIntelligence]);
        
        // Kritik tehditler varsa alarm √ßal
        this.processAlerts();
    }
    
    async gatherBeeIntelligence() {
        const intelligence = [];
        
        for (const bee of this.cyberBees) {
            const report = await bee.generateIntelligence();
            if (report) intelligence.push(report);
        }
        
        return intelligence;
    }
    
    analyzeThreats(threats) {
        this.threats = threats.filter(t => t.severity > 0);
        
        // Risk seviyesi hesapla
        const maxSeverity = Math.max(...this.threats.map(t => t.severity), 0);
        
        if (maxSeverity >= 8) this.riskLevel = 'CRITICAL';
        else if (maxSeverity >= 6) this.riskLevel = 'HIGH';
        else if (maxSeverity >= 4) this.riskLevel = 'MEDIUM';
        else this.riskLevel = 'LOW';
        
        // UI g√ºncelle
        this.updateOSIRISUI();
    }
    
    processAlerts() {
        const criticalThreats = this.threats.filter(t => t.severity >= 7);
        
        for (const threat of criticalThreats) {
            this.createAlert(threat);
        }
    }
    
    createAlert(threat) {
        const alert = {
            id: Date.now() + Math.random(),
            threat: threat,
            timestamp: Date.now(),
            status: 'ACTIVE'
        };
        
        this.alerts.unshift(alert);
        
        // Maksimum 50 alert sakla
        if (this.alerts.length > 50) {
            this.alerts = this.alerts.slice(0, 50);
        }
        
        // Kullanƒ±cƒ±ya bildir
        this.app.showNotification(
            `‚ö†Ô∏è OSIRIS ALERT: ${threat.type} - ${threat.message}`,
            'warning'
        );
    }
    
    updateOSIRISUI() {
        // OSIRIS panelini g√ºncelle
        const panel = document.getElementById('osiris-panel');
        if (!panel) return;
        
        // Risk seviyesi
        const riskElement = panel.querySelector('#osiris-risk-level');
        if (riskElement) {
            riskElement.textContent = this.riskLevel;
            riskElement.className = `risk-level ${this.riskLevel.toLowerCase()}`;
        }
        
        // Aktif tehdit sayƒ±sƒ±
        const threatCount = panel.querySelector('#osiris-threat-count');
        if (threatCount) {
            threatCount.textContent = this.threats.length;
        }
        
        // Cyber bee durumu
        const beeStatus = panel.querySelector('#osiris-bee-status');
        if (beeStatus) {
            const activeBees = this.cyberBees.filter(bee => bee.isActive).length;
            beeStatus.textContent = `${activeBees}/${this.cyberBees.length}`;
        }
    }
}

// --- Cyber Bee Network ---
class CyberBee {
    constructor(type, osiris) {
        this.type = type;
        this.osiris = osiris;
        this.isActive = false;
        this.intelligence = [];
        this.lastActivity = 0;
        this.behaviorPattern = this.getBehaviorPattern(type);
    }
    
    getBehaviorPattern(type) {
        const patterns = {
            scout: {
                scanFrequency: 3000,
                focusArea: 'market_exploration',
                sensitivity: 0.7
            },
            guardian: {
                scanFrequency: 1000,
                focusArea: 'threat_detection',
                sensitivity: 0.9
            },
            analyzer: {
                scanFrequency: 5000,
                focusArea: 'pattern_analysis',
                sensitivity: 0.8
            },
            hunter: {
                scanFrequency: 2000,
                focusArea: 'anomaly_hunting',
                sensitivity: 0.95
            },
            coordinator: {
                scanFrequency: 10000,
                focusArea: 'network_coordination',
                sensitivity: 0.6
            }
        };
        
        return patterns[type] || patterns.scout;
    }
    
    async initialize() {
        this.isActive = true;
        this.startBehaviorLoop();
    }
    
    startBehaviorLoop() {
        this.behaviorTimer = setInterval(() => {
            this.executeBehavior();
        }, this.behaviorPattern.scanFrequency);
    }
    
    async executeBehavior() {
        if (!this.isActive) return;
        
        this.lastActivity = Date.now();
        
        switch (this.type) {
            case 'scout':
                await this.scoutMarketConditions();
                break;
            case 'guardian':
                await this.guardAgainstThreats();
                break;
            case 'analyzer':
                await this.analyzePatterns();
                break;
            case 'hunter':
                await this.huntAnomalies();
                break;
            case 'coordinator':
                await this.coordinateNetwork();
                break;
        }
    }
    
    async scoutMarketConditions() {
        const candles = this.osiris.app.candles;
        if (!candles || candles.length < 10) return;
        
        const recent = candles.slice(-10);
        const volatility = this.calculateVolatility(recent);
        const volume = recent[recent.length - 1].volume;
        const avgVolume = recent.reduce((sum, c) => sum + c.volume, 0) / recent.length;
        
        if (volatility > 0.05) { // %5+ volatilite
            this.reportIntelligence({
                type: 'HIGH_VOLATILITY',
                severity: Math.min(volatility * 100, 10),
                data: { volatility, currentVolume: volume, avgVolume }
            });
        }
    }
    
    async guardAgainstThreats() {
        const signals = this.osiris.app.signals || [];
        const recentSignals = signals.filter(s => 
            Date.now() - s.timestamp < 300000 // Son 5 dakika
        );
        
        const slCount = recentSignals.filter(s => s.status === 'sl').length;
        const totalCount = recentSignals.length;
        
        if (totalCount > 0 && slCount / totalCount > 0.7) { // %70+ loss rate
            this.reportIntelligence({
                type: 'HIGH_LOSS_RATE',
                severity: 8,
                data: { slCount, totalCount, lossRate: slCount / totalCount }
            });
        }
    }
    
    async analyzePatterns() {
        const candles = this.osiris.app.candles;
        if (!candles || candles.length < 20) return;
        
        // Fiyat pattern analizi
        const recent = candles.slice(-20);
        const prices = recent.map(c => c.close);
        
        // Trend analizi
        const trend = this.calculateTrend(prices);
        const trendStrength = Math.abs(trend);
        
        if (trendStrength > 0.02) { // %2+ trend g√ºc√º
            this.reportIntelligence({
                type: 'STRONG_TREND_DETECTED',
                severity: Math.min(trendStrength * 200, 7),
                data: { trend, strength: trendStrength, direction: trend > 0 ? 'UP' : 'DOWN' }
            });
        }
    }
    
    async huntAnomalies() {
        const orderBook = this.osiris.app.lastOrderBook;
        if (!orderBook) return;
        
        // Emir defteri anomali tespiti
        const bids = orderBook.bids || [];
        const asks = orderBook.asks || [];
        
        if (bids.length === 0 || asks.length === 0) return;
        
        const spread = asks[0][0] - bids[0][0];
        const midPrice = (asks[0][0] + bids[0][0]) / 2;
        const spreadPercent = (spread / midPrice) * 100;
        
        if (spreadPercent > 0.5) { // %0.5+ spread
            this.reportIntelligence({
                type: 'WIDE_SPREAD_ANOMALY',
                severity: Math.min(spreadPercent * 10, 9),
                data: { spread, spreadPercent, midPrice }
            });
        }
    }
    
    async coordinateNetwork() {
        // Diƒüer bee'lerle koordinasyon
        const otherBees = this.osiris.cyberBees.filter(bee => bee !== this);
        const recentIntelligence = otherBees
            .map(bee => bee.intelligence.slice(-5))
            .flat()
            .filter(intel => Date.now() - intel.timestamp < 60000); // Son 1 dakika
        
        if (recentIntelligence.length > 10) {
            this.reportIntelligence({
                type: 'HIGH_NETWORK_ACTIVITY',
                severity: 5,
                data: { intelligenceCount: recentIntelligence.length }
            });
        }
    }
    
    calculateVolatility(candles) {
        const prices = candles.map(c => c.close);
        const mean = prices.reduce((sum, p) => sum + p, 0) / prices.length;
        const variance = prices.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / prices.length;
        return Math.sqrt(variance) / mean;
    }
    
    calculateTrend(prices) {
        const n = prices.length;
        let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
        
        for (let i = 0; i < n; i++) {
            sumX += i;
            sumY += prices[i];
            sumXY += i * prices[i];
            sumX2 += i * i;
        }
        
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        return slope / prices[0]; // Normalize
    }
    
    reportIntelligence(intel) {
        intel.timestamp = Date.now();
        intel.source = `bee_${this.type}`;
        
        this.intelligence.push(intel);
        
        // Maksimum 100 intelligence sakla
        if (this.intelligence.length > 100) {
            this.intelligence = this.intelligence.slice(-100);
        }
    }
    
    async generateIntelligence() {
        // Son 30 saniyedeki intelligence'ƒ± d√∂nd√ºr
        const recent = this.intelligence.filter(intel => 
            Date.now() - intel.timestamp < 30000
        );
        
        return recent.length > 0 ? recent[recent.length - 1] : null;
    }
    
    terminate() {
        this.isActive = false;
        clearInterval(this.behaviorTimer);
    }
}

// --- Market Anomaly Detector ---
class MarketAnomalyDetector {
    constructor(osiris) {
        this.osiris = osiris;
        this.isActive = false;
        this.baselineMetrics = null;
    }
    
    activate() {
        this.isActive = true;
        this.calculateBaseline();
    }
    
    deactivate() {
        this.isActive = false;
    }
    
    calculateBaseline() {
        const candles = this.osiris.app.candles;
        if (!candles || candles.length < 100) return;
        
        const recent100 = candles.slice(-100);
        const volumes = recent100.map(c => c.volume);
        const ranges = recent100.map(c => c.high - c.low);
        
        this.baselineMetrics = {
            avgVolume: volumes.reduce((sum, v) => sum + v, 0) / volumes.length,
            avgRange: ranges.reduce((sum, r) => sum + r, 0) / ranges.length,
            volumeStd: this.calculateStd(volumes),
            rangeStd: this.calculateStd(ranges)
        };
    }
    
    calculateStd(arr) {
        const mean = arr.reduce((sum, v) => sum + v, 0) / arr.length;
        const variance = arr.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / arr.length;
        return Math.sqrt(variance);
    }
    
    async scan() {
        if (!this.isActive || !this.baselineMetrics) return [];
        
        const threats = [];
        const candles = this.osiris.app.candles;
        if (!candles || candles.length === 0) return threats;
        
        const lastCandle = candles[candles.length - 1];
        const currentVolume = lastCandle.volume;
        const currentRange = lastCandle.high - lastCandle.low;
        
        // Hacim anomalisi
        const volumeDeviation = Math.abs(currentVolume - this.baselineMetrics.avgVolume) / this.baselineMetrics.volumeStd;
        if (volumeDeviation > 3) { // 3 sigma dƒ±≈üƒ±nda
            threats.push({
                type: 'VOLUME_ANOMALY',
                severity: Math.min(volumeDeviation, 10),
                message: `Anormal hacim tespit edildi: ${volumeDeviation.toFixed(2)} sigma`,
                data: { currentVolume, baseline: this.baselineMetrics.avgVolume, deviation: volumeDeviation }
            });
        }
        
        // Fiyat aralƒ±ƒüƒ± anomalisi
        const rangeDeviation = Math.abs(currentRange - this.baselineMetrics.avgRange) / this.baselineMetrics.rangeStd;
        if (rangeDeviation > 3) {
            threats.push({
                type: 'PRICE_RANGE_ANOMALY',
                severity: Math.min(rangeDeviation, 10),
                message: `Anormal fiyat aralƒ±ƒüƒ±: ${rangeDeviation.toFixed(2)} sigma`,
                data: { currentRange, baseline: this.baselineMetrics.avgRange, deviation: rangeDeviation }
            });
        }
        
        return threats;
    }
}

// --- Liquidity Monitor ---
class LiquidityMonitor {
    constructor(osiris) {
        this.osiris = osiris;
        this.isActive = false;
        this.liquidityThresholds = {
            low: 50000,    // $50K
            critical: 20000 // $20K
        };
    }
    
    activate() {
        this.isActive = true;
    }
    
    deactivate() {
        this.isActive = false;
    }
    
    async scan() {
        if (!this.isActive) return [];
        
        const threats = [];
        const orderBook = this.osiris.app.lastOrderBook;
        if (!orderBook) return threats;
        
        const bidLiquidity = this.calculateLiquidity(orderBook.bids || []);
        const askLiquidity = this.calculateLiquidity(orderBook.asks || []);
        const totalLiquidity = bidLiquidity + askLiquidity;
        
        if (totalLiquidity < this.liquidityThresholds.critical) {
            threats.push({
                type: 'CRITICAL_LIQUIDITY',
                severity: 9,
                message: `Kritik likidite seviyesi: $${totalLiquidity.toFixed(0)}`,
                data: { bidLiquidity, askLiquidity, totalLiquidity }
            });
        } else if (totalLiquidity < this.liquidityThresholds.low) {
            threats.push({
                type: 'LOW_LIQUIDITY',
                severity: 6,
                message: `D√º≈ü√ºk likidite: $${totalLiquidity.toFixed(0)}`,
                data: { bidLiquidity, askLiquidity, totalLiquidity }
            });
        }
        
        return threats;
    }
    
    calculateLiquidity(orders) {
        return orders.slice(0, 10).reduce((sum, [price, quantity]) => {
            return sum + (price * quantity);
        }, 0);
    }
}

// --- Volatility Watcher ---
class VolatilityWatcher {
    constructor(osiris) {
        this.osiris = osiris;
        this.isActive = false;
        this.volatilityThresholds = {
            high: 0.03,    // %3
            extreme: 0.05  // %5
        };
    }
    
    activate() {
        this.isActive = true;
    }
    
    deactivate() {
        this.isActive = false;
    }
    
    async scan() {
        if (!this.isActive) return [];
        
        const threats = [];
        const candles = this.osiris.app.candles;
        if (!candles || candles.length < 20) return threats;
        
        const recent = candles.slice(-20);
        const volatility = this.calculateVolatility(recent);
        
        if (volatility > this.volatilityThresholds.extreme) {
            threats.push({
                type: 'EXTREME_VOLATILITY',
                severity: 8,
                message: `Ekstrem volatilite: %${(volatility * 100).toFixed(2)}`,
                data: { volatility, threshold: this.volatilityThresholds.extreme }
            });
        } else if (volatility > this.volatilityThresholds.high) {
            threats.push({
                type: 'HIGH_VOLATILITY',
                severity: 5,
                message: `Y√ºksek volatilite: %${(volatility * 100).toFixed(2)}`,
                data: { volatility, threshold: this.volatilityThresholds.high }
            });
        }
        
        return threats;
    }
    
    calculateVolatility(candles) {
        const prices = candles.map(c => c.close);
        const mean = prices.reduce((sum, p) => sum + p, 0) / prices.length;
        const variance = prices.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / prices.length;
        return Math.sqrt(variance) / mean;
    }
}

// --- Order Book Analyzer ---
class OrderBookAnalyzer {
    constructor(osiris) {
        this.osiris = osiris;
        this.isActive = false;
    }
    
    activate() {
        this.isActive = true;
    }
    
    deactivate() {
        this.isActive = false;
    }
    
    async scan() {
        if (!this.isActive) return [];
        
        const threats = [];
        const orderBook = this.osiris.app.lastOrderBook;
        if (!orderBook) return threats;
        
        const bids = orderBook.bids || [];
        const asks = orderBook.asks || [];
        
        if (bids.length === 0 || asks.length === 0) {
            threats.push({
                type: 'EMPTY_ORDER_BOOK',
                severity: 10,
                message: 'Emir defteri bo≈ü',
                data: { bidsCount: bids.length, asksCount: asks.length }
            });
            return threats;
        }
        
        // Spread analizi
        const spread = asks[0][0] - bids[0][0];
        const midPrice = (asks[0][0] + bids[0][0]) / 2;
        const spreadPercent = (spread / midPrice) * 100;
        
        if (spreadPercent > 1.0) { // %1+ spread
            threats.push({
                type: 'WIDE_SPREAD',
                severity: Math.min(spreadPercent * 5, 10),
                message: `Geni≈ü spread: %${spreadPercent.toFixed(3)}`,
                data: { spread, spreadPercent, midPrice }
            });
        }
        
        // Emir dengesizliƒüi
        const bidVolume = bids.slice(0, 10).reduce((sum, [_, qty]) => sum + qty, 0);
        const askVolume = asks.slice(0, 10).reduce((sum, [_, qty]) => sum + qty, 0);
        const imbalance = Math.abs(bidVolume - askVolume) / (bidVolume + askVolume);
        
        if (imbalance > 0.8) { // %80+ dengesizlik
            threats.push({
                type: 'ORDER_IMBALANCE',
                severity: Math.min(imbalance * 10, 9),
                message: `Emir dengesizliƒüi: %${(imbalance * 100).toFixed(1)}`,
                data: { bidVolume, askVolume, imbalance }
            });
        }
        
        return threats;
    }
}

// --- Risk Assessment ---
class RiskAssessment {
    constructor(osiris) {
        this.osiris = osiris;
        this.isActive = false;
    }
    
    activate() {
        this.isActive = true;
    }
    
    deactivate() {
        this.isActive = false;
    }
    
    async scan() {
        if (!this.isActive) return [];
        
        const threats = [];
        const app = this.osiris.app;
        
        // Trading performans analizi
        const signals = app.signals || [];
        if (signals.length > 10) {
            const recentSignals = signals.slice(-20);
            const tpCount = recentSignals.filter(s => s.status === 'tp').length;
            const slCount = recentSignals.filter(s => s.status === 'sl').length;
            const winRate = tpCount / (tpCount + slCount);
            
            if (winRate < 0.3) { // %30 altƒ±nda kazanma oranƒ±
                threats.push({
                    type: 'LOW_WIN_RATE',
                    severity: 7,
                    message: `D√º≈ü√ºk kazanma oranƒ±: %${(winRate * 100).toFixed(1)}`,
                    data: { winRate, tpCount, slCount, totalCount: tpCount + slCount }
                });
            }
        }
        
        // Sistem saƒülƒ±ƒüƒ±
        const lastUpdate = app.lastDataUpdate || 0;
        const timeSinceUpdate = Date.now() - lastUpdate;
        
        if (timeSinceUpdate > 60000) { // 1 dakikadan eski veri
            threats.push({
                type: 'STALE_DATA',
                severity: 6,
                message: `Eski veri: ${Math.round(timeSinceUpdate / 1000)}s`,
                data: { timeSinceUpdate, lastUpdate }
            });
        }
        
        return threats;
    }
}

// OSIRIS UI entegrasyonu
window.addEventListener('DOMContentLoaded', () => {
    if (!window.app) return;
    
    // OSIRIS sistemini ba≈ülat
    window.app.osiris = new OSIRISCore(window.app);
    
    // OSIRIS paneli olu≈ütur
    createOSIRISPanel();
    
    // Chart overlay signals olu≈ütur
    createChartSignalOverlay();
    
    // Otomatik sinyal g√ºncellemeleri
    setInterval(async () => {
        if (window.app && window.app.aiPredictionEngine && window.app.aiPredictionEngine.isTrained) {
            const pred = await window.app.aiPredictionEngine.predictAll();
            if (pred) {
                updateChartSignals(
                    `${pred.pricePrediction.toFixed(2)}`,
                    'ACTIVE',
                    pred.trend
                );
            }
        }
    }, 30000); // Her 30 saniyede bir g√ºncelle
    
    // Otomatik ba≈ülatma (1 saniye gecikmeyle)
    setTimeout(() => {
        window.app.osiris.activate();
    }, 1000);
});

// Chart overlay signals
function createChartSignalOverlay() {
    const overlay = document.createElement('div');
    overlay.id = 'chart-signal-overlay';
    overlay.innerHTML = `
        <div style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);z-index:1100;pointer-events:none;display:flex;gap:10px;flex-wrap:wrap;">
            <div id="ai-signal" style="background:rgba(16,185,129,0.9);color:white;padding:4px 8px;border-radius:4px;font-size:11px;font-weight:bold;display:none;">
                ü§ñ AI: <span id="ai-signal-text">--</span>
            </div>
            <div id="osiris-signal" style="background:rgba(59,130,246,0.9);color:white;padding:4px 8px;border-radius:4px;font-size:11px;font-weight:bold;display:none;">
                üõ°Ô∏è OSIRIS: <span id="osiris-signal-text">--</span>
            </div>
            <div id="trend-signal" style="background:rgba(251,191,36,0.9);color:white;padding:4px 8px;border-radius:4px;font-size:11px;font-weight:bold;display:none;">
                üìà TREND: <span id="trend-signal-text">--</span>
            </div>
        </div>
    `;
    document.body.appendChild(overlay);
}

// Signal update functions
function updateChartSignals(aiSignal, osirisSignal, trendSignal) {
    if (aiSignal) {
        document.getElementById('ai-signal-text').textContent = aiSignal;
        document.getElementById('ai-signal').style.display = 'block';
        setTimeout(() => document.getElementById('ai-signal').style.display = 'none', 5000);
    }
    
    if (osirisSignal) {
        document.getElementById('osiris-signal-text').textContent = osirisSignal;
        document.getElementById('osiris-signal').style.display = 'block';
        setTimeout(() => document.getElementById('osiris-signal').style.display = 'none', 5000);
    }
    
    if (trendSignal) {
        document.getElementById('trend-signal-text').textContent = trendSignal;
        document.getElementById('trend-signal').style.display = 'block';
        setTimeout(() => document.getElementById('trend-signal').style.display = 'none', 5000);
    }
}

function createOSIRISPanel() {
    const panel = document.createElement('div');
    panel.id = 'osiris-panel';
    panel.innerHTML = `
        <div style="position:fixed;top:20px;right:20px;z-index:1500;width:260px;background:rgba(13,17,23,0.92);border:1px solid #3b82f6;border-radius:8px;padding:12px;font-family:'Roboto Mono',monospace;font-size:12px;color:#e2e8f0;backdrop-filter:blur(8px);transition:all 0.3s ease;" id="osiris-main-panel">
            <div style="display:flex;align-items:center;gap:8px;margin-bottom:10px;color:#3b82f6;font-weight:bold;cursor:pointer;" onclick="toggleOSIRISPanel()">
                üõ°Ô∏è OSIRIS SENTINEL
                <div style="flex:1;height:1px;background:linear-gradient(90deg,#3b82f6,transparent);"></div>
                <span id="osiris-toggle" style="font-size:14px;">‚àí</span>
            </div>
            <div id="osiris-content" style="transition:all 0.3s ease;">
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px;">
                    <div>Risk: <span id="osiris-risk-level" class="risk-level low">LOW</span></div>
                    <div>Threats: <span id="osiris-threat-count">0</span></div>
                    <div>Cyber Bees: <span id="osiris-bee-status">0/0</span></div>
                    <div>Status: <span style="color:#10b981;">ACTIVE</span></div>
                </div>
                <div style="font-size:10px;opacity:0.7;text-align:center;">
                    Real-time threat detection & anomaly analysis
                </div>
            </div>
        </div>
    `;
    document.body.appendChild(panel);
    
    // Toggle fonksiyonu
    window.toggleOSIRISPanel = function() {
        const content = document.getElementById('osiris-content');
        const toggle = document.getElementById('osiris-toggle');
        const mainPanel = document.getElementById('osiris-main-panel');
        
        if (content.style.maxHeight === '0px') {
            content.style.maxHeight = '200px';
            content.style.opacity = '1';
            toggle.textContent = '‚àí';
            mainPanel.style.height = 'auto';
        } else {
            content.style.maxHeight = '0px';
            content.style.opacity = '0';
            toggle.textContent = '+';
            mainPanel.style.height = '40px';
        }
    };
}
</script>
<!-- Yeni Navigasyon ve Grafik G√∂r√ºn√ºm Y√∂netimi i√ßin JS -->
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Navigasyon butonlarƒ± i√ßin event listeners
        const navItems = document.querySelectorAll('.nav-item');
        navItems.forEach(item => {
            item.addEventListener('click', function() {
                // Aktif butonun stilini g√ºncelle
                navItems.forEach(btn => btn.classList.remove('active'));
                this.classList.add('active');
                
                // ƒ∞lgili g√∂r√ºn√ºm√º g√∂ster
                const viewId = this.getAttribute('data-view');
                const views = document.querySelectorAll('.content-view');
                views.forEach(view => view.classList.remove('active'));
                document.getElementById(viewId + '-view').classList.add('active');
                
                // √ñzel g√∂r√ºn√ºm i≈ülemlerini √ßalƒ±≈ütƒ±r
                handleViewChange(viewId);
            });
        });
        
        // ƒ∞lk y√ºkleme i√ßin ana grafik g√∂r√ºn√ºm√ºn√º aktif yap
        document.querySelector('[data-view="chart"]').classList.add('active');
        
        // Grafik kontrolleri i√ßin event listeners
        const chartZoomIn = document.querySelector('.chart-btn[title="Yakƒ±nla≈ütƒ±r"]');
        const chartZoomOut = document.querySelector('.chart-btn[title="Uzakla≈ütƒ±r"]');
        const chartFullscreen = document.querySelector('.chart-btn[title="Tam Ekran"]');
        
        if (chartZoomIn) chartZoomIn.addEventListener('click', () => {
            if (window.app && window.app.chartManager) window.app.chartManager.zoomIn();
        });
        
        if (chartZoomOut) chartZoomOut.addEventListener('click', () => {
            if (window.app && window.app.chartManager) window.app.chartManager.zoomOut();
        });
        
        if (chartFullscreen) chartFullscreen.addEventListener('click', toggleFullscreen);
        
        // Baƒülantƒ± durumu g√ºncelleme (√∂rnek)
        updateConnectionStatus(true);
        
        // Fiyat g√ºncelleme i√ßin interval
        setInterval(simulatePriceUpdate, 2000);
        
        // Grafik olu≈üturma
        initializeChart();
    });
    
    // G√∂r√ºn√ºm deƒüi≈üikliƒüini y√∂netme
    function handleViewChange(viewId) {
        console.log('View changed to:', viewId);
        switch(viewId) {
            case 'chart':
                // Grafik g√∂r√ºn√ºm√ºnde √∂zel i≈ülemler
                if (window.app && window.app.chartManager) {
                    window.app.chartManager.resetZoom();
                }
                break;
            case 'panteon':
                // Panteon i√ßeriƒüini panteon-view i√ßine ta≈üƒ±
                const panteonContent = document.getElementById('panteon-panel');
                document.getElementById('panteon-view').innerHTML = '';
                document.getElementById('panteon-view').appendChild(panteonContent.cloneNode(true));
                break;
            case 'kehanet':
                // Kehanet i√ßeriƒüini kehanet-view i√ßine ta≈üƒ±
                const kehanetContent = document.getElementById('kehanet-panel');
                document.getElementById('kehanet-view').innerHTML = '';
                document.getElementById('kehanet-view').appendChild(kehanetContent.cloneNode(true));
                break;
            // Diƒüer g√∂r√ºn√ºmler i√ßin i≈ülemler eklenebilir
        }
    }
    
    // Baƒülantƒ± durumunu g√ºncelleme
    function updateConnectionStatus(isConnected) {
        const statusIndicator = document.querySelector('.connection-status');
        if (isConnected) {
            statusIndicator.classList.add('online');
            statusIndicator.classList.remove('offline');
            statusIndicator.title = 'Baƒülantƒ± Aktif';
        } else {
            statusIndicator.classList.remove('online');
            statusIndicator.classList.add('offline');
            statusIndicator.title = 'Baƒülantƒ± Kesildi';
        }
    }
    
    // Demo fiyat g√ºncellemesi (ger√ßek sistemde WebSocket ile deƒüi≈ütirilecek)
    function simulatePriceUpdate() {
        const currentPrice = parseFloat(document.getElementById('ticker-price').textContent);
        const change = (Math.random() - 0.5) * 2; // -1 ile +1 arasƒ±
        const newPrice = (currentPrice + change).toFixed(2);
        
        document.getElementById('ticker-price').textContent = newPrice;
        
        // Fiyat renklendirme
        if (change > 0) {
            document.getElementById('ticker-price').style.color = 'var(--success)';
        } else if (change < 0) {
            document.getElementById('ticker-price').style.color = 'var(--danger)';
        }
        
        // 2 saniye sonra rengi normale d√∂nd√ºr
        setTimeout(() => {
            document.getElementById('ticker-price').style.color = '';
        }, 1000);
    }
    
    // Tam ekran ge√ßi≈üi
    function toggleFullscreen() {
        const chartView = document.getElementById('chart-view');
        
        if (!document.fullscreenElement) {
            if (chartView.requestFullscreen) {
                chartView.requestFullscreen();
            } else if (chartView.webkitRequestFullscreen) {
                chartView.webkitRequestFullscreen();
            } else if (chartView.msRequestFullscreen) {
                chartView.msRequestFullscreen();
            }
            document.querySelector('.chart-btn[title="Tam Ekran"]').textContent = '‚õ∂';
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
            document.querySelector('.chart-btn[title="Tam Ekran"]').textContent = '‚õ∂';
        }
    }
    
    // Grafik olu≈üturma
    function initializeChart() {
        const chartContainer = document.getElementById('chart-container');
        
        // LightweightCharts ile grafik olu≈ütur
        const chart = LightweightCharts.createChart(chartContainer, {
            width: chartContainer.clientWidth,
            height: chartContainer.clientHeight,
            layout: {
                background: { color: 'rgba(22, 27, 34, 0.2)' },
                textColor: '#D9D9D9',
                fontSize: 12,
                fontFamily: 'Roboto Mono'
            },
            grid: {
                vertLines: { color: 'rgba(42, 46, 57, 0.5)' },
                horzLines: { color: 'rgba(42, 46, 57, 0.5)' }
            },
            timeScale: {
                timeVisible: true,
                secondsVisible: false,
                borderColor: 'rgba(197, 203, 206, 0.3)',
            },
            crosshair: {
                mode: LightweightCharts.CrosshairMode.Normal,
                vertLine: {
                    color: 'rgba(197, 203, 206, 0.5)',
                    width: 1,
                    style: LightweightCharts.LineStyle.Solid,
                    labelBackgroundColor: '#171B26',
                },
                horzLine: {
                    color: 'rgba(197, 203, 206, 0.5)',
                    width: 1,
                    style: LightweightCharts.LineStyle.Solid,
                    labelBackgroundColor: '#171B26',
                }
            }
        });
        
        // Pencere boyutu deƒüi≈üince grafiƒüi g√ºncelle
        window.addEventListener('resize', () => {
            chart.resize(
                chartContainer.clientWidth,
                chartContainer.clientHeight
            );
        });
        
        // Mum serisi olu≈ütur
        const candleSeries = chart.addCandlestickSeries({
            upColor: '#26a69a',
            downColor: '#ef5350',
            borderVisible: false,
            wickUpColor: '#26a69a',
            wickDownColor: '#ef5350'
        });
        
        // √ñrnek veri - ger√ßek uygulamada API'den alƒ±nacak
        const demoData = generateDemoData(100);
        candleSeries.setData(demoData);
        
        // Hacim serisi ekle
        const volumeSeries = chart.addHistogramSeries({
            color: '#26a69a',
            priceFormat: {
                type: 'volume',
            },
            priceScaleId: '',
            scaleMargins: {
                top: 0.8,
                bottom: 0,
            },
        });
        
        const volumeData = demoData.map(item => ({
            time: item.time,
            value: item.volume,
            color: item.close > item.open ? '#26a69a' : '#ef5350'
        }));
        
        volumeSeries.setData(volumeData);
        
        // Global eri≈üim i√ßin
        window.chart = chart;
        window.candleSeries = candleSeries;
        window.volumeSeries = volumeSeries;
        
        // Demo sinyaller ekle
        setTimeout(() => {
            candleSeries.setMarkers([
                { time: demoData[10].time, position: 'belowBar', color: '#2196F3', shape: 'arrowUp', text: 'AL' },
                { time: demoData[20].time, position: 'aboveBar', color: '#FF5252', shape: 'arrowDown', text: 'SAT' },
                { time: demoData[30].time, position: 'belowBar', color: '#2196F3', shape: 'arrowUp', text: 'AL' },
                { time: demoData[40].time, position: 'belowBar', color: '#66BB6A', shape: 'circle', text: 'TP' },
                { time: demoData[50].time, position: 'belowBar', color: '#2196F3', shape: 'arrowUp', text: 'AL' }
            ]);
        }, 1000);
    }
    
    // Demo mum verileri olu≈ütur
    function generateDemoData(count) {
        const data = [];
        let time = new Date(Date.UTC(2023, 0, 1, 0, 0, 0, 0));
        let price = 200;
        let volume = 1000;
        
        for (let i = 0; i < count; i++) {
            const volatility = 3; // Volatilite (fiyat deƒüi≈ükenliƒüi)
            const rnd = Math.random() - 0.5; // -0.5 ile 0.5 arasƒ±nda rastgele deƒüer
            const change = volatility * rnd;
            
            const open = price;
            const close = open + change;
            const high = Math.max(open, close) + Math.abs(change) * 0.2 * Math.random();
            const low = Math.min(open, close) - Math.abs(change) * 0.2 * Math.random();
            const volumeChange = (1 + (Math.random() - 0.5) * 0.3) * volume;
            
            data.push({
                time: time.getTime() / 1000,
                open: open,
                high: high,
                low: low,
                close: close,
                volume: volumeChange
            });
            
            // Bir sonraki mum i√ßin deƒüerleri g√ºncelle
            price = close;
            time = new Date(time.getTime() + 3600000); // 1 saat ekle
            volume = volumeChange;
        }
        
        return data;
    }
</script>
<!-- Yan Men√º ve Panel Etkile≈üimleri i√ßin JS -->
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Yan men√º butonlarƒ±nƒ± se√ß
        const sideMenuBtns = document.querySelectorAll('.side-menu-item');
        const notificationsToggle = document.getElementById('notifications-toggle');
        const energyToggle = document.getElementById('energy-toggle');
        const ritualToggle = document.getElementById('ritual-toggle');
        const osirisToggle = document.getElementById('osiris-toggle');
        const logsToggle = document.getElementById('logs-toggle');
        const themeToggle = document.getElementById('theme-toggle');
        const helpToggle = document.getElementById('help-toggle');
        
        // Panel kapatma butonlarƒ±nƒ± se√ß
        const closePanelBtns = document.querySelectorAll('.close-panel');
        
        // Aktif paneli izleme
        let activePanel = null;
        
        // Bildirim paneli toggle fonksiyonu
        notificationsToggle.addEventListener('click', function() {
            togglePanel('notification-panel', this);
        });
        
        // Diƒüer panel toggle'larƒ± (enerji, rit√ºel, vb.)
        // ƒ∞lgili paneller yapƒ±ldƒ±ƒüƒ±nda etkinle≈ütirilecek
        energyToggle.addEventListener('click', function() {
            alert('Enerji Paneli yapƒ±m a≈üamasƒ±nda!');
            // togglePanel('energy-panel', this);
        });
        
        ritualToggle.addEventListener('click', function() {
            alert('Rit√ºel Sistemi yapƒ±m a≈üamasƒ±nda!');
            // togglePanel('ritual-panel', this);
        });
        
        osirisToggle.addEventListener('click', function() {
            alert('OSIRIS Sistemi yapƒ±m a≈üamasƒ±nda!');
            // togglePanel('osiris-panel', this);
        });
        
        logsToggle.addEventListener('click', function() {
            alert('Log Paneli yapƒ±m a≈üamasƒ±nda!');
            // togglePanel('logs-panel', this);
        });
        
        // Tema deƒüi≈ütirme
        themeToggle.addEventListener('click', function() {
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            
            // Tema deƒüi≈üimi animasyonu
            document.body.classList.add('theme-transition');
            setTimeout(() => {
                document.body.classList.remove('theme-transition');
            }, 1000);
            
            // ƒ∞kon g√ºncelleme
            this.querySelector('.side-icon').textContent = newTheme === 'dark' ? 'üåì' : 'üåí';
        });
        
        // Yardƒ±m
        helpToggle.addEventListener('click', function() {
            alert('Ultimate Trading War Room v3.0\n\nGeli≈ütirici: Tech Army Team\nS√ºr√ºm: 3.0.5\n\nDaha fazla bilgi i√ßin d√∂k√ºmantasyona bakƒ±nƒ±z.');
        });
        
        // Panel kapatma butonlarƒ±
        closePanelBtns.forEach(btn => {
            btn.addEventListener('click', function() {
                const panel = this.closest('.side-panel');
                if (panel) {
                    panel.classList.remove('active');
                    // ƒ∞lgili butonun aktif durumunu kaldƒ±r
                    const panelId = panel.id;
                    const relatedBtn = document.querySelector(`[data-target="${panelId}"]`) || 
                                      document.querySelector(`#${panelId.replace('-panel', '-toggle')}`);
                    
                    if (relatedBtn) {
                        relatedBtn.classList.remove('active');
                    }
                    
                    activePanel = null;
                }
            });
        });
        
        // Panel ge√ßi≈üi
        function togglePanel(panelId, button) {
            const panel = document.getElementById(panelId);
            
            // √ñnceki aktif paneli kapat
            if (activePanel && activePanel !== panel) {
                activePanel.classList.remove('active');
                
                // √ñnceki aktif butonun aktifliƒüini kaldƒ±r
                const prevButton = document.querySelector(`[data-target="${activePanel.id}"]`) || 
                                 document.querySelector(`#${activePanel.id.replace('-panel', '-toggle')}`);
                if (prevButton) {
                    prevButton.classList.remove('active');
                }
            }
            
            // Panel ge√ßi≈üi
            if (panel) {
                const isActive = panel.classList.toggle('active');
                button.classList.toggle('active', isActive);
                
                activePanel = isActive ? panel : null;
                
                // Panel a√ßƒ±ldƒ±ƒüƒ±nda bildirimleri temizle
                if (isActive && panelId === 'notification-panel') {
                    clearNotificationBadge();
                }
            }
        }
        
        // Demo bildirimleri g√∂ster
        setTimeout(() => {
            showNotification('Yeni sinyal: SOL/USDT i√ßin AL sinyali olu≈ütu', 'success');
        }, 3000);
        
        setTimeout(() => {
            showNotification('Volatilite Uyarƒ±sƒ±: BTC volatilitesi y√ºkseliyor', 'warning');
        }, 7000);
        
        // Bildirim g√∂sterme fonksiyonu
        function showNotification(message, type = 'info') {
            // Bildirim sayƒ±sƒ±nƒ± arttƒ±r
            updateNotificationBadge(1);
            
            // Bildirim toast'u olu≈ütur
            const toast = document.createElement('div');
            toast.className = `notification-toast ${type}`;
            toast.innerHTML = `
                <div class="notification-toast-icon">${getNotificationIcon(type)}</div>
                <div class="notification-toast-content">${message}</div>
                <button class="notification-toast-close">‚úñ</button>
            `;
            
            // Toast'u ekle
            document.body.appendChild(toast);
            
            // Animasyon i√ßin setTimeout
            setTimeout(() => {
                toast.classList.add('show');
            }, 10);
            
            // Otomatik kapanma
            const timeout = setTimeout(() => {
                closeNotificationToast(toast);
            }, 5000);
            
            // Kapatma butonu
            const closeBtn = toast.querySelector('.notification-toast-close');
            closeBtn.addEventListener('click', () => {
                clearTimeout(timeout);
                closeNotificationToast(toast);
            });
        }
        
        // Bildirim kapatma fonksiyonu
        function closeNotificationToast(toast) {
            toast.classList.remove('show');
            setTimeout(() => {
                toast.remove();
            }, 300);
        }
        
        // Bildirim sayacƒ±nƒ± g√ºncelle
        function updateNotificationBadge(increment = 1) {
            const badge = document.querySelector('.notification-badge');
            if (badge) {
                let count = parseInt(badge.textContent) || 0;
                count += increment;
                badge.textContent = count;
                badge.style.display = count > 0 ? 'flex' : 'none';
            }
        }
        
        // Bildirim sayacƒ±nƒ± sƒ±fƒ±rla
        function clearNotificationBadge() {
            const badge = document.querySelector('.notification-badge');
            if (badge) {
                badge.textContent = '0';
                badge.style.display = 'none';
            }
        }
        
        // Bildirim ikonlarƒ±
        function getNotificationIcon(type) {
            switch(type) {
                case 'success': return '‚úÖ';
                case 'warning': return '‚ö†Ô∏è';
                case 'danger': return '‚ùå';
                case 'info':
                default: return '‚ÑπÔ∏è';
            }
        }
        
        // Toast bildirimleri i√ßin CSS olu≈ütur
        const style = document.createElement('style');
        style.textContent = `
            .notification-toast {
                position: fixed;
                top: 70px;
                right: 15px;
                min-width: 280px;
                max-width: 350px;
                background: rgba(22, 27, 34, 0.9);
                backdrop-filter: blur(10px);
                border-left: 4px solid var(--primary);
                border-radius: 5px;
                padding: 12px 15px;
                display: flex;
                align-items: center;
                gap: 12px;
                box-shadow: 0 5px 15px rgba(0,0,0,0.3);
                transform: translateX(120%);
                opacity: 0;
                transition: transform 0.3s ease, opacity 0.3s ease;
                z-index: 9999;
                font-family: 'Roboto Mono', monospace;
            }
            
            .notification-toast.show {
                transform: translateX(0);
                opacity: 1;
            }
            
            .notification-toast.success {
                border-left-color: var(--success);
            }
            
            .notification-toast.warning {
                border-left-color: var(--warning);
            }
            
            .notification-toast.danger {
                border-left-color: var(--danger);
            }
            
            .notification-toast.info {
                border-left-color: var(--info);
            }
            
            .notification-toast-icon {
                flex-shrink: 0;
                width: 24px;
                height: 24px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 14px;
            }
            
            .notification-toast-content {
                flex-grow: 1;
                font-size: 13px;
            }
            
            .notification-toast-close {
                background: transparent;
                border: none;
                color: var(--text-secondary);
                cursor: pointer;
                font-size: 12px;
                padding: 3px;
                border-radius: 3px;
                transition: all 0.2s ease;
                flex-shrink: 0;
            }
            
            .notification-toast-close:hover {
                background: rgba(255,255,255,0.1);
                color: var(--danger);
            }
            
            /* Tema ge√ßi≈ü animasyonu */
            .theme-transition {
                transition: background-color 0.5s ease, color 0.5s ease;
            }
            
            /* Birden fazla toast olduƒüunda konumlandƒ±rma */
            .notification-toast:nth-child(1) { top: 70px; }
            .notification-toast:nth-child(2) { top: 140px; }
            .notification-toast:nth-child(3) { top: 210px; }
            .notification-toast:nth-child(4) { top: 280px; }
            .notification-toast:nth-child(5) { top: 350px; }
            
            /* Mobil uyumluluk */
            @media screen and (max-width: 768px) {
                .notification-toast {
                    min-width: unset;
                    width: calc(100% - 30px);
                    max-width: calc(100% - 30px);
                }
            }
        `;
        document.head.appendChild(style);
    });
</script>
<script>
// Grafik olu≈üturma ve y√∂netimi
function initializeChart() {
    const chartContainer = document.getElementById('chart-container');
    if (!chartContainer) return;
    
    // Eƒüer LightweightCharts y√ºkl√ºyse grafik olu≈ütur
    if (typeof LightweightCharts !== 'undefined') {
        // Grafik olu≈ütur
        const chart = LightweightCharts.createChart(chartContainer, {
            width: chartContainer.clientWidth,
            height: chartContainer.clientHeight,
            layout: {
                background: {
                    type: 'solid',
                    color: 'var(--panel-bg)',
                },
                textColor: 'var(--text-main)',
            },
            grid: {
                vertLines: {
                    color: 'rgba(42, 46, 57, 0.5)',
                },
                horzLines: {
                    color: 'rgba(42, 46, 57, 0.5)',
                },
            },
            timeScale: {
                timeVisible: true,
                secondsVisible: false,
            },
            crosshair: {
                mode: LightweightCharts.CrosshairMode.Normal,
            },
            rightPriceScale: {
                borderColor: 'var(--border-color)',
            },
        });
        
        // Mum serisini olu≈ütur
        const candlestickSeries = chart.addCandlestickSeries({
            upColor: 'var(--success)',
            downColor: 'var(--danger)',
            borderDownColor: 'var(--danger)',
            borderUpColor: 'var(--success)',
            wickDownColor: 'var(--danger)',
            wickUpColor: 'var(--success)',
        });
        
        // Hacim serisini olu≈ütur
        const volumeSeries = chart.addHistogramSeries({
            color: 'rgba(59, 130, 246, 0.5)',
            priceFormat: {
                type: 'volume',
            },
            priceScaleId: '',
            scaleMargins: {
                top: 0.8,
                bottom: 0,
            },
        });
        
        // Pencere boyut deƒüi≈üikliƒüi durumunda grafiƒüi yeniden boyutlandƒ±r
        function handleResize() {
            if (chart) {
                chart.applyOptions({
                    width: chartContainer.clientWidth,
                    height: chartContainer.clientHeight,
                });
            }
        }
        
        window.addEventListener('resize', handleResize);
        
        // Demo verileri y√ºkle
        const demoData = generateDemoData(100);
        candlestickSeries.setData(demoData);
        
        // Hacim verilerini ayarla
        const volumeData = demoData.map(item => ({
            time: item.time,
            value: item.volume,
            color: item.close > item.open ? 'rgba(16, 185, 129, 0.5)' : 'rgba(239, 68, 68, 0.5)',
        }));
        volumeSeries.setData(volumeData);
        
        // Global eri≈üim i√ßin
        window.chart = chart;
        window.candleSeries = candlestickSeries;
        window.volumeSeries = volumeSeries;
        
        // √ñrnek sinyal i≈üaretleri
        setTimeout(() => {
            candlestickSeries.setMarkers([
                {
                    time: demoData[10].time,
                    position: 'belowBar',
                    color: 'var(--success)',
                    shape: 'arrowUp',
                    text: 'AL',
                },
                {
                    time: demoData[30].time,
                    position: 'aboveBar',
                    color: 'var(--danger)',
                    shape: 'arrowDown',
                    text: 'SAT',
                },
                {
                    time: demoData[50].time,
                    position: 'belowBar',
                    color: 'var(--success)',
                    shape: 'arrowUp',
                    text: 'AL',
                },
                {
                    time: demoData[80].time,
                    position: 'aboveBar',
                    color: 'var(--danger)',
                    shape: 'arrowDown',
                    text: 'SAT',
                },
            ]);
        }, 1000);
    } else {
        console.error('LightweightCharts k√ºt√ºphanesi y√ºklenemedi!');
        chartContainer.innerHTML = '<div style="display:flex;justify-content:center;align-items:center;height:100%;color:var(--danger);">Grafik k√ºt√ºphanesi y√ºklenemedi!</div>';
    }
}

// Demo mum verileri olu≈ütur
function generateDemoData(count) {
    const data = [];
    let time = new Date(Date.UTC(2023, 0, 1, 0, 0, 0, 0));
    let price = 35000;
    let volume = 1000;
    
    for (let i = 0; i < count; i++) {
        const volatility = Math.random() * 200 + 100;
        const open = price;
        const close = price + (Math.random() - 0.5) * volatility;
        const high = Math.max(open, close) + Math.random() * volatility * 0.5;
        const low = Math.min(open, close) - Math.random() * volatility * 0.5;
        
        data.push({
            time: Math.floor(time.getTime() / 1000),
            open: open,
            high: high,
            low: low,
            close: close,
            volume: volume + Math.floor(Math.random() * 1000),
        });
        
        price = close;
        volume = volume + Math.floor((Math.random() - 0.5) * 500);
        if (volume < 500) volume = 500;
        
        time.setDate(time.getDate() + 1);
    }
    
    return data;
}

// DOM y√ºklendiƒüinde grafik ba≈ülatƒ±lƒ±r
document.addEventListener('DOMContentLoaded', function() {
    initializeChart();
});
</script>
<script>
/* JavaScript hata d√ºzeltmeleri i√ßin global fonksiyonlar */
window.fixDuplicateIds = function() {
    // Tekrarlanan ID'leri d√ºzelt
    const kehanetPanels = document.querySelectorAll('[id="kehanet-panel"]');
    if (kehanetPanels.length > 1) {
        kehanetPanels[0].id = 'kehanet-panel-main';
        kehanetPanels[1].id = 'kehanet-panel-secondary';
        
        // Toggle butonlarƒ±nƒ± da g√ºncelle
        const toggles = document.querySelectorAll('[id="kp-toggle"]');
        if (toggles.length > 1) {
            toggles[0].id = 'kp-toggle-main';
            toggles[1].id = 'kp-toggle-secondary';
        }
        
        // Content alanlarƒ±nƒ± da g√ºncelle
        const contents = document.querySelectorAll('[id="kp-content"]');
        if (contents.length > 1) {
            contents[0].id = 'kp-content-main';
            contents[1].id = 'kp-content-secondary';
        }
        
        console.log('Duplicate IDs fixed successfully');
    }
};

// Sayfa y√ºklendiƒüinde ID d√ºzeltmelerini √ßalƒ±≈ütƒ±r
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', window.fixDuplicateIds);
} else {
    window.fixDuplicateIds();
}
</script>
</html>