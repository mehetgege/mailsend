<!DOCTYPE html>
<html lang="tr" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ULTIMATE TRADING WAR ROOM v3.0 | SAVAŞ ÜSSÜ</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@300;400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
    <!-- TSParticles for visual effects -->
    <script src="https://cdn.jsdelivr.net/npm/tsparticles-slim@2.12.0/tsparticles.slim.bundle.min.js"></script>
    <!-- TensorFlow.js for Machine Learning -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <!-- ML.js for additional ML algorithms -->
    <script src="https://cdn.jsdelivr.net/npm/ml-matrix@6.10.4/lib/ml-matrix.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ml-regression@6.0.1/lib/ml-regression.min.js"></script>
    <style>
    /* Yeni Tasarım Değişkenleri */
    :root {
        /* Temel Renkler */
        --metatron-color: #64B5F6;  /* Mavi - Bilgelik */
        --uriel-color: #FFA726;     /* Turuncu - Cesaret */
        --raphael-color: #81C784;   /* Yeşil - Şifa */
        --gabriel-color: #BA68C8;   /* Mor - İletişim */
        --michael-color: #EF5350;   /* Kırmızı - Savaş */
        
        /* UI Ana Değişkenler */
        --header-height: 50px;      /* Üst menü yüksekliği */
        --menu-width: 60px;         /* Yan menü genişliği */
        --menu-expanded-width: 250px; /* Genişletilmiş yan menü */
        --chart-padding: 10px;      /* Grafik etrafındaki boşluk */
        --animation-speed: 0.3s;    /* Standart animasyon hızı */
        
        /* Tema Değişkenleri - Dark Theme */
        --background: #131722;
        --panel-bg: #1c2230;
        --text-main: #e1e2e6;
        --text-secondary: #9ca3af;
        --border-color: #2a2e39;
        --input-bg: #171b26;
        --hover-bg: #22283a;
        --primary: #3b82f6;
        --primary-rgb: 59, 130, 246;
        --primary-light: #60a5fa;
        --primary-dark: #2563eb;
        
        /* Durum Renkleri */
        --success: #10b981;
        --success-rgb: 16, 185, 129;
        --danger: #ef4444;
        --danger-rgb: 239, 68, 68;
        --warning: #f59e0b;
        --warning-rgb: 245, 158, 11;
        --info: #3b82f6;
        --info-rgb: 59, 130, 246;
        
        /* Özel UI Renkleri */
        --card-gradient: linear-gradient(145deg, #1c2230, #181e2a);
        --shadow-small: 0 2px 5px rgba(0,0,0,0.2);
        --shadow-medium: 0 4px 10px rgba(0,0,0,0.3);
        --shadow-large: 0 10px 25px rgba(0,0,0,0.4);
    }
    
    /* Açık Tema */
    [data-theme="light"] {
        --background: #f1f5f9;
        --panel-bg: #ffffff;
        --text-main: #1e293b;
        --text-secondary: #64748b;
        --border-color: #e2e8f0;
        --input-bg: #f8fafc;
        --hover-bg: #e2e8f0;
        --primary: #3b82f6;
        --primary-rgb: 59, 130, 246;
        --primary-light: #60a5fa;
        --primary-dark: #2563eb;
        
        --success: #10b981;
        --success-rgb: 16, 185, 129;
        --danger: #ef4444;
        --danger-rgb: 239, 68, 68;
        --warning: #f59e0b;
        --warning-rgb: 245, 158, 11;
        --info: #3b82f6;
        --info-rgb: 59, 130, 246;
        
        --card-gradient: linear-gradient(145deg, #ffffff, #f8fafc);
        --shadow-small: 0 2px 5px rgba(0,0,0,0.05);
        --shadow-medium: 0 4px 10px rgba(0,0,0,0.1);
        --shadow-large: 0 10px 25px rgba(0,0,0,0.15);
    }
    
    /* Savaş Modu */
    [data-theme="war"] {
        --background: #1a0a0a;
        --panel-bg: #240d0d;
        --text-main: #ffd700;
        --text-secondary: #ff9e45;
        --border-color: #4d1a1a;
        --input-bg: #2d1010;
        --hover-bg: #3a1515;
        --primary: #ff4500;
        --primary-rgb: 255, 69, 0;
        --primary-light: #ff6a33;
        --primary-dark: #cc3700;
        
        --success: #ffd700;
        --success-rgb: 255, 215, 0;
        --danger: #ff0000;
        --danger-rgb: 255, 0, 0;
        --warning: #ff8c00;
        --warning-rgb: 255, 140, 0;
        --info: #ff4500;
        --info-rgb: 255, 69, 0;
        
        --card-gradient: linear-gradient(145deg, #240d0d, #1d0808);
        --shadow-small: 0 2px 5px rgba(255,0,0,0.2);
        --shadow-medium: 0 4px 10px rgba(255,0,0,0.3);
        --shadow-large: 0 10px 25px rgba(255,0,0,0.4);
    }
    
    /* YENİ EMOJİ STICKER BAR STİLLERİ */
    .emoji-sticker-bar {
        display: flex;
        align-items: center;
        gap: 8px;
        flex: 1;
        justify-content: center;
        max-width: 600px;
        margin: 0 auto;
    }
    
    .sticker-item {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 48px;
        height: 24px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 20px;
        cursor: pointer;
        transition: all 0.3s ease;
        padding: 2px 8px;
        user-select: none;
    }
    
    .sticker-item:hover {
        background: rgba(255, 255, 255, 0.15);
        border-color: var(--primary);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
    }
    
    .sticker-item.active {
        background: rgba(59, 130, 246, 0.2);
        border-color: var(--primary);
        box-shadow: 0 0 8px rgba(59, 130, 246, 0.3);
    }
    
    .sticker-emoji {
        font-size: 16px;
        filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));
    }
    
    /* Mini Göstergeler */
    .notification-badge, .signal-badge {
        position: absolute;
        top: -4px;
        right: -4px;
        background: var(--danger);
        color: white;
        font-size: 9px;
        font-weight: bold;
        min-width: 14px;
        height: 14px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        animation: pulse-badge 2s infinite;
    }
    
    @keyframes pulse-badge {
        0% { transform: scale(1); }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); }
    }
    
    .mini-energy-bar {
        position: absolute;
        bottom: -8px;
        left: 50%;
        transform: translateX(-50%);
        width: 30px;
        height: 2px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 1px;
        overflow: hidden;
    }
    
    .mini-energy-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--warning), var(--success));
        border-radius: 1px;
        transition: width 0.5s ease;
    }
    
    .mini-power-indicator {
        position: absolute;
        bottom: -6px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 2px;
    }
    
    .power-dot {
        width: 4px;
        height: 4px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.3);
        transition: background 0.3s ease;
    }
    
    .power-dot.active {
        background: var(--primary);
        box-shadow: 0 0 4px var(--primary);
    }
    
    .mini-confidence-circle {
        position: absolute;
        bottom: -8px;
        left: 50%;
        transform: translateX(-50%);
        width: 16px;
        height: 16px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.3);
    }
    
    .confidence-text {
        font-size: 8px;
        font-weight: bold;
        color: var(--text-primary);
    }
    
    /* Ana Menü Sistemi */
    .main-menu-container {
        position: fixed;
        top: 0;
        left: 0;
        z-index: 2000;
    }
    
    .menu-toggle-btn {
        position: fixed;
        top: 15px;
        left: 15px;
        z-index: 2001;
        width: 40px;
        height: 40px;
        background: var(--panel-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        backdrop-filter: blur(4px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }
    
    .menu-toggle-btn:hover {
        background: var(--hover-bg);
        border-color: var(--primary);
        transform: translateY(-1px);
    }
    
    .menu-icon {
        font-size: 18px;
        transition: transform 0.3s ease;
    }
    
    .menu-toggle-btn.active .menu-icon {
        transform: rotate(90deg);
    }
    
    .main-menu {
        position: fixed;
        top: 0;
        left: -350px;
        width: 340px;
        height: 100vh;
        background: var(--panel-bg);
        border-right: 1px solid var(--border-color);
        box-shadow: 2px 0 15px rgba(0, 0, 0, 0.3);
        transition: left 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 2000;
        overflow-y: auto;
        backdrop-filter: blur(8px);
    }
    
    .main-menu.open {
        left: 0;
    }
    
    #panteon-panel{
        position: fixed;
        top: 20px;
        left: 20px; /* Sol üste taşı */
        z-index: 1200;
        width: 320px; /* Biraz küçült */
        background: rgba(22,27,34,0.95);
        backdrop-filter: blur(6px);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        font-family: 'Roboto Mono', monospace;
        color: var(--text-main);
        box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        transition: all 0.3s ease;
        overflow: hidden;
    }
    #panteon-panel .pp-title{
        display: flex; 
        align-items: center; 
        justify-content: space-between; 
        padding: 10px 15px; 
        font-size: 15px; 
        font-weight: 600; 
        border-bottom: 1px solid var(--border-color);
        background: rgba(0,0,0,0.2);
        color: var(--yellow);
    }
    #panteon-panel .pp-body{
        padding: 0;
        max-height: 70vh;
        overflow-y: auto;
    }
    
    /* Panteon İstatistikleri */
    .panteon-stats {
        display: flex;
        justify-content: space-between;
        padding: 8px 12px;
        background: rgba(0,0,0,0.15);
        border-bottom: 1px solid var(--border-color);
        font-size: 13px;
    }
    
    .regime-indicator, .state-indicator {
        display: flex;
        gap: 8px;
    }
    
    .current-regime {
        color: var(--uriel-color);
        font-weight: 600;
    }
    
    .collective-state {
        color: var(--metatron-color);
        font-weight: 600;
    }
    
    /* Panteon Panel İyileştirmeler */
    .panteon-panel {
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 10px;
    }
    
    /* Elçi Kartları */
    .ambassador {
        background: rgba(0,0,0,0.2);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        padding: 10px;
        transition: all 0.3s ease;
        position: relative;
    }
    
    .ambassador.active {
        border-color: var(--accent-color);
    }
    
    .ambassador.inactive {
        opacity: 0.6;
        filter: grayscale(0.7);
    }
    
    /* Elçi Mod Renklendirmeleri */
    .ambassador[data-mode="İNANÇLI"] {
        border-left: 4px solid var(--green);
    }
    
    .ambassador[data-mode="ŞÜPHECİ"] {
        border-left: 4px solid var(--yellow);
    }
    
    .ambassador[data-mode="KIYAMET"] {
        border-left: 4px solid var(--red);
    }
    
    /* Elçi Rol Renklendirmeleri */
    .ambassador[data-role="wisdom"] .ambassador-name {
        color: var(--metatron-color);
    }
    
    .ambassador[data-role="courage"] .ambassador-name {
        color: var(--uriel-color);
    }
    
    .ambassador[data-role="healing"] .ambassador-name {
        color: var(--raphael-color);
    }
    
    .ambassador[data-role="communication"] .ambassador-name {
        color: var(--gabriel-color);
    }
    
    .ambassador[data-role="warfare"] .ambassador-name {
        color: var(--michael-color);
    }
    
    /* Elçi Başlık */
    .ambassador-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 6px;
    }
    
    .ambassador-name {
        font-weight: 600;
        font-size: 15px;
    }
    
    .ambassador-toggle {
        width: 22px;
        height: 22px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(255,255,255,0.1);
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .ambassador-toggle:hover {
        background: rgba(255,255,255,0.2);
    }
    
    /* Elçi Bilgileri */
    .ambassador-info {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        margin-bottom: 8px;
    }
    
    .ambassador-role {
        opacity: 0.7;
    }
    
    .ambassador-status {
        display: flex;
        gap: 10px;
    }
    
    .ambassador-mode {
        font-weight: 600;
    }
    
    .ambassador[data-mode="İNANÇLI"] .ambassador-mode {
        color: var(--green);
    }
    
    .ambassador[data-mode="ŞÜPHECİ"] .ambassador-mode {
        color: var(--yellow);
    }
    
    .ambassador[data-mode="KIYAMET"] .ambassador-mode {
        color: var(--red);
    }
    
    .reputation {
        opacity: 0.8;
    }
    
    .reputation-score {
        font-weight: 600;
    }
    
    /* İlerleme Çubukları */
    .progress-container {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-bottom: 8px;
    }
    
    .confidence, .power {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 12px;
    }
    
    .confidence span, .power span {
        width: 45px;
        opacity: 0.7;
    }
    
    .confidence-bar, .power-bar {
        flex: 1;
        height: 6px;
        background: rgba(255,255,255,0.1);
        border-radius: 3px;
        overflow: hidden;
        position: relative;
    }
    
    .confidence-level {
        height: 100%;
        background: linear-gradient(90deg, var(--yellow), var(--green));
        border-radius: 3px;
        font-size: 9px;
        display: flex;
        align-items: center;
        justify-content: flex-end;
        padding-right: 4px;
        color: rgba(0,0,0,0.7);
        transition: width 0.5s ease;
    }
    
    .power-level {
        height: 100%;
        background: linear-gradient(90deg, var(--accent-color), var(--accent-color-bright));
        border-radius: 3px;
        transition: width 0.5s ease;
    }
    
    /* Strateji Seçim Butonları */
    .strategy-select {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
        margin-top: 5px;
    }
    
    .strategy-select button {
        background: rgba(0,0,0,0.3);
        border: 1px solid var(--border-color);
        color: var(--text-secondary);
        font-size: 11px;
        padding: 3px 8px;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .strategy-select button:hover {
        background: rgba(255,255,255,0.1);
    }
    
    .strategy-select button.active {
        background: rgba(var(--accent-color-rgb), 0.3);
        border-color: var(--accent-color);
        color: var(--accent-color-bright);
    }
    
    /* Yetenek Düğmeleri */
    .pantheon-abilities {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-top: 10px;
        padding: 10px;
        border-top: 1px solid var(--border-color);
    }
    
    .pantheon-ability {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        cursor: pointer;
        transition: all 0.2s ease;
        padding: 8px;
        border-radius: 6px;
        width: 90px;
    }
    
    .pantheon-ability:hover {
        background: rgba(255,255,255,0.05);
    }
    
    .pantheon-ability.ready {
        border: 1px solid rgba(var(--accent-color-rgb), 0.5);
    }
    
    .pantheon-ability.cooldown {
        opacity: 0.6;
        border: 1px solid rgba(255,255,255,0.1);
    }
    
    .ability-icon {
        font-size: 18px;
    }
    
    .ability-name {
        font-size: 12px;
        font-weight: 600;
    }
    
    .cooldown-indicator {
        font-size: 10px;
        opacity: 0.7;
    }
    
    /* Aktif Konsey Efektleri */
    .pp-power-fill {
        height: 100%;
        border-radius: 2px;
        transition: width 0.5s ease;
    }
    #amb-metatron .pp-power-fill { background: var(--metatron-color, #3b82f6); }
    #amb-uriel .pp-power-fill { background: var(--uriel-color, #ef4444); }
    #amb-raphael .pp-power-fill { background: var(--raphael-color, #10b981); }
    #amb-gabriel .pp-power-fill { background: var(--gabriel-color, #a855f7); }
    #amb-michael .pp-power-fill { background: var(--michael-color, #f97316); }
    
    .pp-expand-btn {
        background: transparent;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        padding: 0;
        font-size: 12px;
        opacity: 0.7;
        transition: all 0.2s ease;
    }
    .pp-expand-btn:hover {
        opacity: 1;
        color: var(--primary);
    }
    
    .pp-collective-state {
        font-size: 11px;
        display: flex;
        align-items: center;
    }
    .pp-state-label {
        color: var(--text-secondary);
        margin-right: 5px;
    }
    .pp-state-value {
        font-weight: bold;
    }
    
    .pp-actions {
        display: flex;
        gap: 5px;
    }
    .pp-action-btn {
        background: transparent;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        padding: 4px;
        font-size: 12px;
        opacity: 0.7;
        transition: all 0.2s ease;
        border-radius: 3px;
    }
    .pp-action-btn:hover {
        opacity: 1;
        color: var(--primary);
        background: var(--bg-tertiary);
    }
    
    /* Renk değişkenleri - Elçi renkleri */
    :root {
        --metatron-color: #3b82f6; /* Mavi - Bilgelik */
        --uriel-color: #ef4444;    /* Kırmızı - Cesaret */
        --raphael-color: #10b981;  /* Yeşil - Şifa */
        --gabriel-color: #a855f7;  /* Mor - İletişim */
        --michael-color: #f97316;  /* Turuncu - Savaş */
    }
    
    /* Kehanet Paneli (sağ alt) */
    #kehanet-panel{ 
        position: fixed; 
        right: 10px; 
        bottom: 12px; 
        z-index: 1200; 
        width: 260px; 
        background: rgba(22,27,34,0.9); 
        backdrop-filter: blur(4px); 
        border: 1px solid var(--border-color); 
        border-radius: 6px; 
        font-family: 'Roboto Mono', monospace; 
        color: var(--text-main); 
        box-shadow: 0 2px 10px rgba(0,0,0,0.35);
        transition: all 0.3s ease;
    }
    #kehanet-panel .kp-title{ 
        display: flex; 
        align-items: center; 
        justify-content: space-between; 
        padding: 8px 10px; 
        border-bottom: 1px solid var(--border-color); 
        font-weight: 700; 
        font-size: 12px; 
        color: var(--primary); 
        user-select: none; 
    }
    #kehanet-panel .kp-body{ 
        padding: 8px 10px; 
        display: grid; 
        gap: 6px; 
        font-size: 12px; 
    }
    #kehanet-panel .kp-footer {
        border-top: 1px solid var(--border-color);
        padding: 8px 10px;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    .kp-row{ 
        display: flex; 
        align-items: center; 
        justify-content: space-between;
        padding: 2px 0;
    }
    .kp-key{ 
        color: var(--text-secondary); 
    }
    .kp-val{ 
        font-weight: 700; 
    }
    .kp-divider {
        height: 1px;
        background: var(--border-color);
        margin: 4px 0;
        opacity: 0.6;
    }
    .kp-advanced {
        display: none;
        opacity: 0;
        transform: translateY(-10px);
        transition: all 0.3s ease;
    }
    .kp-panel-expanded .kp-advanced {
        display: grid;
        gap: 6px;
        opacity: 1;
        transform: translateY(0);
    }
    .kp-panel-expanded {
        width: 320px;
        height: auto;
    }
    .kp-expand-btn {
        background: transparent;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        padding: 0;
        font-size: 12px;
        opacity: 0.7;
        transition: all 0.2s ease;
    }
    .kp-expand-btn:hover {
        opacity: 1;
        color: var(--primary);
    }
    .kp-chart-container {
        margin-top: 6px;
        height: 70px;
        background: var(--bg-tertiary);
        border-radius: 4px;
        overflow: hidden;
        border: 1px solid var(--border-color);
    }
    .kp-mini-chart {
        width: 100%;
        height: 100%;
    }
    .kp-confidence-bar {
        flex: 1;
        height: 6px;
        background: var(--bg-tertiary);
        border-radius: 3px;
        overflow: hidden;
        position: relative;
        margin-right: 10px;
    }
    .kp-confidence-fill {
        height: 100%;
        width: 75%;
        background: linear-gradient(90deg, var(--warning) 0%, var(--success) 100%);
        border-radius: 3px;
        transition: width 0.5s ease;
    }
    .kp-confidence-label {
        position: absolute;
        top: -16px;
        right: 5px;
        font-size: 9px;
        color: var(--text-secondary);
    }
    .kp-refresh-btn {
        background: transparent;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        padding: 0;
        font-size: 14px;
        opacity: 0.7;
        transition: all 0.2s ease;
    }
    .kp-refresh-btn:hover {
        opacity: 1;
        color: var(--primary);
        transform: rotate(180deg);
    }
    .prediction-refresh {
        animation: prediction-pulse 0.8s ease-out;
    }
    @keyframes prediction-pulse {
        0% { box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.3); }
        70% { box-shadow: 0 0 0 15px rgba(139, 92, 246, 0); }
        100% { box-shadow: 0 0 0 0 rgba(139, 92, 246, 0); }
    }
    .trend-up { color: var(--success); }
    .trend-down { color: var(--danger); }
    .trend-neutral { color: var(--warning); }
    
    /* tsParticles katmanı (İlk Işık ve diğer efektler için) */
    #cosmic-effects-layer{
        position: fixed; 
        inset: 0; 
        z-index: 3000; 
        pointer-events: none;
    }
    
    /* Enerji Kutusu Stilleri */
    .energy-box {
        position: fixed;
        bottom: 70px;
        right: 10px;
        width: 250px;
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        box-shadow: 0 0 20px rgba(0, 170, 255, 0.3);
        z-index: 999;
        padding: 10px;
        color: var(--text-primary);
        transition: all 0.3s ease;
    }
    
    .energy-box-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 5px;
    }
    
    .energy-box-title {
        font-family: var(--primary-font);
        font-size: 14px;
        font-weight: bold;
        color: var(--info);
        margin: 0;
    }
    
    .energy-box-close {
        cursor: pointer;
        opacity: 0.7;
        transition: opacity 0.2s;
        color: var(--text-secondary);
    }
    
    .energy-box-close:hover {
        opacity: 1;
    }
    
    .energy-meter {
        width: 100%;
        height: 15px;
        background: var(--bg-tertiary);
        border-radius: 10px;
        overflow: hidden;
        margin: 5px 0;
        position: relative;
    }
    
    .energy-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--info) 0%, var(--success) 100%);
        border-radius: 10px;
        width: 75%;
        transition: width 1s ease;
        position: relative;
    }
    
    .energy-fill::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.2) 50%, rgba(255,255,255,0) 100%);
        animation: energy-pulse 2s infinite;
    }
    
    @keyframes energy-pulse {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(100%); }
    }
    
    .energy-info {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        color: var(--text-secondary);
        margin-bottom: 10px;
    }
    
    .energy-actions {
        display: flex;
        justify-content: space-between;
        margin-top: 5px;
        gap: 5px;
    }
    
    .energy-action-btn {
        flex: 1;
        background: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        color: var(--text-primary);
        padding: 5px;
        font-size: 11px;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
        text-align: center;
    }
    
    .energy-action-btn:hover {
        background: var(--hover-bg);
        border-color: var(--primary);
    }
    
    .energy-low {
        box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
    }
    
    .energy-low .energy-fill {
        background: linear-gradient(90deg, #ff3366 0%, #ffaa00 100%);
    }
    
    .energy-status {
        text-align: center;
        font-size: 11px;
        color: var(--text-secondary);
        margin: 5px 0;
        padding: 2px;
        border-radius: 3px;
        background: var(--bg-tertiary);
    }

    /* Mobil uyumluluk */
    @media screen and (max-width: 768px){
        #panteon-panel{ 
            width: 90vw !important;
            left: 5vw !important;
            top: 10px !important;
        }
        #kehanet-panel{
            width: 90vw !important;
            right: 5vw !important;
            bottom: 10px !important;
        }
        #osiris-main-panel{
            width: 90vw !important;
            right: 5vw !important;
            top: 70px !important;
        }
    }
        }
        .energy-box {
            bottom: 120px;
            width: 200px;
        }
    }
    </style>
    <script>
    // Emoji Güvenlik Sistemi - Çekirdek Sınıf
    class EmojiSecuritySystem {
        constructor() {
            this.securityLevel = 'normal';
            this.activeThreats = [];
            this.notifications = [];
            this.confidence = 75;
            this.energy = 80;
            this.signalStrength = 65;
            this.powerLevel = 70;
            this.analyticsData = {
                risk: 'medium',
                signals: 15,
                accuracy: 78
            };
            this.init();
        }

        init() {
            this.createEmojiBar();
            this.bindEmojiEvents();
            this.startSecurityMonitoring();
            this.updateAllStickers();
        }

        createEmojiBar() {
            const existingBar = document.querySelector('.emoji-sticker-bar');
            if (existingBar) {
                existingBar.innerHTML = this.generateEmojiBarHTML();
            }
        }

        generateEmojiBarHTML() {
            return `
                <div class="sticker-item" data-type="notifications" title="Bildirimler">
                    <span class="sticker-emoji">📢</span>
                    <div class="notification-badge" id="notif-badge">3</div>
                    <div class="mini-energy-bar">
                        <div class="mini-energy-fill" style="width: 60%"></div>
                    </div>
                </div>
                
                <div class="sticker-item" data-type="security" title="Güvenlik Seviyesi">
                    <span class="sticker-emoji">🛡️</span>
                    <div class="signal-badge" id="security-badge">⚠️</div>
                    <div class="mini-power-indicator">
                        <div class="power-dot active"></div>
                        <div class="power-dot active"></div>
                        <div class="power-dot active"></div>
                        <div class="power-dot"></div>
                        <div class="power-dot"></div>
                    </div>
                </div>
                
                <div class="sticker-item" data-type="signals" title="Sinyal Gücü">
                    <span class="sticker-emoji">📡</span>
                    <div class="mini-confidence-circle">
                        <span class="confidence-text">78</span>
                    </div>
                </div>
                
                <div class="sticker-item" data-type="analytics" title="Analitik">
                    <span class="sticker-emoji">📊</span>
                    <div class="mini-energy-bar">
                        <div class="mini-energy-fill" style="width: 85%"></div>
                    </div>
                </div>
                
                <div class="sticker-item" data-type="energy" title="Enerji Seviyesi">
                    <span class="sticker-emoji">⚡</span>
                    <div class="mini-power-indicator">
                        <div class="power-dot active"></div>
                        <div class="power-dot active"></div>
                        <div class="power-dot active"></div>
                        <div class="power-dot active"></div>
                        <div class="power-dot"></div>
                    </div>
                </div>
                
                <div class="sticker-item" data-type="ai" title="AI Durumu">
                    <span class="sticker-emoji">🤖</span>
                    <div class="signal-badge" id="ai-badge">ON</div>
                </div>
                
                <div class="sticker-item" data-type="market" title="Piyasa Durumu">
                    <span class="sticker-emoji">📈</span>
                    <div class="mini-confidence-circle">
                        <span class="confidence-text">↗</span>
                    </div>
                </div>
            `;
        }

        bindEmojiEvents() {
            document.querySelectorAll('.sticker-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    const type = item.dataset.type;
                    this.handleEmojiClick(type, item);
                });
                
                item.addEventListener('mouseenter', (e) => {
                    this.showQuickInfo(item);
                });
            });
        }

        handleEmojiClick(type, element) {
            element.classList.add('active');
            setTimeout(() => element.classList.remove('active'), 300);

            switch(type) {
                case 'notifications':
                    this.toggleNotificationDetails();
                    break;
                case 'security':
                    this.showSecurityReport();
                    break;
                case 'signals':
                    this.showSignalAnalysis();
                    break;
                case 'analytics':
                    this.openAnalyticsDashboard();
                    break;
                case 'energy':
                    this.showEnergyManagement();
                    break;
                case 'ai':
                    this.toggleAISystem();
                    break;
                case 'market':
                    this.showMarketOverview();
                    break;
            }
        }

        updateAllStickers() {
            this.updateNotificationSticker();
            this.updateSecuritySticker();
            this.updateSignalSticker();
            this.updateEnergySticker();
            this.updateAISticker();
            this.updateMarketSticker();
        }

        updateNotificationSticker() {
            const badge = document.getElementById('notif-badge');
            if (badge) {
                badge.textContent = this.notifications.length;
                badge.style.display = this.notifications.length > 0 ? 'flex' : 'none';
            }
        }

        updateSecuritySticker() {
            const badge = document.getElementById('security-badge');
            const powerDots = document.querySelectorAll('[data-type="security"] .power-dot');
            
            if (badge) {
                const level = this.getSecurityLevel();
                badge.textContent = level === 'high' ? '🟢' : level === 'medium' ? '🟡' : '🔴';
            }
            
            const activeCount = Math.floor((this.confidence / 100) * 5);
            powerDots.forEach((dot, index) => {
                dot.classList.toggle('active', index < activeCount);
            });
        }

        updateEnergySticker() {
            const powerDots = document.querySelectorAll('[data-type="energy"] .power-dot');
            const activeCount = Math.floor((this.energy / 100) * 5);
            
            powerDots.forEach((dot, index) => {
                dot.classList.toggle('active', index < activeCount);
            });
        }

        showQuickInfo(element) {
            const type = element.dataset.type;
            const tooltip = document.createElement('div');
            tooltip.className = 'sticker-tooltip';
            tooltip.style.cssText = `
                position: absolute;
                bottom: 100%;
                left: 50%;
                transform: translateX(-50%);
                background: var(--panel-bg);
                border: 1px solid var(--border-color);
                border-radius: 4px;
                padding: 4px 8px;
                font-size: 10px;
                white-space: nowrap;
                z-index: 1000;
                margin-bottom: 5px;
            `;
            
            const info = this.getQuickInfo(type);
            tooltip.textContent = info;
            
            element.style.position = 'relative';
            element.appendChild(tooltip);
            
            setTimeout(() => {
                if (tooltip.parentNode) {
                    tooltip.parentNode.removeChild(tooltip);
                }
            }, 2000);
        }

        getQuickInfo(type) {
            const infos = {
                notifications: `${this.notifications.length} yeni bildirim`,
                security: `Güvenlik: ${this.getSecurityLevel()}`,
                signals: `Sinyal gücü: ${this.signalStrength}%`,
                analytics: `Risk seviyesi: ${this.analyticsData.risk}`,
                energy: `Enerji: ${this.energy}%`,
                ai: 'AI sistemi aktif',
                market: 'Piyasa: Yükseliş eğilimi'
            };
            return infos[type] || 'Bilgi yok';
        }

        getSecurityLevel() {
            if (this.confidence > 80) return 'high';
            if (this.confidence > 50) return 'medium';
            return 'low';
        }

        startSecurityMonitoring() {
            setInterval(() => {
                this.updateSecurityMetrics();
                this.updateAllStickers();
            }, 3000);
        }

        updateSecurityMetrics() {
            // Rastgele değişimler simüle et
            this.confidence += (Math.random() - 0.5) * 5;
            this.energy += (Math.random() - 0.5) * 3;
            this.signalStrength += (Math.random() - 0.5) * 4;
            
            // Sınırları koru
            this.confidence = Math.max(0, Math.min(100, this.confidence));
            this.energy = Math.max(0, Math.min(100, this.energy));
            this.signalStrength = Math.max(0, Math.min(100, this.signalStrength));
        }

        toggleNotificationDetails() {
            console.log('Bildirim detayları açılıyor...');
            if (window.app && window.app.showNotification) {
                window.app.showNotification('Bildirim sistemi açıldı', 'info');
            }
        }

        showSecurityReport() {
            console.log('Güvenlik raporu gösteriliyor...');
            if (window.app && window.app.showNotification) {
                window.app.showNotification(`Güvenlik seviyesi: ${this.getSecurityLevel()}`, 'info');
            }
        }

        showSignalAnalysis() {
            console.log('Sinyal analizi açılıyor...');
            if (window.app && window.app.showNotification) {
                window.app.showNotification(`Sinyal gücü: ${this.signalStrength.toFixed(0)}%`, 'info');
            }
        }

        openAnalyticsDashboard() {
            console.log('Analytics dashboard açılıyor...');
        }

        showEnergyManagement() {
            console.log('Enerji yönetimi açılıyor...');
            if (window.app && window.app.showNotification) {
                window.app.showNotification(`Enerji seviyesi: ${this.energy.toFixed(0)}%`, 'info');
            }
        }

        toggleAISystem() {
            console.log('AI sistemi toggle edildi');
            if (window.app && window.app.showNotification) {
                window.app.showNotification('AI sistemi yeniden başlatıldı', 'success');
            }
        }

        showMarketOverview() {
            console.log('Piyasa genel durumu gösteriliyor...');
        }
    }

    // IndexedDB Yardımcı Sınıfları
    class IDBUtil {
        static promisifyRequest(req) {
            return new Promise((resolve, reject) => {
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }
    }
    
    // IndexedDB Yönetici Sınıfı - Panteon için
    class PanteonDBManager {
        constructor() {
            this.db = null;
            this.DB_NAME = 'UTC_PANTHEON_DB';
            this.DB_VERSION = 1;
        }
        
        static get instance() {
            if(!window.__panteonDbMan) {
                window.__panteonDbMan = new PanteonDBManager();
            }
            return window.__panteonDbMan;
        }
        
        async open() {
            if(this.db) return this.db;
            const req = indexedDB.open(this.DB_NAME, this.DB_VERSION);
            
            req.onupgradeneeded = (ev) => {
                const db = ev.target.result;
                if(!db.objectStoreNames.contains('settings')) db.createObjectStore('settings', { keyPath: 'id' });
                if(!db.objectStoreNames.contains('panteon')) db.createObjectStore('panteon', { keyPath: 'id' });
                if(!db.objectStoreNames.contains('strategyStats')) db.createObjectStore('strategyStats', { keyPath: 'strategyKey' });
                if(!db.objectStoreNames.contains('signals')) {
                    const s = db.createObjectStore('signals', { keyPath: 'id', autoIncrement: true });
                    s.createIndex('byTimestamp','timestamp',{unique:false});
                    s.createIndex('bySymbol','symbol',{unique:false});
                    s.createIndex('byStatus','status',{unique:false});
                    s.createIndex('byDirection','direction',{unique:false});
                }
                if(!db.objectStoreNames.contains('notifications')) {
                    const n = db.createObjectStore('notifications', { keyPath: 'id', autoIncrement: true });
                    n.createIndex('byTimestamp','timestamp',{unique:false});
                    n.createIndex('byType','type',{unique:false});
                }
                if(!db.objectStoreNames.contains('kv')) db.createObjectStore('kv', { keyPath: 'key' });
                if(!db.objectStoreNames.contains('meta')) db.createObjectStore('meta', { keyPath: 'key' });
            };
            
            this.db = await IDBUtil.promisifyRequest(req);
            return this.db;
        }
        
        store(name, mode='readonly') {
            const tx = this.db.transaction(name, mode);
            return tx.objectStore(name);
        }
        
        async getPanteonState() {
            await this.open();
            const res = await IDBUtil.promisifyRequest(this.store('panteon').get('state'));
            return res?.data || this._panteonDefaults();
        }
        
        async setPanteonState(data) {
            await this.open();
            await IDBUtil.promisifyRequest(this.store('panteon','readwrite').put({
                id: 'state',
                data,
                updatedAt: Date.now()
            }));
            return true;
        }
        
        _panteonDefaults() {
            return {
                zeus: { role: 'creator' },
                env: { createdAt: Date.now(), version: '3.2' },
                ambassadors: {
                    Metatron: { reputation: 0, mode: 'İnançlı' },
                    Uriel: { reputation: 0, mode: 'İnançlı' },
                    Raphael: { reputation: 0, mode: 'İnançlı' }
                },
                lastDormancyPenaltyAt: null
            };
        }
    }
    
    // Görsel Efektler Yöneticisi
    class EffectsManager {
        constructor() {
            this.layerId = 'cosmic-effects-layer';
            this.ensureLayer();
            this.effects = {
                firstLight: { cooldown: 5000, lastUsed: 0 },
                prediction: { cooldown: 3000, lastUsed: 0 },
                horseman: { cooldown: 10000, lastUsed: 0 },
                confluence: { cooldown: 2000, lastUsed: 0 }
            };
        }
        
        ensureLayer() {
            if(!document.getElementById(this.layerId)) {
                const d = document.createElement('div');
                d.id = this.layerId;
                d.style.position = 'fixed';
                d.style.inset = '0';
                d.style.zIndex = '3000';
                d.style.pointerEvents = 'none';
                document.body.appendChild(d);
            }
        }
        
        async ensureTsParticles() {
            if(window.tsParticles) return;
            await new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = 'https://cdn.jsdelivr.net/npm/tsparticles@3/tsparticles.bundle.min.js';
                s.async = true;
                s.onload = () => resolve(true);
                s.onerror = () => reject(new Error('tsParticles yüklenemedi'));
                document.head.appendChild(s);
            });
        }
        
        checkCooldown(effectName) {
            const effect = this.effects[effectName];
            if (!effect) return true;
            
            const now = Date.now();
            if (now - effect.lastUsed < effect.cooldown) {
                return false;
            }
            
            effect.lastUsed = now;
            return true;
        }
        
        async firstLight(duration=2200) {
            try {
                if (!this.checkCooldown('firstLight')) return null;
                
                await this.ensureTsParticles();
                const config = {
                    background: { color: 'transparent' },
                    fullScreen: { enable: false },
                    particles: { number: { value: 0 } },
                    emitters: {
                        position: { x: 50, y: 50 },
                        rate: { delay: 0.01, quantity: 60 },
                        life: { duration: duration/1000, count: 1 },
                        particles: {
                            move: { enable: true, speed: {min: 10, max: 40}, outModes: 'destroy' },
                            color: { value: ['#ffffff','#7dd3fc','#60a5fa'] },
                            shape: { type: 'circle' },
                            size: { value: {min: 1, max: 3} },
                            opacity: { value: {min: 0.2, max: 0.8} },
                            wobble: { enable: true, distance: 5, speed: 20 },
                            shadow: { enable: true, blur: 6, color: '#a5f3fc' }
                        }
                    }
                };
                
                const container = await window.tsParticles.load('cosmic-effects-layer', config);
                setTimeout(() => {
                    try { container?.destroy(); } catch {}
                }, duration + 250);
                
                return container;
            } catch(e) {
                const el = document.createElement('div');
                el.style.position = 'absolute';
                el.style.inset = '0';
                el.style.background = 'radial-gradient(circle at center, rgba(255,255,255,0.9), rgba(96,165,250,0.5), rgba(2,6,23,0))';
                el.style.animation = 'firstLightPulse 1.8s ease-out forwards';
                
                const st = document.createElement('style');
                st.textContent = `
                    @keyframes firstLightPulse {
                        0% { opacity: 0; transform: scale(0.6); filter: blur(4px); }
                        25% { opacity: 1; transform: scale(1.0); filter: blur(2px); }
                        100% { opacity: 0; transform: scale(1.8); filter: blur(8px); }
                    }
                `;
                
                document.head.appendChild(st);
                document.getElementById(this.layerId).appendChild(el);
                
                setTimeout(() => {
                    try { el.remove(); } catch {}
                }, 2000);
                
                console.error('firstLight effect error:', e);
                return null;
            }
        }
        
        async showPredictionEffect(duration=2000) {
            try {
                if (!this.checkCooldown('prediction')) return null;
                
                await this.ensureTsParticles();
                
                // Kehanet Paneli elemanını bul
                const kehanetPanel = document.getElementById('kehanet-panel');
                if (!kehanetPanel) return null;
                
                // Panel koordinatlarını al
                const rect = kehanetPanel.getBoundingClientRect();
                const x = (rect.left + rect.right) / 2;
                const y = (rect.top + rect.bottom) / 2;
                
                // Efekt ayarları
                const config = {
                    background: { color: 'transparent' },
                    fullScreen: { enable: false },
                    particles: { number: { value: 0 } },
                    emitters: {
                        position: { x: (x / window.innerWidth) * 100, y: (y / window.innerHeight) * 100 },
                        rate: { delay: 0.01, quantity: 30 },
                        life: { duration: duration/1000, count: 1 },
                        particles: {
                            move: { 
                                enable: true, 
                                speed: {min: 1, max: 3},
                                outModes: 'destroy',
                                direction: 'out',
                                straight: false,
                                bounce: false
                            },
                            color: { value: ['#a855f7','#3b82f6','#06b6d4'] },
                            shape: { type: 'circle' },
                            size: { value: {min: 1, max: 4} },
                            opacity: { value: {min: 0.3, max: 0.8} },
                            life: { duration: {min: 1, max: 3} },
                            roll: { 
                                enable: true,
                                speed: 3
                            },
                            wobble: { 
                                enable: true, 
                                distance: 3,
                                speed: 10
                            },
                            tilt: {
                                enable: true,
                                direction: 'random',
                                value: {
                                    min: 0,
                                    max: 360
                                },
                                animation: {
                                    enable: true,
                                    speed: 10
                                }
                            },
                            shadow: { 
                                enable: true, 
                                blur: 3,
                                color: '#a5f3fc' 
                            }
                        }
                    }
                };
                
                const container = await window.tsParticles.load('cosmic-effects-layer', config);
                setTimeout(() => {
                    try { container?.destroy(); } catch {}
                }, duration);
                
                return container;
            } catch(e) {
                console.error('prediction effect error:', e);
                return null;
            }
        }
        
        async showHorsemanEffect(horseman, duration=3500) {
            try {
                if (!this.checkCooldown('horseman')) return null;
                
                await this.ensureTsParticles();
                
                // Atlı tipine göre renkleri ve efekt tipini belirle
                let colors, emitterShape, speed, particleShape;
                
                switch(horseman) {
                    case 'KITLIK':
                        colors = ['#fbbf24', '#f59e0b', '#d97706']; // Sarı/Turuncu
                        emitterShape = 'square';
                        speed = {min: 1, max: 3};
                        particleShape = 'square';
                        break;
                    case 'SALGIN':
                        colors = ['#10b981', '#059669', '#047857']; // Yeşil
                        emitterShape = 'circle';
                        speed = {min: 2, max: 5};
                        particleShape = 'circle';
                        break;
                    case 'SAVAŞ':
                        colors = ['#ef4444', '#dc2626', '#b91c1c']; // Kırmızı
                        emitterShape = 'triangle';
                        speed = {min: 5, max: 15};
                        particleShape = 'triangle';
                        break;
                    case 'ÖLÜM':
                        colors = ['#8b5cf6', '#7c3aed', '#6d28d9']; // Mor
                        emitterShape = 'star';
                        speed = {min: 10, max: 25};
                        particleShape = 'polygon';
                        break;
                    default:
                        colors = ['#ffffff', '#e2e8f0', '#cbd5e1']; // Beyaz/Gri
                        emitterShape = 'circle';
                        speed = {min: 3, max: 8};
                        particleShape = 'circle';
                }
                
                // Efekt konfigürasyonu
                const config = {
                    background: { color: 'transparent' },
                    fullScreen: { enable: true },
                    particles: { 
                        number: { value: 0 },
                        move: {
                            enable: true,
                            speed: speed,
                            direction: 'random',
                            outModes: 'out'
                        },
                        opacity: {
                            value: {min: 0.3, max: 0.7}
                        },
                        size: {
                            value: {min: 1, max: 5}
                        },
                        color: {
                            value: colors
                        },
                        shape: {
                            type: particleShape
                        },
                        life: {
                            duration: {min: 1, max: duration/1000}
                        }
                    },
                    emitters: {
                        direction: 'random',
                        position: {
                            x: 50,
                            y: 50
                        },
                        rate: {
                            delay: 0.1,
                            quantity: 5
                        },
                        size: {
                            width: 100,
                            height: 100
                        },
                        life: {
                            duration: duration/1000 - 0.5,
                            count: 1
                        }
                    }
                };
                
                const container = await window.tsParticles.load('cosmic-effects-layer', config);
                setTimeout(() => {
                    try { container?.destroy(); } catch {}
                }, duration);
                
                return container;
            } catch(e) {
                console.error('horseman effect error:', e);
                return null;
            }
        }
        
        async showConfluenceEffect(position, signalType, duration=1500) {
            try {
                if (!this.checkCooldown('confluence')) return null;
                
                await this.ensureTsParticles();
                
                // Sinyal tipine göre renkleri belirle
                let colors;
                if (signalType === 'BUY') {
                    colors = ['#22c55e', '#16a34a', '#15803d']; // Yeşil tonları
                } else if (signalType === 'SELL') {
                    colors = ['#ef4444', '#dc2626', '#b91c1c']; // Kırmızı tonları
                } else {
                    colors = ['#3b82f6', '#2563eb', '#1d4ed8']; // Mavi tonları (nötr/bilgi)
                }
                
                // Pozisyon bilgisi
                const x = position?.x || 50;
                const y = position?.y || 50;
                
                // Efekt konfigürasyonu
                const config = {
                    background: { color: 'transparent' },
                    fullScreen: { enable: false },
                    particles: { number: { value: 0 } },
                    emitters: {
                        position: { x, y },
                        rate: { delay: 0.01, quantity: 20 },
                        life: { duration: duration/1000, count: 1 },
                        particles: {
                            move: { 
                                enable: true, 
                                speed: {min: 3, max: 7},
                                outModes: 'destroy',
                                direction: 'none',
                                gravity: { 
                                    enable: true,
                                    acceleration: 0.2
                                },
                                trail: {
                                    enable: true,
                                    fillColor: '#000',
                                    length: 4
                                }
                            },
                            color: { value: colors },
                            shape: { type: 'circle' },
                            size: { value: {min: 2, max: 5} },
                            opacity: { 
                                value: {min: 0.4, max: 0.8},
                                animation: {
                                    enable: true,
                                    speed: 1,
                                    minimumValue: 0,
                                    destroy: 'min'
                                }
                            },
                            life: { duration: {min: 0.5, max: 1.5} },
                            rotate: {
                                enable: true,
                                value: {
                                    min: 0,
                                    max: 360
                                },
                                animation: {
                                    enable: true,
                                    speed: 5
                                }
                            },
                            shadow: { 
                                enable: true, 
                                blur: 5,
                                color: colors[0]
                            }
                        }
                    }
                };
                
                const container = await window.tsParticles.load('cosmic-effects-layer', config);
                setTimeout(() => {
                    try { container?.destroy(); } catch {}
                }, duration);
                
                return container;
            } catch(e) {
                console.error('confluence effect error:', e);
                return null;
            }
        }
    }
    
    // IndexedDB yardımcıları - Panteon için
    async function openDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open('coinank_data', 2);
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                
                // Panteon durumu için object store
                if (!db.objectStoreNames.contains('panteon_state')) {
                    db.createObjectStore('panteon_state');
                }
                
                // Diğer store'lar burada eklenebilir
            };
            
            request.onsuccess = (event) => {
                resolve({
                    db: event.target.result,
                    get: async (store, key) => {
                        return new Promise((resolve, reject) => {
                            const transaction = event.target.result.transaction(store, 'readonly');
                            const objectStore = transaction.objectStore(store);
                            const getRequest = objectStore.get(key);
                            
                            getRequest.onsuccess = () => {
                                resolve(getRequest.result);
                            };
                            
                            getRequest.onerror = (error) => {
                                reject(error);
                            };
                        });
                    },
                    put: async (store, value, key) => {
                        return new Promise((resolve, reject) => {
                            const transaction = event.target.result.transaction(store, 'readwrite');
                            const objectStore = transaction.objectStore(store);
                            const putRequest = objectStore.put(value, key);
                            
                            putRequest.onsuccess = () => {
                                resolve(putRequest.result);
                            };
                            
                            putRequest.onerror = (error) => {
                                reject(error);
                            };
                        });
                    },
                    delete: async (store, key) => {
                        return new Promise((resolve, reject) => {
                            const transaction = event.target.result.transaction(store, 'readwrite');
                            const objectStore = transaction.objectStore(store);
                            const deleteRequest = objectStore.delete(key);
                            
                            deleteRequest.onsuccess = () => {
                                resolve();
                            };
                            
                            deleteRequest.onerror = (error) => {
                                reject(error);
                            };
                        });
                    }
                });
            };
            
            request.onerror = (event) => {
                reject(event.target.error);
            };
        });
    }
    
    // Panteon Bootstrap
    async function bootstrapPantheon() {
        if(!('indexedDB' in window)) {
            console.error('IndexedDB desteklenmiyor. Geçici bellek modu.');
        }
        
        const db = DBManager.instance;
        await db.open();
        
        // İlk Işık Efekti
        const fx = new EffectsManager();
        await fx.firstLight(2200);
        
        // UI mitolojik isimlendirme (buton/metin güncellemeleri)
        const renameUI = () => {
            const honorBtn = document.getElementById('honor-board-btn'); 
            if(honorBtn) honorBtn.textContent = 'Panteon';
            
            const bannedBtn = document.getElementById('banned-board-btn'); 
            if(bannedBtn) bannedBtn.textContent = 'Zindan';
            
            const saveBtn = document.getElementById('save-settings-btn'); 
            if(saveBtn) saveBtn.textContent = 'Kaderi Mühürle';
            
            const resetBtn = document.getElementById('reset-all-settings-btn'); 
            if(resetBtn) resetBtn.textContent = 'Evreni Sıfırla';
            
            const mobileHonor = document.getElementById('mobile-honor-board-btn'); 
            if(mobileHonor) mobileHonor.textContent = '🏛️';
            
            const mobileBanned = document.getElementById('mobile-banned-board-btn'); 
            if(mobileBanned) mobileBanned.textContent = 'ZDN';
            
            const settingsTitle = document.querySelector('.settings-modal-header span'); 
            if(settingsTitle) settingsTitle.textContent = 'AMELİYATHANE & OPTİMİZASYON';
            
            const clearSignals = document.getElementById('modal-clear-signals-btn'); 
            if(clearSignals) clearSignals.textContent = 'Kurban Et';
        };
        
        // Panteon panelini persist edilen değerlerle başlat
        const initPanteonPanel = async () => {
            const state = await db.getPanteonState();
            const envEl = document.getElementById('pp-env'); 
            if(envEl) envEl.textContent = state.env?.version || 'v3.2';
            
            const setAmb = (id, data) => {
                const root = document.getElementById(id);
                if(!root) return;
                
                const rep = root.querySelector('.pp-rep'); 
                if(rep) {
                    rep.textContent = String(data.reputation ?? 0);
                    rep.dataset.rep = String(data.reputation ?? 0);
                }
                
                const mode = root.querySelector('.pp-mode'); 
                if(mode) {
                    mode.textContent = data.mode || 'İnançlı';
                    mode.dataset.mode = data.mode || 'İnançlı';
                }
            };
            
            setAmb('amb-metatron', state.ambassadors?.Metatron || { reputation: 0, mode: 'İnançlı' });
            setAmb('amb-uriel', state.ambassadors?.Uriel || { reputation: 0, mode: 'İnançlı' });
            setAmb('amb-raphael', state.ambassadors?.Raphael || { reputation: 0, mode: 'İnançlı' });
        };
        
        initPanteonPanel();
        renameUI();
        
        // Global export
        window.Pantheon = {
            db,
            effects: new EffectsManager()
        };
    }
    
    // Kehanet Paneli Sınıfı - Piyasa Tahmini ve Analizi
    class KehanetPanel {
        constructor() {
            this.panel = document.getElementById('kehanet-panel');
            this.expandBtn = document.getElementById('kp-expand-btn');
            this.refreshBtn = document.getElementById('kp-refresh-btn');
            this.confidenceFill = document.getElementById('kp-confidence-fill');
            this.confidenceLabel = document.getElementById('kp-confidence-label');
            this.miniChart = document.getElementById('kp-mini-chart');
            
            this.elements = {
                regime: document.getElementById('kp-regime'),
                session: document.getElementById('kp-session'),
                guardian: document.getElementById('kp-guardian'),
                pulse: document.getElementById('kp-pulse'),
                trend: document.getElementById('kp-trend'),
                prediction: document.getElementById('kp-prediction'),
                probability: document.getElementById('kp-probability'),
                timeframe: document.getElementById('kp-timeframe'),
                liquidity: document.getElementById('kp-liquidity'),
                pressure: document.getElementById('kp-pressure')
            };
            
            this.predictions = {
                trend: null,
                direction: null,
                probability: 0,
                timeTarget: null,
                confidence: 0,
                lastUpdate: null,
                supportLevels: [],
                resistanceLevels: []
            };
            
            this.marketData = {
                price: 0,
                volume: 0,
                atr: 0,
                regime: '—',
                liquidityImbalance: 0
            };
            
            this.isExpanded = false;
            this.chart = null;
            
            this.init();
        }
        
        init() {
            this.bindEvents();
            this.initMiniChart();
            this.loadPanelState();
            
            // İlk senkronizasyonu başlat
            this.sync();
            
            // Düzenli güncelleme aralığı
            setInterval(() => this.sync(), 1500);
            
            // Her 5 dakikada bir yeni tahmin oluştur
            setInterval(() => this.generatePrediction(), 5 * 60 * 1000);
            
            // İlk tahmini oluştur
            this.generatePrediction();
            
            console.log('Kehanet Paneli başlatıldı');
        }
        
        bindEvents() {
            // Panel genişletme/daraltma düğmesi
            if (this.expandBtn) {
                this.expandBtn.addEventListener('click', () => {
                    this.togglePanelExpand();
                });
            }
            
            // Tahmin yenileme düğmesi
            if (this.refreshBtn) {
                this.refreshBtn.addEventListener('click', () => {
                    this.generatePrediction(true);
                });
            }
            
            // Piyasa olaylarına abone ol
            if (window.app) {
                // Piyasa rejimi değiştiğinde
                window.app.on('marketRegimeChanged', (regime) => {
                    this.marketData.regime = regime;
                    this.generatePrediction();
                });
                
                // Yeni mum oluştuğunda
                window.app.on('newCandle', (candle) => {
                    this.updateMiniChart(candle);
                });
            }
        }
        
        sync() {
            if (!window.app) return;
            
            // Temel veriler
            const regime = window.app.marketRegime || '—';
            const session = window.app.sessionState || '—';
            const guardian = (window.app.settings?.features?.enableRiskGuardian) ? 'Aktif' : 'Pasif';
            
            // ATR (Average True Range) hesaplama
            const atr = window.app.indicators?.atr || 0;
            const price = window.app.marketData?.price || 0;
            const atrPct = (atr && price) ? (atr / price) : 0;
            const pulse = atrPct ? `${(atrPct*100).toFixed(2)}%` : '—';
            
            // Tüm piyasa verilerini güncelle
            this.marketData = {
                price: price,
                volume: window.app.marketData?.volume || 0,
                atr: atr,
                regime: regime,
                liquidityImbalance: this.calculateLiquidityImbalance()
            };
            
            // Temel bilgileri güncelle
            this.updateElement('regime', regime);
            this.updateElement('session', session);
            this.updateElement('guardian', guardian);
            this.updateElement('pulse', pulse);
            
            // Eğilim bilgisini güncelle
            const trend = this.determineTrend();
            this.updateElement('trend', trend);
            
            // Gelişmiş panel değerlerini güncelle (tahminlere dayalı)
            this.updateAdvancedPanelValues();
        }
        
        updateElement(key, value) {
            const element = this.elements[key];
            if (element) {
                element.textContent = value;
                
                // Bazı değerler için renk sınıflarını güncelle
                if (key === 'trend') {
                    element.className = 'kp-val'; // Reset
                    if (value.includes('Yükseliş')) {
                        element.classList.add('trend-up');
                    } else if (value.includes('Düşüş')) {
                        element.classList.add('trend-down');
                    } else if (value.includes('Yatay')) {
                        element.classList.add('trend-neutral');
                    }
                }
            }
        }
        
        togglePanelExpand() {
            this.isExpanded = !this.isExpanded;
            
            if (this.isExpanded) {
                this.panel.classList.add('kp-panel-expanded');
                // Mini grafiği yeniden boyutlandır
                if (this.chart) {
                    this.chart.resize(280, 70);
                }
            } else {
                this.panel.classList.remove('kp-panel-expanded');
            }
            
            // Panel durumunu kaydet
            localStorage.setItem('kehanet_panel_expanded', this.isExpanded);
        }
        
        loadPanelState() {
            const savedState = localStorage.getItem('kehanet_panel_expanded');
            if (savedState === 'true') {
                this.isExpanded = true;
                this.panel.classList.add('kp-panel-expanded');
            }
        }
        
        determineTrend() {
            if (!window.app || !window.app.indicators) {
                return 'Belirsiz';
            }
            
            // Trend belirlemek için kullanılabilecek göstergeler
            const macd = window.app.indicators.macd;
            const rsi = window.app.indicators.rsi;
            const ema200 = window.app.indicators.ema200;
            const price = window.app.marketData?.price || 0;
            
            if (!macd || !rsi || !ema200 || !price) {
                return 'Veri Yok';
            }
            
            // MACD ve RSI'ye dayalı trend belirleme
            let trendStrength = 0;
            
            // MACD trendi
            if (macd.histogram > 0 && macd.signal < macd.macd) {
                trendStrength += 1; // Yükseliş sinyali
            } else if (macd.histogram < 0 && macd.signal > macd.macd) {
                trendStrength -= 1; // Düşüş sinyali
            }
            
            // RSI trendi
            if (rsi > 60) {
                trendStrength += 1; // Yükseliş
            } else if (rsi < 40) {
                trendStrength -= 1; // Düşüş
            }
            
            // Fiyat ve EMA200 ilişkisi
            if (price > ema200) {
                trendStrength += 1; // Uzun vadeli yükseliş
            } else if (price < ema200) {
                trendStrength -= 1; // Uzun vadeli düşüş
            }
            
            // Son trendi belirle
            if (trendStrength >= 2) {
                return '↗️ Yükseliş';
            } else if (trendStrength <= -2) {
                return '↘️ Düşüş';
            } else {
                return '↔️ Yatay';
            }
        }
        
        calculateLiquidityImbalance() {
            // Emir defteri verilerini al (eğer mevcutsa)
            if (!window.app || !window.app.orderbook) {
                return 0;
            }
            
            const asks = window.app.orderbook.asks || [];
            const bids = window.app.orderbook.bids || [];
            
            if (asks.length === 0 || bids.length === 0) {
                return 0;
            }
            
            // En iyi 5 seviyenin toplam likidite hacmini hesapla
            let totalAskVolume = 0;
            let totalBidVolume = 0;
            
            for (let i = 0; i < Math.min(5, asks.length); i++) {
                totalAskVolume += asks[i].quantity;
            }
            
            for (let i = 0; i < Math.min(5, bids.length); i++) {
                totalBidVolume += bids[i].quantity;
            }
            
            // Likidite dengesizliği hesapla (-1 ile 1 arasında)
            const totalVolume = totalAskVolume + totalBidVolume;
            if (totalVolume === 0) return 0;
            
            return (totalBidVolume - totalAskVolume) / totalVolume;
        }
        
        initMiniChart() {
            if (!this.miniChart) return;
            
            try {
                // LightweightCharts'ı kullanarak mini grafik oluştur
                this.chart = LightweightCharts.createChart(this.miniChart, {
                    width: 280,
                    height: 70,
                    layout: {
                        background: { type: 'solid', color: 'transparent' },
                        textColor: 'rgba(255, 255, 255, 0.5)',
                    },
                    grid: {
                        vertLines: { color: 'rgba(42, 46, 57, 0)' },
                        horzLines: { color: 'rgba(42, 46, 57, 0.2)' },
                    },
                    timeScale: {
                        visible: false
                    },
                    rightPriceScale: {
                        visible: false
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal,
                        vertLine: { visible: false },
                        horzLine: { visible: false }
                    },
                    handleScale: false,
                    handleScroll: false
                });
                
                // Fiyat serisini oluştur
                this.priceSeries = this.chart.addAreaSeries({
                    topColor: 'rgba(33, 150, 243, 0.56)',
                    bottomColor: 'rgba(33, 150, 243, 0.04)',
                    lineColor: 'rgba(33, 150, 243, 1)',
                    lineWidth: 2
                });
                
                // Başlangıç verileri (son 10 mum)
                const initialData = this.getInitialChartData();
                this.priceSeries.setData(initialData);
                
            } catch (error) {
                console.error('Mini grafik oluşturma hatası:', error);
            }
        }
        
        getInitialChartData() {
            // App'den geçmiş verileri al veya varsayılan oluştur
            if (window.app && window.app.candles && window.app.candles.length > 0) {
                return window.app.candles.slice(-10).map(candle => ({
                    time: candle.time / 1000, // Unix zaman damgası
                    value: candle.close
                }));
            }
            
            // Varsayılan veriler
            const data = [];
            const now = Math.floor(Date.now() / 1000);
            const price = 20000; // Varsayılan fiyat
            
            for (let i = 9; i >= 0; i--) {
                data.push({
                    time: now - i * 60,
                    value: price + Math.random() * 500 - 250
                });
            }
            
            return data;
        }
        
        updateMiniChart(candle) {
            if (!this.priceSeries || !candle) return;
            
            // Yeni mumu grafiğe ekle
            this.priceSeries.update({
                time: candle.time / 1000,
                value: candle.close
            });
        }
        
        generatePrediction(userTriggered = false) {
            if (!window.app) return;
            
            // Tahmin için gerekli verileri topla
            const price = window.app.marketData?.price || 0;
            const volume = window.app.marketData?.volume || 0;
            const regime = window.app.marketRegime || 'NORMAL';
            const indicators = window.app.indicators || {};
            
            // Eğer kullanıcı tetiklediyse, özel efekt göster
            if (userTriggered) {
                this.showPredictionEffect();
            }
            
            // Tahmin algoritması
            let direction = null;
            let probability = 0;
            let confidence = 0;
            
            // Trend belirle
            const trend = this.determineTrend();
            
            // Farklı stratejilerin sinyallerini ağırlıklandırarak topla
            const signals = this.aggregateSignals();
            
            // Yön ve olasılık hesapla
            if (signals.bullish > signals.bearish) {
                direction = 'YUKARI';
                probability = Math.min(90, 50 + (signals.bullish - signals.bearish) * 5);
            } else if (signals.bearish > signals.bullish) {
                direction = 'AŞAĞI';
                probability = Math.min(90, 50 + (signals.bearish - signals.bullish) * 5);
            } else {
                direction = 'YATAY';
                probability = 50;
            }
            
            // Güven seviyesi hesaplama
            confidence = this.calculateConfidence(signals, regime);
            
            // Destek/direnç seviyeleri hesaplama
            const levels = this.calculateSupportResistanceLevels(price);
            
            // Zaman hedefi (dakika cinsinden)
            const timeTarget = this.calculateTimeTarget(regime, signals.volatility);
            
            // Tahmin sonuçlarını güncelle
            this.predictions = {
                trend: trend,
                direction: direction,
                probability: probability,
                timeTarget: timeTarget,
                confidence: confidence,
                lastUpdate: new Date(),
                supportLevels: levels.support,
                resistanceLevels: levels.resistance,
                liquidityImbalance: this.marketData.liquidityImbalance
            };
            
            // UI'ı güncelle
            this.updateAdvancedPanelValues();
            this.updateConfidenceBar(confidence);
            
            return this.predictions;
        }
        
        aggregateSignals() {
            if (!window.app || !window.app.indicators) {
                return { bullish: 0, bearish: 0, neutral: 0, volatility: 0 };
            }
            
            const ind = window.app.indicators;
            let bullish = 0;
            let bearish = 0;
            let neutral = 0;
            let volatility = 0;
            
            // MACD sinyalleri
            if (ind.macd) {
                if (ind.macd.histogram > 0 && ind.macd.histogram > ind.macd.histogramPrev) {
                    bullish += 2;
                } else if (ind.macd.histogram < 0 && ind.macd.histogram < ind.macd.histogramPrev) {
                    bearish += 2;
                } else {
                    neutral += 1;
                }
            }
            
            // RSI sinyalleri
            if (ind.rsi) {
                if (ind.rsi > 70) {
                    bearish += 1; // Aşırı alım
                } else if (ind.rsi < 30) {
                    bullish += 1; // Aşırı satım
                } else if (ind.rsi > 55) {
                    bullish += 0.5;
                } else if (ind.rsi < 45) {
                    bearish += 0.5;
                } else {
                    neutral += 1;
                }
            }
            
            // Bollinger Bandı sinyalleri
            if (ind.bb && window.app.marketData?.price) {
                const price = window.app.marketData.price;
                if (price > ind.bb.upper) {
                    bearish += 1.5; // Üst banda dokunma
                } else if (price < ind.bb.lower) {
                    bullish += 1.5; // Alt banda dokunma
                } else if (price > ind.bb.middle) {
                    bullish += 0.5;
                } else if (price < ind.bb.middle) {
                    bearish += 0.5;
                }
                
                // Volatilite hesaplama (bant genişliği)
                volatility = (ind.bb.upper - ind.bb.lower) / ind.bb.middle;
            }
            
            // Hareketli ortalama sinyalleri
            if (ind.ema9 && ind.ema21 && ind.ema55) {
                if (ind.ema9 > ind.ema21 && ind.ema21 > ind.ema55) {
                    bullish += 2; // Güçlü yükseliş trendi
                } else if (ind.ema9 < ind.ema21 && ind.ema21 < ind.ema55) {
                    bearish += 2; // Güçlü düşüş trendi
                } else if (ind.ema9 > ind.ema21) {
                    bullish += 0.5;
                } else if (ind.ema9 < ind.ema21) {
                    bearish += 0.5;
                }
            }
            
            // Hacim analizi
            if (window.app.marketData?.volume && window.app.marketData?.volumeAvg) {
                const volumeRatio = window.app.marketData.volume / window.app.marketData.volumeAvg;
                
                if (volumeRatio > 1.5 && bullish > bearish) {
                    bullish += volumeRatio - 1; // Hacim artışı ile birlikte alım sinyali güçlenir
                } else if (volumeRatio > 1.5 && bearish > bullish) {
                    bearish += volumeRatio - 1; // Hacim artışı ile birlikte satım sinyali güçlenir
                }
            }
            
            // ATR (volatilite göstergesi)
            if (ind.atr && window.app.marketData?.price) {
                const atrPct = ind.atr / window.app.marketData.price;
                volatility += atrPct * 100; // Volatiliteyi yüzde olarak ekle
            }
            
            return { bullish, bearish, neutral, volatility };
        }
        
        calculateConfidence(signals, regime) {
            // Güven seviyesi hesaplama (0-100 arasında)
            const totalSignals = signals.bullish + signals.bearish + signals.neutral;
            if (totalSignals === 0) return 50;
            
            // Dominant sinyalin gücü
            const dominantForce = Math.max(signals.bullish, signals.bearish);
            const dominantRatio = dominantForce / totalSignals;
            
            // Volatilite faktörü
            const volatilityFactor = Math.max(0, Math.min(1, 2 - signals.volatility / 5));
            
            // Rejim faktörü
            let regimeFactor = 1;
            if (regime === 'KITLIK') regimeFactor = 0.9; // Düşük volatilite, tahminler daha zor
            if (regime === 'SALGIN') regimeFactor = 0.7; // Kaotik piyasa, tahminler çok zor
            if (regime === 'SAVAŞ') regimeFactor = 1.1; // Trendli piyasa, tahminler daha kolay
            if (regime === 'ÖLÜM') regimeFactor = 0.5; // Ekstrem olaylar, tahminler çok zor
            
            // Güven seviyesi
            const confidence = dominantRatio * 100 * volatilityFactor * regimeFactor;
            
            return Math.min(95, Math.max(5, Math.round(confidence)));
        }
        
        calculateSupportResistanceLevels(currentPrice) {
            if (!currentPrice) return { support: [], resistance: [] };
            
            // Son fiyat hareketlerine dayalı pivot noktaları hesaplama
            const candles = window.app?.candles || [];
            if (candles.length < 10) {
                // Varsayılan seviyeler (basitleştirilmiş)
                return {
                    support: [currentPrice * 0.99, currentPrice * 0.98, currentPrice * 0.97],
                    resistance: [currentPrice * 1.01, currentPrice * 1.02, currentPrice * 1.03]
                };
            }
            
            // Geçmiş fiyat verilerinden pivot noktaları bulma
            const pivots = this.findPivotPoints(candles);
            const atr = window.app.indicators?.atr || (currentPrice * 0.01);
            
            // Mevcut fiyata göre destek ve direnç seviyelerini filtrele
            const support = pivots.filter(p => p < currentPrice).sort((a, b) => b - a).slice(0, 3);
            const resistance = pivots.filter(p => p > currentPrice).sort((a, b) => a - b).slice(0, 3);
            
            // Eğer yeterli seviye bulunamadıysa, ATR'ye dayalı seviyeler ekle
            while (support.length < 3) {
                const lastSupport = support.length > 0 ? support[support.length - 1] : currentPrice;
                support.push(lastSupport - atr);
            }
            
            while (resistance.length < 3) {
                const lastResistance = resistance.length > 0 ? resistance[resistance.length - 1] : currentPrice;
                resistance.push(lastResistance + atr);
            }
            
            return { support, resistance };
        }
        
        findPivotPoints(candles) {
            const pivots = [];
            const lookback = Math.min(candles.length, 100); // Son 100 mum
            
            // Basit pivot noktaları (yüksek ve düşük noktalar)
            for (let i = 5; i < lookback - 5; i++) {
                const isHighPivot = candles[i].high > candles[i-1].high && 
                                   candles[i].high > candles[i-2].high &&
                                   candles[i].high > candles[i+1].high && 
                                   candles[i].high > candles[i+2].high;
                
                const isLowPivot = candles[i].low < candles[i-1].low && 
                                  candles[i].low < candles[i-2].low &&
                                  candles[i].low < candles[i+1].low && 
                                  candles[i].low < candles[i+2].low;
                
                if (isHighPivot) pivots.push(candles[i].high);
                if (isLowPivot) pivots.push(candles[i].low);
            }
            
            // Yakın pivot noktalarını birleştir
            const uniquePivots = [];
            const tolerance = window.app.indicators?.atr || 0;
            
            pivots.forEach(pivot => {
                // Benzer bir pivot noktası var mı kontrol et
                const similarPivot = uniquePivots.find(p => Math.abs(p - pivot) < tolerance);
                if (!similarPivot) {
                    uniquePivots.push(pivot);
                }
            });
            
            return uniquePivots;
        }
        
        calculateTimeTarget(regime, volatility) {
            // Zaman hedefi (dakika cinsinden) hesaplama
            let baseTime = 30; // Varsayılan 30 dakika
            
            // Rejime göre ayarla
            if (regime === 'KITLIK') baseTime = 60; // Yatay piyasada daha uzun sürer
            if (regime === 'SALGIN') baseTime = 15; // Dalgalı piyasada daha hızlı değişir
            if (regime === 'SAVAŞ') baseTime = 45; // Trend devam edecek
            if (regime === 'ÖLÜM') baseTime = 10; // Çok hızlı değişimler
            
            // Volatiliteye göre ayarla
            const volatilityFactor = Math.max(0.5, Math.min(2, 1 + volatility / 10));
            const targetMinutes = Math.round(baseTime / volatilityFactor);
            
            return targetMinutes;
        }
        
        updateAdvancedPanelValues() {
            // Tahmin yönü
            this.updateElement('prediction', this.predictions.direction || '—');
            
            // Olasılık
            const probability = this.predictions.probability ? `%${this.predictions.probability}` : '—';
            this.updateElement('probability', probability);
            
            // Zaman hedefi
            const timeframe = this.predictions.timeTarget ? `${this.predictions.timeTarget} dk` : '—';
            this.updateElement('timeframe', timeframe);
            
            // Likidite
            const liquidityImbalance = this.marketData.liquidityImbalance;
            let liquidityText = '—';
            
            if (liquidityImbalance > 0.2) {
                liquidityText = '🟢 Alım Baskısı';
            } else if (liquidityImbalance < -0.2) {
                liquidityText = '🔴 Satış Baskısı';
            } else if (liquidityImbalance !== 0) {
                liquidityText = '⚪ Dengeli';
            }
            
            this.updateElement('liquidity', liquidityText);
            
            // Baskı göstergesi
            let pressureText = '—';
            if (window.app && window.app.indicators && window.app.indicators.rsi) {
                const rsi = window.app.indicators.rsi;
                if (rsi > 75) {
                    pressureText = '🔴 Aşırı Alım';
                } else if (rsi > 60) {
                    pressureText = '🟠 Yüksek';
                } else if (rsi < 25) {
                    pressureText = '🔵 Aşırı Satım';
                } else if (rsi < 40) {
                    pressureText = '🔷 Düşük';
                } else {
                    pressureText = '⚪ Normal';
                }
            }
            
            this.updateElement('pressure', pressureText);
        }
        
        updateConfidenceBar(confidence) {
            if (this.confidenceFill && this.confidenceLabel) {
                this.confidenceFill.style.width = `${confidence}%`;
                this.confidenceLabel.textContent = `Güven: %${confidence}`;
                
                // Renk değişimi
                if (confidence < 30) {
                    this.confidenceFill.style.background = 'linear-gradient(90deg, var(--danger) 0%, var(--warning) 100%)';
                } else if (confidence < 60) {
                    this.confidenceFill.style.background = 'linear-gradient(90deg, var(--warning) 0%, var(--info) 100%)';
                } else {
                    this.confidenceFill.style.background = 'linear-gradient(90deg, var(--info) 0%, var(--success) 100%)';
                }
            }
        }
        
        showPredictionEffect() {
            // Tahmin yenileme efekti
            if (this.panel) {
                this.panel.classList.add('prediction-refresh');
                setTimeout(() => {
                    this.panel.classList.remove('prediction-refresh');
                }, 1000);
            }
            
            // Özel efekt (tsParticles kullanarak)
            if (window.Pantheon && window.Pantheon.effects) {
                window.Pantheon.effects.showPredictionEffect();
            }
        }
    }
    
    // Kehanet Paneli JS Fonksiyonu
    const initKehanetPanel = () => {
        // Kehanet Panelini oluştur ve başlat
        window.kehanetPanel = new KehanetPanel();
    };
    
    // Sayfa yüklenince Panteon ve Kehanet Panelini başlat
    document.addEventListener('DOMContentLoaded', async () => {
        try {
            // Panteon sistemini başlat - ABM (Ajan Tabanlı Modelleme) ile yeni versiyonu başlat
            window.pantheonSystem = new PantheonSystem();
            
            // Panteon olaylarını dinle
            document.addEventListener('pantheon:state_change', (event) => {
                console.log('Panteon Durum Değişikliği:', event.detail);
                // Burada durum değişikliğini UI'da gösterebilir veya başka işlemler yapabilirsiniz
            });
            
            document.addEventListener('pantheon:decision', (event) => {
                console.log('Panteon Kararı:', event.detail);
                
                // Karar UI'da gösterme
                const decision = event.detail;
                showNotification(
                    `Elçiler Konseyi: ${decision.recommendation}`,
                    `Güven: ${decision.confidence.toFixed(1)}% | Risk: ${(decision.riskLevel * 100).toFixed(1)}%`,
                    decision.recommendation === 'ATAK' ? 'success' : 
                    decision.recommendation === 'GERİÇEKİL' ? 'error' : 'info',
                    5000
                );
            });
            
            document.addEventListener('pantheon:revelation', (event) => {
                console.log('Metatron Vahiy:', event.detail);
                showNotification(
                    'Metatron\'un Vahyi',
                    `Öngörü Gücü: ${event.detail.power.toFixed(1)}%`,
                    'info',
                    4000
                );
            });
            
            document.addEventListener('pantheon:valor', (event) => {
                console.log('Uriel Cesaret:', event.detail);
                showNotification(
                    'Uriel\'in Cesareti',
                    `Cesaret Gücü: ${event.detail.power.toFixed(1)}%`,
                    'warning',
                    4000
                );
            });
            
            // Kehanet panelini başlat
            initKehanetPanel();
            
            // App hazır olduğunda window.app'e veri erişimini enjekte et
            const ensureInject = setInterval(() => {
                if(window.app && window.Pantheon) {
                    clearInterval(ensureInject);
                }
            }, 100);
        } catch(e) {
            console.error('Panteon bootstrap hatası:', e);
        }
    });
    
    // Önemli sınıfları önce tanımla (PantheonSystem)
    /**
     * PantheonSystem - Ajan Tabanlı Modelleme yaklaşımıyla geliştirilmiş,
     * stratejileri kategorize eden ve kararları etkileyen akıllı sistem
     */
    class PantheonSystem {
        constructor() {
            // Elçi ajanlarını tanımla (her biri otonomdur ve kendi durumuna sahiptir)
            this.ambassadors = {
                metatron: {
                    name: 'Metatron',
                    role: 'wisdom',
                    displayName: 'Metatron',
                    archetype: 'Bilgelik, Analiz',
                    color: 'var(--metatron-color)',
                    
                    // ABM - Ajan Durumu (State)
                    state: {
                        reputation: 0,
                        mode: 'İNANÇLI', // İNANÇLI, ŞÜPHECİ, KIYAMET
                        confidence: 75,
                        power: 0, // Anlık güç/etki seviyesi (0-100)
                        active: true,
                        risk_appetite: 0.5, // 0-1 arası risk iştahı
                        confirmation_bias: 0.3, // Onaylama yanlılığı
                        mean_reversion_bias: 0, // Ortalamaya dönüş yanlılığı
                        active_strategies: []
                    },
                    
                    // ABM - Ajan Davranışı (Behavior Rules)
                    strategies: ['SupportResistanceStrategy', 'MeanReversionStrategy', 'OrderBookImbalanceStrategy'],
                    primaryDataSources: ['Price Levels', 'Order Book Depth', 'RSI'],
                    
                    // ABM - Çevresel Adaptasyon (Environmental Adaptation)
                    regimeAdaptation: {
                        'KITLIK': { risk_modifier: 1.2, weight_modifier: 1.3 }, // Yatay piyasada güçlü
                        'SALGIN': { risk_modifier: 0.9, weight_modifier: 1.1 }, // Dalgalı piyasada orta
                        'SAVAŞ': { risk_modifier: 0.7, weight_modifier: 0.8 },  // Trendli piyasada zayıf
                        'ÖLÜM': { risk_modifier: 0.4, weight_modifier: 0.5 }    // Çöküşte çok zayıf
                    }
                },
                
                uriel: {
                    name: 'Uriel',
                    role: 'courage',
                    displayName: 'Uriel',
                    archetype: 'Cesaret, Hız',
                    color: 'var(--uriel-color)',
                    
                    // ABM - Ajan Durumu (State)
                    state: {
                        reputation: 0,
                        mode: 'İNANÇLI',
                        confidence: 75,
                        power: 0,
                        active: true,
                        risk_appetite: 0.8,
                        trend_following_bias: 0.7,
                        aggression_level: 0.6,
                        active_strategies: []
                    },
                    
                    // ABM - Ajan Davranışı (Behavior Rules)
                    strategies: ['BreakoutPatternStrategy', 'MomentumStrategy', 'TrendFollowingStrategy'],
                    primaryDataSources: ['Price Velocity', 'Volume Spikes', 'Volatility'],
                    
                    // ABM - Çevresel Adaptasyon (Environmental Adaptation)
                    regimeAdaptation: {
                        'KITLIK': { risk_modifier: 0.6, weight_modifier: 0.5 },  // Yatay piyasada zayıf
                        'SALGIN': { risk_modifier: 0.8, weight_modifier: 0.7 },  // Dalgalı piyasada orta
                        'SAVAŞ': { risk_modifier: 1.4, weight_modifier: 1.5 },   // Trendli piyasada çok güçlü
                        'ÖLÜM': { risk_modifier: 1.2, weight_modifier: 1.1 }     // Çöküşte güçlü
                    }
                },
                
                raphael: {
                    name: 'Raphael',
                    role: 'healing',
                    displayName: 'Raphael',
                    archetype: 'Şifa, Denge',
                    color: 'var(--raphael-color)',
                    
                    // ABM - Ajan Durumu (State)
                    state: {
                        reputation: 0,
                        mode: 'İNANÇLI',
                        confidence: 75,
                        power: 0,
                        active: true,
                        risk_appetite: 0.4,
                        mean_reversion_bias: 0.8,
                        information_sensitivity: 0.5,
                        active_strategies: []
                    },
                    
                    // ABM - Ajan Davranışı (Behavior Rules)
                    strategies: ['StatArbitrageStrategy', 'LiquidityGapStrategy', 'OverboughtOversoldStrategy'],
                    primaryDataSources: ['Correlations', 'Spreads', 'Order Flow'],
                    
                    // ABM - Çevresel Adaptasyon (Environmental Adaptation)
                    regimeAdaptation: {
                        'KITLIK': { risk_modifier: 0.9, weight_modifier: 1.0 },  // Yatay piyasada normal
                        'SALGIN': { risk_modifier: 1.3, weight_modifier: 1.4 },  // Dalgalı piyasada çok güçlü
                        'SAVAŞ': { risk_modifier: 0.5, weight_modifier: 0.4 },   // Trendli piyasada zayıf
                        'ÖLÜM': { risk_modifier: 0.7, weight_modifier: 0.9 }     // Çöküşte orta
                    }
                },
                
                gabriel: {
                    name: 'Gabriel',
                    role: 'communication',
                    displayName: 'Gabriel',
                    archetype: 'İletişim, Bilgi',
                    color: 'var(--gabriel-color)',
                    
                    // ABM - Ajan Durumu (State)
                    state: {
                        reputation: 0,
                        mode: 'İNANÇLI',
                        confidence: 75,
                        power: 0,
                        active: true,
                        risk_appetite: 0.6,
                        information_sensitivity: 0.9,
                        social_influence: 0.7,
                        active_strategies: []
                    },
                    
                    // ABM - Ajan Davranışı (Behavior Rules)
                    strategies: ['SmartMoneyStrategy', 'VolumeProfileStrategy', 'SentimentAnalysisStrategy'],
                    primaryDataSources: ['Volume', 'News Flow', 'Social Media Data'],
                    
                    // ABM - Çevresel Adaptasyon (Environmental Adaptation)
                    regimeAdaptation: {
                        'KITLIK': { risk_modifier: 0.8, weight_modifier: 0.7 },  // Yatay piyasada orta
                        'SALGIN': { risk_modifier: 0.7, weight_modifier: 0.8 },  // Dalgalı piyasada orta
                        'SAVAŞ': { risk_modifier: 0.9, weight_modifier: 1.0 },   // Trendli piyasada normal
                        'ÖLÜM': { risk_modifier: 1.3, weight_modifier: 1.5 }     // Çöküşte çok güçlü (haberler önemli)
                    }
                },
                
                michael: {
                    name: 'Michael',
                    role: 'warfare',
                    displayName: 'Michael',
                    archetype: 'Savaş, Güç',
                    color: 'var(--michael-color)',
                    
                    // ABM - Ajan Durumu (State)
                    state: {
                        reputation: 0,
                        mode: 'İNANÇLI',
                        confidence: 75,
                        power: 0,
                        active: true,
                        risk_appetite: 0.9,
                        aggression_level: 0.8,
                        opportunistic_bias: 0.7,
                        active_strategies: []
                    },
                    
                    // ABM - Ajan Davranışı (Behavior Rules)
                    strategies: ['AggressiveCandleStrategy', 'LiquidationCascadeStrategy', 'VolatilityBreakoutStrategy'],
                    primaryDataSources: ['Candle Patterns', 'Open Interest', 'Liquidation Data'],
                    
                    // ABM - Çevresel Adaptasyon (Environmental Adaptation)
                    regimeAdaptation: {
                        'KITLIK': { risk_modifier: 0.4, weight_modifier: 0.3 },  // Yatay piyasada çok zayıf
                        'SALGIN': { risk_modifier: 0.6, weight_modifier: 0.7 },  // Dalgalı piyasada orta
                        'SAVAŞ': { risk_modifier: 1.3, weight_modifier: 1.2 },   // Trendli piyasada güçlü
                        'ÖLÜM': { risk_modifier: 1.5, weight_modifier: 1.6 }     // Çöküşte çok güçlü
                    }
                }
            };
            
            // Yetenekler ve bekleme süreleri
            this.abilities = {
                council: { cooldown: 60000, lastUsed: 0, description: 'Tüm Elçilerin bir araya gelerek kolektif karar alması' },
                reset: { cooldown: 300000, lastUsed: 0, description: 'İtibar puanlarını sıfırlama' },
                revelation: { cooldown: 45000, lastUsed: 0, description: 'Metatron\'un öngörüsü' },
                valor: { cooldown: 30000, lastUsed: 0, description: 'Uriel\'in cesareti' },
                communication: { cooldown: 35000, lastUsed: 0, description: 'Gabriel\'in bilgi analizi ve sosyal medya taraması' },
                warfare: { cooldown: 25000, lastUsed: 0, description: 'Michael\'in agresif saldırı analizi ve likidite avı' }
            };
            
            // Sistem durum değişkenleri
            this.system = {
                initialized: false,
                currentRegime: 'NORMAL',
                collectiveState: 'Dengeli',
                confidenceThreshold: 65,
                lastUpdateTime: Date.now(),
                decayRate: 0.05, // Saniyede %0.05 güç azalması
                usageHistory: [],
                version: '3.5'
            };
            
            // Sistemi başlat
            this.init();
        }
        
        async init() {
            if (this.system.initialized) return;
            
            try {
                // Kaydedilmiş verileri yükle
                await this.loadState();
                
                // UI elemanlarını bul ve olayları bağla
                this.bindUI();
                
                // UI'ı güncelle
                this.updateUI();
                
                // Düzenli güncelleme için zamanlayıcı başlat
                this.startUpdateLoop();
                
                this.system.initialized = true;
                console.log('Panteon Sistemi başlatıldı (v' + this.system.version + ')');
            } catch (error) {
                console.error('Panteon Sistemi başlatılamadı:', error);
            }
        }
        
        bindEvents() {
            // Kapatma butonu
            document.querySelector('.pantheon-close')?.addEventListener('click', (e) => {
                e.stopPropagation();
                const ui = document.getElementById('pantheon-ui');
                if (ui) {
                    ui.style.display = 'none';
                    localStorage.setItem('pantheonUIVisible', 'false');
                }
            });
            
            // Toggle butonu
            document.querySelector('.pantheon-toggle-btn')?.addEventListener('click', (e) => {
                e.stopPropagation();
                const content = document.querySelector('.pantheon-content');
                const btn = document.querySelector('.pantheon-toggle-btn');
                if (content && btn) {
                    const isVisible = content.style.display !== 'none';
                    content.style.display = isVisible ? 'none' : 'flex';
                    btn.textContent = isVisible ? '▲' : '▼';
                    localStorage.setItem('pantheonContentVisible', (!isVisible).toString());
                }
            });
            
            // Restore visibility state
            const shouldHideContent = localStorage.getItem('pantheonContentVisible') === 'false';
            if (shouldHideContent) {
                const content = document.querySelector('.pantheon-content');
                const btn = document.querySelector('.pantheon-toggle-btn');
                if (content && btn) {
                    content.style.display = 'none';
                    btn.textContent = '▲';
                }
            }
            
            // Yetenek butonları
            Object.keys(this.abilities).forEach(abilityId => {
                const abilityEl = document.querySelector(`.ability[data-ability="${abilityId}"]`);
                if (abilityEl) {
                    abilityEl.addEventListener('click', () => this.activateAbility(abilityId));
                }
            });
            
            // Tanrı etkileşimleri
            document.querySelectorAll('.god').forEach(godEl => {
                const godName = godEl.dataset.god;
                if (godName && this.gods[godName]) {
                    godEl.addEventListener('click', () => this.onGodClick(godName));
                }
            });
        }
        
        loadPowers() {
            try {
                const savedPowers = JSON.parse(localStorage.getItem('pantheonPowers') || '{}');
                Object.keys(this.gods).forEach(godName => {
                    if (savedPowers[godName] !== undefined) {
                        this.gods[godName].power = Math.min(savedPowers[godName], this.gods[godName].maxPower);
                    }
                });
                this.updateUI();
            } catch (e) {
                console.error('Güç değerleri yüklenirken hata:', e);
            }
        }
        
        savePowers() {
            try {
                const powersToSave = {};
                Object.keys(this.gods).forEach(godName => {
                    powersToSave[godName] = this.gods[godName].power;
                });
                localStorage.setItem('pantheonPowers', JSON.stringify(powersToSave));
            } catch (e) {
                console.error('Güç değerleri kaydedilirken hata:', e);
            }
        }
        
        increasePantheonPower(godName, amount = 1) {
            if (!this.gods[godName]) return;
            
            const god = this.gods[godName];
            god.power = Math.min(god.power + amount, god.maxPower);
            
            // Özel efektler
            this.createPowerEffect(godName);
            
            // UI güncelle
            this.updateUI();
            
            // Kaydet
            this.savePowers();
            
            // Özel yetenekler
            this.checkSpecialAbilities(godName);
            
            return god.power;
        }
        
        checkSpecialAbilities(godName) {
            const god = this.gods[godName];
            if (!god) return;
            
            // %100 güç özel yeteneği
            if (god.power >= god.maxPower) {
                this.triggerElciSpecialAbility(godName);
                god.power = 0; // Gücü sıfırla
                this.updateUI();
                this.savePowers();
            }
        }
        
        triggerElciSpecialAbility(godName) {
            const abilities = {
                metatron: () => this.activateRevelation(),
                uriel: () => this.activateValor(),
                raphael: () => this.activateRestoration(),
                gabriel: () => this.activateCommunication(),
                michael: () => this.activateJudgment()
            };
            
            if (abilities[godName]) {
                abilities[godName]();
                this.showNotification(`${this.getGodDisplayName(godName)} özel yeteneği aktive edildi!`, 'success');
            }
        }
        
        activateRevelation() {
            // Metatron - Vahiy: Tüm stratejilerin doğruluk oranını geçici olarak artır
            this.showNotification('Vahiy: Stratejilerin doğruluk oranı arttı!', 'divine');
            
            // Işık efekti oluştur
            this.createFirstLightEffect();
            
            if (window.app) {
                // Tüm aktif stratejiler için sinyal kalitesini geçici olarak artır
                const strategies = window.app.strategies || {};
                const activeStrategies = window.app.settings?.activeStrategies || {};
                
                Object.keys(activeStrategies).forEach(key => {
                    if (activeStrategies[key] && strategies[key]) {
                        // Stratejilerin alfa değerini artır (geçici olarak)
                        if (window.app.strategyStats[key]?.overall) {
                            const originalAlpha = window.app.strategyStats[key].overall.alpha || 3;
                            window.app.strategyStats[key].overall.alpha = originalAlpha * 1.5;
                            
                            // 60 saniye sonra normale döndür
                            setTimeout(() => {
                                window.app.strategyStats[key].overall.alpha = originalAlpha;
                            }, 60000);
                        }
                    }
                });
                
                // Metatron'a güç ekliyoruz
                this.increasePower('metatron', 20);
                
                window.app.speak("Vahiy gücü aktifleştirildi. Stratejiler aydınlandı.");
            }
        }
        
        activateValor() {
            // Uriel - Cesaret: Risk toleransını geçici olarak artırır
            this.showNotification('Cesaret: Risk limitleri artırıldı!', 'divine');
            
            if (window.app) {
                // Geçici olarak daha agresif ticaret stratejisi
                const settings = window.app.settings || {};
                const originalRiskFactor = settings.riskFactor || 1.0;
                const originalLeverageLevel = settings.leverageLevel || 1.0;
                
                // Riski artır (geçici olarak)
                window.app.settings.riskFactor = originalRiskFactor * 1.5;
                window.app.settings.leverageLevel = originalLeverageLevel * 1.2;
                
                // Savaş modunu aktifleştir
                if (!window.app.combatModeActive) {
                    window.app.activateCombatMode();
                }
                
                // 45 saniye sonra normale döndür
                setTimeout(() => {
                    window.app.settings.riskFactor = originalRiskFactor;
                    window.app.settings.leverageLevel = originalLeverageLevel;
                }, 45000);
                
                // Uriel'e güç ekliyoruz
                this.increasePower('uriel', 15);
                
                window.app.speak("Cesaret gücü aktifleşti. Risk toleransı arttı!");
            }
        }
        
        activateRestoration() {
            // Raphael - Şifa: Kayıpları telafi etme ve iyileşme
            this.showNotification('Şifa: Kayıplar telafi ediliyor ve stratejiler iyileştiriliyor...', 'divine');
            
            if (window.app) {
                // Tüm shadowbanned stratejileri yeniden rehabilite et
                const statusMaps = window.app.settings?.statusMaps || {};
                const shadowBanned = statusMaps.shadowBanned || {};
                
                Object.keys(shadowBanned).forEach(key => {
                    // Eğer gölge yasaklı ancak hard-banned değilse
                    if (shadowBanned[key] && !statusMaps.hardBanned?.[key]) {
                        // Şansa bağlı olarak rehabilite et
                        if (Math.random() < 0.5) {
                            window.app.toggleShadow(key); // Gölgeden çıkar
                        }
                    }
                });
                
                // Sinyal geçmişinde son 3 kaybedilen sinyali siliyoruz
                let lossCount = 0;
                let signals = window.app.signals || [];
                
                // Sondan başlayarak en son kaybedilen 3 sinyali bul
                for (let i = signals.length - 1; i >= 0 && lossCount < 3; i--) {
                    if (signals[i].status === 'sl') {
                        signals[i].status = 'restored';
                        lossCount++;
                    }
                }
                
                // Raphael'e güç ekliyoruz
                this.increasePower('raphael', 10);
                
                window.app.speak("İyileştirme gücü aktif. Stratejiler rehabilite ediliyor!");
            }
        }
        
        activateCommunication() {
            // Gabriel - İletişim: Veri akışını ve sinyal iletimini iyileştir
            this.showNotification('İletişim: Veri akışı optimize edildi, sinyal kalitesi arttırıldı!', 'divine');
            
            if (window.app) {
                // WebSocket bağlantısını yeniden başlat (daha temiz veri akışı için)
                if (window.app.socket && window.app.reconnect) {
                    window.app.reconnect();
                }
                
                // Sinyal filtreleme hassasiyetini geçici olarak artır
                const originalNoiseThreshold = window.app.settings?.noiseThreshold || 0.5;
                window.app.settings.noiseThreshold = originalNoiseThreshold * 0.7; // Daha hassas filtreleme
                
                // 50 saniye sonra normale döndür
                setTimeout(() => {
                    window.app.settings.noiseThreshold = originalNoiseThreshold;
                }, 50000);
                
                // Gabriel'e güç ekliyoruz
                this.increasePower('gabriel', 12);
                
                window.app.speak("İletişim gücü aktif. Sinyal gürültü filtreleme optimize edildi!");
            }
        }
        
        activateJudgment() {
            // Michael - Yargı: Düşman pozisyonlarını ortaya çıkar ve piyasa adaletini sağla
            this.showNotification('Yargı: Düşman pozisyonları tespit edildi! Karşı hamle yapılıyor...', 'divine');
            
            if (window.app) {
                // En kötü performans gösteren stratejiyi tespit et ve cezalandır
                const strategyStats = window.app.strategyStats || {};
                let worstStrategy = null;
                let worstPerformance = Infinity;
                
                Object.keys(strategyStats).forEach(key => {
                    const stats = strategyStats[key]?.overall || {};
                    if (stats.contrib > 10) { // Yeterli veri varsa
                        const performance = stats.wins / (stats.wins + stats.losses || 1);
                        if (performance < worstPerformance) {
                            worstPerformance = performance;
                            worstStrategy = key;
                        }
                    }
                });
                
                if (worstStrategy) {
                    // En kötü stratejiyi gölgeye al
                    window.app.toggleShadow(worstStrategy);
                    window.app.showNotification(`${window.app.strategies[worstStrategy].displayName} stratejisi adalete teslim edildi!`, 'warning');
                }
                
                // Piyasada düşman pozisyonlarını tespit et (fiyat hareketlerindeki anormallikleri bul)
                window.app.detectMarketManipulation();
                
                // Michael'a güç ekliyoruz
                this.increasePower('michael', 18);
                
                window.app.speak("Adalet gücü aktif. Düşman pozisyonları tespit edildi ve cezalandırıldı!");
            }
        }
        
        // İlk Işık efekti
        createFirstLightEffect() {
            // Ekrana parlak bir ışık efekti ekle
            const flash = document.createElement('div');
            flash.className = 'first-light-effect';
            flash.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: radial-gradient(circle at center, rgba(255,255,255,0.9), rgba(255,255,255,0) 70%);
                pointer-events: none;
                z-index: 9999;
                opacity: 0;
                animation: first-light-pulse 2s ease-out;
            `;
            
            const style = document.createElement('style');
            style.innerHTML = `
                @keyframes first-light-pulse {
                    0% { opacity: 0; }
                    10% { opacity: 0.9; }
                    100% { opacity: 0; }
                }
            `;
            
            document.head.appendChild(style);
            document.body.appendChild(flash);
            
            // Animasyon bitince kaldır
            flash.addEventListener('animationend', () => {
                flash.remove();
            });
        }
        
        // Tanrı güç seviyesini artır
        increasePower(godName, amount) {
            if (!this.gods[godName]) return;
            
            // Mevcut gücü artır
            this.gods[godName].power = Math.min(100, this.gods[godName].power + amount);
            
            // UI güncelle
            this.updateUI();
            
            // Efekt oluştur
            for (let i = 0; i < 10; i++) {
                this.createPowerEffect(godName);
            }
            
            // Güçleri kaydet
            this.savePowers();
        }
        
        activateAbility(abilityId) {
            const ability = this.abilities[abilityId];
            if (!ability) return;
            
            const now = Date.now();
            const cooldownLeft = (ability.lastUsed + ability.cooldown) - now;
            
            if (cooldownLeft > 0) {
                this.showNotification(`Bekleyin: ${(cooldownLeft/1000).toFixed(1)} saniye kaldı`, 'warning');
                return;
            }
            
            // Yeteneği etkinleştir
            ability.lastUsed = now;
            this.startCooldown(abilityId, ability.cooldown);
            
            // Yeteneğe özel işlemler
            switch(abilityId) {
                case 'revelation':
                    this.activateRevelation();
                    break;
                case 'valor':
                    this.activateValor();
                    break;
                case 'restoration':
                    this.activateRestoration();
                    break;
            }
        }
        
        startCooldown(abilityId, duration) {
            const abilityEl = document.querySelector(`.ability[data-ability="${abilityId}"]`);
            if (!abilityEl) return;
            
            const cooldownEl = abilityEl.querySelector('.ability-cooldown');
            if (!cooldownEl) return;
            
            abilityEl.classList.add('on-cooldown');
            cooldownEl.style.transition = `transform ${duration}ms linear`;
            cooldownEl.style.transform = 'scaleX(0)';
            
            // Animasyon bittiğinde sınıfı kaldır
            setTimeout(() => {
                abilityEl.classList.remove('on-cooldown');
                cooldownEl.style.transition = 'none';
                cooldownEl.style.transform = 'scaleX(1)';
                // Tarayıcıya stil değişikliğini işlemesi için kısa bir gecikme
                setTimeout(() => {
                    cooldownEl.style.transition = '';
                }, 10);
            }, duration);
        }
        
        onGodClick(godName) {
            // Tanrıya tıklandığında özel bir şeyler yap
            this.showNotification(`${this.getGodDisplayName(godName)} dinleniyor...`, 'info');
        }
        
        getGodDisplayName(godName) {
            const names = {
                metatron: 'Metatron',
                uriel: 'Uriel',
                raphael: 'Raphael',
                gabriel: 'Gabriel',
                michael: 'Michael'
            };
            return names[godName] || godName;
        }
        
        updateUI() {
            // Güç çubuklarını güncelle
            Object.entries(this.gods).forEach(([godName, god]) => {
                const powerEl = document.querySelector(`.god[data-god="${godName}"] .god-power`);
                const progressEl = document.querySelector(`.god[data-god="${godName}"] .god-progress-fill`);
                
                if (powerEl) {
                    powerEl.textContent = `${Math.round(god.power)}%`;
                }
                
                if (progressEl) {
                    const percentage = (god.power / god.maxPower) * 100;
                    progressEl.style.width = `${percentage}%`;
                    
                    // Güç seviyesine göre renk yoğunluğunu ayarla
                    const opacity = 0.3 + (percentage / 100 * 0.7);
                    progressEl.style.opacity = opacity;
                }
            });
            
            // Özel yetenek durumlarını güncelle
            this.updateAbilityStates();
        }
        
        updateAbilityStates() {
            const now = Date.now();
            
            Object.entries(this.abilities).forEach(([abilityId, ability]) => {
                const abilityEl = document.querySelector(`.ability[data-ability="${abilityId}"]`);
                if (!abilityEl) return;
                
                const cooldownLeft = (ability.lastUsed + ability.cooldown) - now;
                if (cooldownLeft > 0) {
                    abilityEl.classList.add('on-cooldown');
                    abilityEl.querySelector('.ability-cooldown').style.transform = `scaleX(${1 - cooldownLeft / ability.cooldown})`;
                } else {
                    abilityEl.classList.remove('on-cooldown');
                    abilityEl.querySelector('.ability-cooldown').style.transform = 'scaleX(1)';
                }
            });
        }
        
        initEffects() {
            // TSParticles veya diğer görsel efektleri burada başlat
            // Gelecekte genişletmek için bu fonksiyon kullanılabilir
        }
        
        createPowerEffect(godName) {
            const godEl = document.querySelector(`.god[data-god="${godName}"]`);
            if (!godEl) return;
            
            // Parlama efekti
            const flash = document.createElement('div');
            flash.className = 'god-flash';
            flash.style.backgroundColor = this.gods[godName].color;
            godEl.appendChild(flash);
            
            // Kısa bir süre sonra temizle
            setTimeout(() => {
                godEl.removeChild(flash);
            }, 500);
        }
        
        decayLoop() {
            setInterval(() => {
                const now = Date.now();
                const elapsed = (now - this.lastDecayTime) / 1000; // Saniye cinsinden geçen süre
                
                // Her tanrı için güç azaltması uygula
                Object.values(this.gods).forEach(god => {
                    const decayAmount = this.powerDecayRate * elapsed;
                    if (god.power > 0) {
                        god.power = Math.max(0, god.power - decayAmount);
                    }
                });
                
                // UI güncelle (daha az sıklıkla)
                if (Math.random() < 0.2) {
                    this.updateUI();
                    this.savePowers();
                }
                
                this.lastDecayTime = now;
            }, 5000); // 5 saniyede bir kontrol et
        }
        
        showNotification(message, type = 'info') {
            // Bildirim gösterme fonksiyonu - app nesnesinden geliyorsa kullan
            if (window.app && window.app.showNotification) {
                window.app.showNotification(message, type);
                return;
            }
            
            // Basit bildirim oluştur
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            const container = document.getElementById('notifications-container') || document.body;
            container.appendChild(notification);
            
            // 3 saniye sonra kaldır
            setTimeout(() => {
                container.removeChild(notification);
            }, 3000);
        }
    }

    // Veritabanı yöneticisi sınıfı
    class DBManager {
        constructor() {
            this.dbName = 'ultimateTrader';
            this.dbVersion = 1;
            this.db = null;
            this.ready = false;
            this.initPromise = null;
        }
        
        init() {
            if (this.initPromise) return this.initPromise;
            
            this.initPromise = new Promise((resolve, reject) => {
                // IndexedDB'yi desteklemiyor mu?
                if (!window.indexedDB) {
                    console.error('Bu tarayıcı IndexedDB desteklemiyor!');
                    reject(new Error('IndexedDB desteklenmiyor'));
                    return;
                }
                
                const request = indexedDB.open(this.dbName, this.dbVersion);
                
                request.onerror = (event) => {
                    console.error('Veritabanı açılırken hata oluştu:', event);
                    reject(event.target.error);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // Depolanacak objeler için object stores oluştur
                    if (!db.objectStoreNames.contains('settings')) {
                        db.createObjectStore('settings', { keyPath: 'id' });
                    }
                    
                    if (!db.objectStoreNames.contains('signals')) {
                        db.createObjectStore('signals', { keyPath: 'id', autoIncrement: true });
                    }
                    
                    if (!db.objectStoreNames.contains('stats')) {
                        db.createObjectStore('stats', { keyPath: 'id' });
                    }
                    
                    if (!db.objectStoreNames.contains('panteon')) {
                        db.createObjectStore('panteon', { keyPath: 'id' });
                    }
                    
                    console.log('Veritabanı şeması güncellendi');
                };
                
                request.onsuccess = (event) => {
                    this.db = event.target.result;
                    this.ready = true;
                    console.log('Veritabanı başarıyla açıldı');
                    resolve(this.db);
                };
            });
            
            return this.initPromise;
        }
        
        async get(storeName, key) {
            await this.init();
            
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(key);
                
                request.onerror = (event) => {
                    console.error(`Veri getirme hatası (${storeName}):`, event);
                    reject(event.target.error);
                };
                
                request.onsuccess = (event) => {
                    resolve(request.result);
                };
            });
        }
        
        async put(storeName, data) {
            await this.init();
            
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(data);
                
                request.onerror = (event) => {
                    console.error(`Veri kaydetme hatası (${storeName}):`, event);
                    reject(event.target.error);
                };
                
                request.onsuccess = (event) => {
                    resolve(request.result);
                };
            });
        }
        
        async delete(storeName, key) {
            await this.init();
            
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(key);
                
                request.onerror = (event) => {
                    console.error(`Veri silme hatası (${storeName}):`, event);
                    reject(event.target.error);
                };
                
                request.onsuccess = (event) => {
                    resolve();
                };
            });
        }
        
        async getAll(storeName) {
            await this.init();
            
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.getAll();
                
                request.onerror = (event) => {
                    console.error(`Tüm verileri getirme hatası (${storeName}):`, event);
                    reject(event.target.error);
                };
                
                request.onsuccess = (event) => {
                    resolve(request.result);
                };
            });
        }
        
        async clear(storeName) {
            await this.init();
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.clear();
                request.onerror = (event) => {
                    console.error(`Depo temizleme hatası (${storeName}):`, event);
                    reject(event.target.error);
                };
                request.onsuccess = (event) => {
                    resolve();
                };
            });
        }
    }
    
    // TheOracle sınıfı - Piyasadaki Mahşerin Atlıları durumlarını analiz eder
    /**
     * TheOracle - Piyasa rejimi tespit motoru
     * Mahşerin Dört Atlısını (KITLIK, SALGIN, SAVAŞ, ÖLÜM) metriklerle tespit eder
     * ve diğer sistem bileşenlerine piyasa koşullarını bildirir
     */
    class TheOracle {
        constructor(app) {
            this.app = app;
            this.isInitialized = false;
            
            // Piyasa Rejimleri
            this.marketRegimes = {
                NORMAL: "NORMAL",   // Normal piyasa koşulları
                KITLIK: "KITLIK",   // Düşük volatilite, düşük hacim (Yatay/Konsolidasyon)
                SALGIN: "SALGIN",   // Yüksek volatilite, yönsüz (Dalgalı/Ortalamaya Dönen)
                SAVAS: "SAVAŞ",     // Yüksek volatilite, yüksek hacim, yönlü (Güçlü Trend)
                OLUM: "ÖLÜM"        // Ekstrem olay, yapısal kırılma (Çöküş/Ani Yükseliş)
            };
            
            // Aktif piyasa rejimi (varsayılan: normal)
            this.currentRegime = this.marketRegimes.NORMAL;
            this.previousRegime = this.marketRegimes.NORMAL;
            
            // Legacy horsemen desteği
            this.horsemen = {
                war: false,       // Savaş (yüksek volatilite)
                famine: false,    // Kıtlık (düşük likidite)
                pestilence: false, // Veba (ani trendler)
                death: false      // Ölüm (ciddi düşüş)
            };
            
            // Analiz pencereleri (periyot sayısı)
            this.volatilityWindow = 14;     // ATR hesaplama penceresi
            this.volumeWindow = 20;         // Hacim normalizasyon penceresi
            this.adxWindow = 14;           // ADX hesaplama penceresi
            this.maWindow = 50;            // Trend analiz penceresi
            
            // Rejim eşikleri
            this.thresholds = {
                // KITLIK için eşikler
                lowVolatility: 0.7,        // ATR ortalamaya göre % olarak (< %70 = düşük volatilite)
                lowVolume: 0.8,            // Hacim ortalamaya göre % olarak (< %80 = düşük hacim)
                
                // SALGIN için eşikler
                highVolatility: 1.5,       // ATR ortalamaya göre % olarak (> %150 = yüksek volatilite)
                lowAdx: 20,                // Düşük ADX değeri (< 20 = zayıf trend)
                
                // SAVAŞ için eşikler
                warVolatility: 1.3,        // ATR ortalamaya göre % olarak (> %130)
                highAdx: 25,               // Yüksek ADX değeri (> 25 = güçlü trend)
                highVolume: 1.3,           // Hacim ortalamaya göre % olarak (> %130)
                
                // ÖLÜM için eşikler
                extremeVolatility: 2.5,    // ATR ortalamaya göre % olarak (> %250 = ekstrem volatilite)
                crashThreshold: -5.0,      // Tek periyotta % düşüş (< -%5 = çöküş)
                spikeThreshold: 5.0        // Tek periyotta % yükseliş (> %5 = ani yükseliş)
            };
            
            // Metrik depoları
            this.metrics = {
                atr: [],              // ATR değerleri
                atrAvg: 0,            // Ortalama ATR
                volume: [],           // Hacim değerleri
                volumeAvg: 0,         // Ortalama hacim
                adx: 0,               // En son ADX değeri
                priceChange: 0,       // Son periyottaki % fiyat değişimi
                maSlope: 0            // Hareketli ortalama eğimi
            };
            
            // Zaman içinde takip için
            this.regimeHistory = [];  // Rejim değişikliklerini takip eder
            this.lastUpdate = Date.now();
            this.updateFrequency = 60000; // ms cinsinden güncelleme sıklığı (1 dakika)
            
            this.averageVolume = 0;
            this.averageRange = 0;
            this.trendStrength = 0;
            
            this.updateInterval = 60000; // 1 dakika
            this.lastUpdate = 0;
        }
        
        async init() {
            if (this.isInitialized) return;
            
            try {
                // İlk metrikleri hesapla
                await this.calculateMetrics();
                
                // İlk rejim analizi yap
                this.detectMarketRegime();
                
                // Düzenli güncelleme ayarla
                this.updateTimer = setInterval(() => this.update(), this.updateFrequency);
                
                this.isInitialized = true;
                console.log('TheOracle initialized with market regime detection v2.0');
            } catch (error) {
                console.error('TheOracle initialization error:', error);
            }
        }
        
        async update() {
            try {
                const now = Date.now();
                const elapsed = now - this.lastUpdate;
                // Eğer son güncellemeden sonra yeterli zaman geçmediyse çık
                if (elapsed < this.updateFrequency * 0.9) return;
                this.lastUpdate = now;
                // Metrikleri güncelle
                await this.calculateMetrics();
                // Önceki rejimi hatırla
                this.previousRegime = this.currentRegime;
                // Piyasa rejimini tespit et
                this.detectMarketRegime();
                // Eğer rejim değiştiyse bildir
                if (this.previousRegime !== this.currentRegime) {
                    this.notifyRegimeChange();
                }
                // Legacy horsemen'i güncelle
                this.updateHorsemenFromRegime();
            } catch (error) {
                console.error('TheOracle update error:', error);
            }
        }
        
        // Four Horsemen Piyasa Rejim Tespiti
        detectMarketRegime() {
            if (!this.app || !this.app.candles || this.app.candles.length < 20) {
                this.currentRegime = 'NORMAL';
                return;
            }
            
            const candles = this.app.candles.slice(-20);
            const prices = candles.map(c => c.close);
            const volumes = candles.map(c => c.volume);
            
            // Volatilite analizi
            const volatility = this.calculateVolatility(prices);
            const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
            const recentVolume = volumes.slice(-5).reduce((a, b) => a + b, 0) / 5;
            
            // Trend analizi
            const trendStrength = this.calculateTrendStrength(prices);
            const priceChange = ((prices[prices.length - 1] - prices[0]) / prices[0]) * 100;
            
            // ATR ile volatilite ölçümü
            const atr = this.app.indicators?.atr || 0;
            const currentPrice = prices[prices.length - 1];
            const atrPercentage = atr / currentPrice * 100;
            
            // Four Horsemen Rejim Tespiti
            this.previousRegime = this.currentRegime;
            
            // ÖLÜM: Büyük düşüş ve yüksek volatilite
            if (priceChange < -5 && atrPercentage > 3) {
                this.currentRegime = 'ÖLÜM';
            }
            // SAVAŞ: Güçlü trend ve artan volatilite
            else if (Math.abs(trendStrength) > 0.7 && atrPercentage > 2) {
                this.currentRegime = 'SAVAŞ';
            }
            // SALGIN: Yüksek volatilite ama zayıf trend
            else if (atrPercentage > 2 && Math.abs(trendStrength) < 0.3) {
                this.currentRegime = 'SALGIN';
            }
            // KITLIK: Düşük volatilite ve hacim
            else if (atrPercentage < 1 && recentVolume < avgVolume * 0.7) {
                this.currentRegime = 'KITLIK';
            }
            else {
                this.currentRegime = 'NORMAL';
            }
            
            // Panteon sistemine rejim güncellemesi gönder
            if (window.pantheon && window.pantheon.system) {
                window.pantheon.system.currentRegime = this.currentRegime;
            }
            
            console.log(`Market Regime: ${this.currentRegime} (Vol: ${atrPercentage.toFixed(2)}%, Trend: ${trendStrength.toFixed(2)}, Price Change: ${priceChange.toFixed(2)}%)`);
        }
        
        notifyRegimeChange() {
            if (this.previousRegime === this.currentRegime) return;
            
            const regimeNames = {
                'KITLIK': 'Kıtlık Atlısı - Düşük likidite ve volatilite',
                'SALGIN': 'Salgın Atlısı - Kaotik ve dalgalı piyasa',
                'SAVAŞ': 'Savaş Atlısı - Güçlü trend ve yüksek volatilite',
                'ÖLÜM': 'Ölüm Atlısı - Büyük düşüş ve ekstrem volatilite',
                'NORMAL': 'Normal Piyasa Durumu'
            };
            
            const message = `🏇 Piyasa Rejimi Değişti: ${regimeNames[this.currentRegime]}`;
            
            if (this.app.showNotification) {
                this.app.showNotification(message, 'divine');
            }
            
            if (this.app.speak) {
                this.app.speak(`Piyasa rejimi değişti. ${regimeNames[this.currentRegime]}`);
            }
        }
        
        calculateBaseMetrics() {
            if (!this.app.candles || this.app.candles.length < 20) return;
            
            const candles = this.app.candles.slice(-20);
            
            // Ortalama hacim hesapla
            let totalVolume = 0;
            candles.forEach(candle => {
                totalVolume += candle.volume;
            });
            this.averageVolume = totalVolume / candles.length;
            
            // Ortalama fiyat aralığı hesapla
            let totalRange = 0;
            candles.forEach(candle => {
                const range = candle.high - candle.low;
                totalRange += range;
            });
            this.averageRange = totalRange / candles.length;
            
            // Trend gücü hesapla (basit lineer regresyon eğimi)
            const prices = candles.map(c => c.close);
            this.trendStrength = this.calculateTrendStrength(prices);
        }
        
        calculateTrendStrength(prices) {
            const n = prices.length;
            let sumX = 0;
            let sumY = 0;
            let sumXY = 0;
            let sumX2 = 0;
            
            for (let i = 0; i < n; i++) {
                sumX += i;
                sumY += prices[i];
                sumXY += i * prices[i];
                sumX2 += i * i;
            }
            
            // Lineer regresyon eğimi hesapla
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            
            // Normalize edilmiş eğim (yüzde olarak)
            const normalizedSlope = (slope / prices[0]) * 100;
            
            return normalizedSlope;
        }
        
        updateHorsemen() {
            if (!this.app.candles || this.app.candles.length < 20) return;
            
            const candles = this.app.candles;
            const recent = candles.slice(-5);
            const current = candles[candles.length - 1];
            const previous = candles[candles.length - 2];
            
            this.calculateBaseMetrics();
            
            // Reset statuses
            Object.keys(this.horsemen).forEach(key => {
                this.horsemen[key] = false;
            });
            
            // Savaş: Yüksek volatilite
            const recentVolatility = this.calculateVolatility(recent.map(c => c.close));
            if (recentVolatility > this.volatilityThreshold) {
                this.horsemen.war = true;
            }
            
            // Kıtlık: Düşük likidite
            const currentVolume = current.volume;
            if (currentVolume < this.averageVolume * this.liquidityThreshold) {
                this.horsemen.famine = true;
            }
            
            // Veba: Ani trendler
            const recentTrendStrength = this.calculateTrendStrength(recent.map(c => c.close));
            if (Math.abs(recentTrendStrength) > Math.abs(this.trendStrength) * this.trendThreshold) {
                this.horsemen.pestilence = true;
            }
            
            // Ölüm: Ciddi düşüş
            const priceChange = ((current.close - previous.close) / previous.close) * 100;
            if (priceChange < this.dropThreshold) {
                this.horsemen.death = true;
            }
            
            this.lastUpdate = Date.now();
            
            // UI güncelle
            this.updateUI();
            
            // Eğer atlılardan biri aktifse, bildirim gönder
            const activeHorsemen = Object.entries(this.horsemen).filter(([_, active]) => active);
            
            if (activeHorsemen.length > 0) {
                const names = {
                    war: "Savaş",
                    famine: "Kıtlık",
                    pestilence: "Veba",
                    death: "Ölüm"
                };
                
                const message = `Mahşerin ${activeHorsemen.length > 1 ? "Atlıları" : "Atlısı"} görüldü: ${activeHorsemen.map(([key, _]) => names[key]).join(", ")}`;
                
                if (this.app.notificationManager) {
                    this.app.notificationManager.notify(message, 'warning', 3);
                }
            }
        }
        
        calculateVolatility(prices) {
            const n = prices.length;
            if (n < 2) return 0;
            
            // Ortalama hesapla
            const avg = prices.reduce((sum, price) => sum + price, 0) / n;
            
            // Varyans hesapla
            const variance = prices.reduce((sum, price) => {
                return sum + Math.pow(price - avg, 2);
            }, 0) / (n - 1);
            
            // Standart sapma
            const stdDev = Math.sqrt(variance);
            
            // Fiyat yüzdesi olarak volatilite
            return (stdDev / avg) * 100;
        }
        
        updateUI() {
            const container = document.getElementById('mahser-atlilari');
            if (!container) return;
            
            // Her atlı için durum güncelle
            Object.entries(this.horsemen).forEach(([horseman, active]) => {
                const element = document.querySelector(`.atlı[data-atli="${horseman}"]`);
                if (element) {
                    element.classList.toggle('active', active);
                }
            });
        }
        
        getHorsemanName(key) {
            const names = {
                war: "Savaş",
                famine: "Kıtlık",
                pestilence: "Veba",
                death: "Ölüm"
            };
            return names[key] || key;
        }
        
        getActiveHorsemen() {
            return Object.entries(this.horsemen)
                .filter(([_, active]) => active)
                .map(([key, _]) => key);
        }
        
        isAnyHorsemanActive() {
            return Object.values(this.horsemen).some(active => active);
        }
    }

    // MultiTimeframeManager sınıfı - Çoklu zaman dilimi analizi
    class MultiTimeframeManager {
        constructor(app) {
            this.app = app;
            this.timeframes = ['1m', '5m', '15m', '1h', '4h', '1d'];
            this.data = {}; // Her zaman dilimi için ayrı veri
            this.signals = {}; // Her zaman dilimi için ayrı sinyal
            this.activeTimeframe = '15m'; // Varsayılan zaman dilimi
            this.isInitialized = false;
            this.updateIntervals = {
                '1m': 60000,
                '5m': 300000,
                '15m': 900000,
                '1h': 3600000,
                '4h': 14400000,
                '1d': 86400000
            };
            this.updateTimers = {};
        }
        
        async init() {
            if (this.isInitialized) return;
            
            try {
                // Arayüz elementlerini oluştur
                this.createTimeframeTabs();
                
                // Her zaman dilimi için veri yükle
                for (const tf of this.timeframes) {
                    await this.loadTimeframeData(tf);
                }
                
                // Güncelleme zamanlayıcılarını ayarla
                this.setupUpdateTimers();
                
                this.isInitialized = true;
                console.log('MultiTimeframeManager başlatıldı');
            } catch (error) {
                console.error('MultiTimeframeManager başlatma hatası:', error);
            }
        }
        
        // initialize metodu için uyumluluk katmanı
        async initialize(symbol, timeframes) {
            this.timeframes = timeframes || this.timeframes;
            // Sembol ayarını güncelle
            if (symbol && this.app) {
                this.app.currentSymbol = symbol;
            }
            // init metodunu çağır
            return this.init();
        }
        
        createTimeframeTabs() {
            const controlsContainer = document.querySelector('.controls');
            if (!controlsContainer) return;
            
            // Sekmeleri içerecek konteyner
            const tabsContainer = document.createElement('div');
            tabsContainer.className = 'tabs-container';
            tabsContainer.style.marginLeft = '10px';
            
            // Zaman dilimlerini sırayla sekmelere ekle
            this.timeframes.forEach(tf => {
                const tab = document.createElement('div');
                tab.className = 'tab';
                tab.dataset.timeframe = tf;
                tab.textContent = tf;
                if (tf === this.activeTimeframe) {
                    tab.classList.add('active');
                }
                
                tab.addEventListener('click', () => this.switchTimeframe(tf));
                
                tabsContainer.appendChild(tab);
            });
            
            controlsContainer.appendChild(tabsContainer);
        }
        
        // Binance veya başka bir kaynaktan API endpoint oluşturur
        buildApiEndpoint(timeframe) {
            const symbol = this.app.symbol || 'BTCUSDT';
            const limit = 500;
            
            // Zaman dilimini Binance formatına çevir
            let interval;
            switch (timeframe) {
                case '1m': interval = '1m'; break;
                case '5m': interval = '5m'; break;
                case '15m': interval = '15m'; break;
                case '1h': interval = '1h'; break;
                case '4h': interval = '4h'; break;
                case '1d': interval = '1d'; break;
                default: interval = '15m';
            }
            
            // Demo veri kullanıyoruz - gerçek API'ye bağlanmak yerine statik veriyi kullan
            return `https://api.example.com/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
        }
        
        async loadTimeframeData(timeframe) {
            try {
                // Endpoint oluştur - app'e bağlı olmadan kendi metodumuzu kullanıyoruz
                const endpoint = this.buildApiEndpoint(timeframe);
                
                // Demo veri kullanıyoruz - gerçek API'ye bağlanmak yerine
                // Eğer app nesnesi içinde candles verisi varsa onu kullanalım
                if (this.app && this.app.candles && this.app.candles.length > 0) {
                    this.data[timeframe] = [...this.app.candles]; // var olan verileri kullan
                    
                    // Sinyalleri hesapla
                    this.generateSignals(timeframe);
                    
                    console.log(`${timeframe} verileri yüklendi (yerel veri)`);
                    
                    // Aktif zaman dilimi ise, ana uygulamada kullan
                    if (timeframe === this.activeTimeframe) {
                        this.applyTimeframeData(timeframe);
                    }
                    
                    return this.data[timeframe];
                }
                
                // Gerçek API'ye bağlanmayı simüle edelim
                console.log(`${timeframe} için demo veri kullanılıyor`);
                
                // Demo veri oluştur
                const demoData = this.generateDemoData(timeframe, 500);
                this.data[timeframe] = demoData;
                
                // Sinyalleri hesapla
                this.generateSignals(timeframe);
                
                console.log(`${timeframe} verileri yüklendi (demo veri)`);
                
                // Aktif zaman dilimi ise, ana uygulamada kullan
                if (timeframe === this.activeTimeframe) {
                    this.applyTimeframeData(timeframe);
                }
                
                return demoData;
            } catch (error) {
                console.log(`${timeframe} verileri yüklenirken hata:`, error);
                return [];
            }
        }
        
        // Demo veri oluşturma metodu
        generateDemoData(timeframe, count = 500) {
            const now = new Date().getTime();
            const data = [];
            
            // Zaman aralığını belirle (milisaniye cinsinden)
            let interval;
            switch (timeframe) {
                case '1m': interval = 60 * 1000; break;
                case '5m': interval = 5 * 60 * 1000; break;
                case '15m': interval = 15 * 60 * 1000; break;
                case '1h': interval = 60 * 60 * 1000; break;
                case '4h': interval = 4 * 60 * 60 * 1000; break;
                case '1d': interval = 24 * 60 * 60 * 1000; break;
                default: interval = 15 * 60 * 1000;
            }
            
            // Son fiyat
            let lastPrice = 40000 + Math.random() * 10000;
            
            // Geçmiş verileri oluştur
            for (let i = count - 1; i >= 0; i--) {
                const time = now - (i * interval);
                
                // Fiyat değişimi (yüzde -1 ile +1 arası)
                const change = (Math.random() * 2 - 1) * 0.01;
                lastPrice = lastPrice * (1 + change);
                
                // Açılış, yüksek, düşük ve kapanış fiyatları
                const open = lastPrice;
                const high = open * (1 + Math.random() * 0.005);
                const low = open * (1 - Math.random() * 0.005);
                const close = (open + high + low) / 3; // Ortalama bir kapanış
                
                // Hacim
                const volume = Math.random() * 100 + 50;
                
                data.push({
                    time: time,
                    open: open,
                    high: high,
                    low: low,
                    close: close,
                    volume: volume
                });
            }
            
            return data;
        }
        
        // Sinyal oluşturma metodu - zaman dilimine özgü sinyaller üretir
        generateSignals(timeframe) {
            if (!this.signals[timeframe]) {
                this.signals[timeframe] = [];
            }
            
            if (!this.data[timeframe] || this.data[timeframe].length === 0) {
                return; // Veri yoksa sinyal üretme
            }
            
            // İlgili zaman dilimi için stratejileri kullanarak sinyal üret
            const candles = this.data[timeframe];
            if (this.app.strategies) {
                // Strateji sınıflarını kullanarak sinyal üret
                for (const strategy of Object.values(this.app.strategies)) {
                    if (!strategy.isEnabled()) continue;
                    
                    const strategySignals = strategy.analyze(candles);
                    if (strategySignals && strategySignals.length > 0) {
                        this.signals[timeframe] = this.signals[timeframe].concat(strategySignals);
                    }
                }
            } else {
                // Basit örnek: Her 10 mumda bir sinyal üret
                for (let i = 10; i < candles.length; i += 10) {
                    const candle = candles[i];
                    
                    if (candle.close > candle.open) {
                        // Yükselen mum - alış sinyali
                        this.signals[timeframe].push({
                            time: candle.time,
                            type: 'buy',
                            price: candle.close,
                            reason: `${timeframe} zaman diliminde yükselen mum paterni`,
                            strength: 0.7
                        });
                    } else {
                        // Düşen mum - satış sinyali
                        this.signals[timeframe].push({
                            time: candle.time,
                            type: 'sell',
                            price: candle.close,
                            reason: `${timeframe} zaman diliminde düşen mum paterni`,
                            strength: 0.7
                        });
                    }
                }
            }
            
            // Sinyalleri sınırla
            if (this.signals[timeframe].length > 50) {
                this.signals[timeframe] = this.signals[timeframe].slice(-50);
            }
        }
        
        applyTimeframeData(timeframe) {
            if (!this.data[timeframe]) return;
            
            // Ana uygulama verilerini güncelle
            this.app.candles = this.data[timeframe];
            this.app.signals = this.signals[timeframe] || [];
            
            // Grafik ve sinyal gösterimini güncelle
            if (this.app.updateChart) this.app.updateChart();
            if (this.app.updateSignals) this.app.updateSignals();
        }
        
        switchTimeframe(timeframe) {
            if (!this.timeframes.includes(timeframe) || timeframe === this.activeTimeframe) return;
            
            // Sekme arayüzünü güncelle
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.timeframe === timeframe);
            });
            
            // Aktif zaman dilimini güncelle
            this.activeTimeframe = timeframe;
            
            // Veriyi uygula
            this.applyTimeframeData(timeframe);
            
            // Kullanıcıyı bilgilendir
            if (this.app.notificationManager) {
                this.app.notificationManager.notify(`Zaman dilimi ${timeframe} olarak değiştirildi`, 'info', 1);
            }
        }
        
        setupUpdateTimers() {
            // Her zaman dilimi için otomatik güncelleme ayarla
            for (const tf of this.timeframes) {
                const interval = this.updateIntervals[tf];
                
                if (interval) {
                    // Önceki zamanlayıcıyı temizle
                    if (this.updateTimers[tf]) {
                        clearInterval(this.updateTimers[tf]);
                    }
                    
                    // Yeni zamanlayıcı oluştur
                    this.updateTimers[tf] = setInterval(async () => {
                        console.log(`${tf} verileri güncelleniyor...`);
                        await this.loadTimeframeData(tf);
                        
                        if (tf === this.activeTimeframe) {
                            this.applyTimeframeData(tf);
                        }
                    }, interval);
                }
            }
        }
        
        destroy() {
            // Zamanlayıcıları temizle
            for (const timer of Object.values(this.updateTimers)) {
                clearInterval(timer);
            }
            
            // Veriyi temizle
            this.data = {};
            this.updateTimers = {};
            
            console.log('MultiTimeframeManager temizlendi');
        }
        
        // cleanup metodu destroy metodunun alias'ı olarak tanımlanıyor
        cleanup() {
            return this.destroy();
        }
    }

    // Confluence Engine - Farklı sinyallerin birleşimi
    // Strateji birleştirme motoru
    class ConfluenceEngine {
        constructor(app) {
            this.app = app;
            this.confluenceEnabled = true;
            this.minConfluenceScore = 3; // Minimum gerekli birleşim puanı
            this.weightedStrategies = {
                'rsi': 1,
                'macd': 1.2,
                'supertrend': 1.5,
                'bollinger': 1.2,
                'ichimoku': 1.3,
                'fractals': 0.7
            };
        }
        
        validateSignal(signal) {
            if (!this.confluenceEnabled) return true;
            
            const confluenceScore = this.calculateConfluenceScore(signal);
            return confluenceScore >= this.minConfluenceScore;
        }
        
        calculateConfluenceScore(signal) {
            if (!signal || !signal.type || !this.app.strategies) return 0;
            
            let score = 0;
            const direction = signal.type === 'buy' ? 1 : -1;
            
            // Tüm stratejilerden son sinyalleri al
            for (const [name, strategy] of Object.entries(this.app.strategies)) {
                if (!strategy.isEnabled()) continue;
                
                const latestSignal = strategy.getLastSignal();
                if (!latestSignal) continue;
                
                // Son sinyal ile aynı yönde mi?
                const signalDirection = latestSignal.type === 'buy' ? 1 : -1;
                
                // Aynı yönde ise, stratejinin ağırlığını skora ekle
                if (signalDirection === direction) {
                    const weight = this.weightedStrategies[name] || 1;
                    score += weight;
                }
            }
            
            // Zaman çerçevesi kontrolü (birden fazla zaman diliminde aynı sinyal varsa bonus)
            if (this.app.multiTimeframeManager && this.app.multiTimeframeManager.signals) {
                const mtfSignals = this.app.multiTimeframeManager.signals;
                let timeframeConfluence = 0;
                
                for (const [tf, signals] of Object.entries(mtfSignals)) {
                    if (tf === this.app.multiTimeframeManager.activeTimeframe) continue;
                    
                    // Son 3 sinyale bak
                    const recentSignals = signals.slice(-3);
                    for (const tfSignal of recentSignals) {
                        if (tfSignal.type === signal.type) {
                            // Farklı zaman diliminde aynı yönde sinyal
                            timeframeConfluence += 0.5;
                            break;
                        }
                    }
                }
                
                score += timeframeConfluence;
            }
            
            // TheOracle kontrolü - Mahşerin Atlıları durumları
            if (this.app.oracle && this.app.oracle.isAnyHorsemanActive()) {
                const activeHorsemen = this.app.oracle.getActiveHorsemen();
                
                // Ölüm atlısı aktifse ve alış sinyali ise, skoru düşür
                if (activeHorsemen.includes('death') && signal.type === 'buy') {
                    score -= 1;
                }
                
                // Savaş atlısı aktifse ve yüksek volatilite varsa, skoru düşür
                if (activeHorsemen.includes('war')) {
                    score -= 0.5;
                }
            }
            
            return Math.round(score * 10) / 10; // Bir ondalık basamağa yuvarla
        }
        
        setMinConfluenceScore(score) {
            this.minConfluenceScore = score;
        }
        
        toggleConfluence(enabled) {
            this.confluenceEnabled = enabled;
        }
        
        setStrategyWeight(strategyName, weight) {
            if (this.weightedStrategies.hasOwnProperty(strategyName)) {
                this.weightedStrategies[strategyName] = weight;
            }
        }
        
        propose(strategy, direction, reason, score) {
            // Stratejilerden gelen sinyal önerilerini işle
            console.log(`[CONFLUENCE] ${strategy} stratejisinden ${direction} sinyali alındı: ${reason}`);
            
            // Burada sinyal işleme ve birleştirme mantığı eklenebilir
            // Şimdilik sadece log'lama ve temel işleme yapıyoruz
            const normalizedScore = score || 1.0;
            
            if (this.app && this.app.recordSignal) {
                this.app.recordSignal({
                    type: direction,
                    strategy: strategy,
                    reason: reason,
                    score: normalizedScore,
                    time: Date.now()
                });
            }
        }
    }

    // Sayfa yüklendiğinde çalışacak ana fonksiyon
    function initApp() {
        console.log('initApp başlatılıyor...');
        // Panteon UI için sürükleme özelliği ve mobil uyumluluğu
        const pantheonUI = document.getElementById('pantheon-ui');
        if (pantheonUI) {
            let isDragging = false;
            let offsetX, offsetY;
            
            function startDrag(e) {
                isDragging = true;
                offsetX = e.clientX - pantheonUI.getBoundingClientRect().left;
                offsetY = e.clientY - pantheonUI.getBoundingClientRect().top;
                pantheonUI.style.cursor = 'grabbing';
                e.preventDefault();
            }
            
            function onDrag(e) {
                if (!isDragging) return;
                pantheonUI.style.left = (e.clientX - offsetX) + 'px';
                pantheonUI.style.top = (e.clientY - offsetY) + 'px';
            }
            
            function stopDrag() {
                isDragging = false;
                pantheonUI.style.cursor = 'grab';
                
                // Pozisyonu kaydet
                const rect = pantheonUI.getBoundingClientRect();
                localStorage.setItem('pantheonUIPosition', JSON.stringify({
                    left: rect.left,
                    top: rect.top
                }));
            }
            
            // Event listener'ları ekle
            pantheonUI.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('mouseleave', stopDrag);
            
            // Kayıtlı pozisyonu yükle (sadece mobil değilse)
            if (window.innerWidth > 768) {
                const savedPosition = localStorage.getItem('pantheonUIPosition');
                if (savedPosition) {
                    try {
                        const { left, top } = JSON.parse(savedPosition);
                        pantheonUI.style.left = `${left}px`;
                        pantheonUI.style.top = `${top}px`;
                    } catch (e) {
                        console.error('Pozisyon yüklenirken hata:', e);
                    }
                }
            }
        }
        
        // Dikey panel butonları için olayları ekle
        const notificationsBtn = document.getElementById('notifications-btn');
        const pantheonToggleBtn = document.getElementById('pantheon-toggle-btn');
        const energyToggleBtn = document.getElementById('energy-toggle-btn');
        const ritualToggleBtn = document.getElementById('ritual-toggle-btn');
        const quickSettingsBtn = document.getElementById('quick-settings-btn');
        const verticalStatsBtn = document.getElementById('vertical-stats-btn');
        const verticalLogBtn = document.getElementById('vertical-log-btn');
        
        // Bildirim paneli kontrolü ve Bildirimler Menüsü
        if(notificationsBtn) {
            const notificationsContainer = document.getElementById('notifications-container');
            
            // Bildirimler menüsü oluştur
            const notificationMenu = document.createElement('div');
            notificationMenu.className = 'notification-menu';
            notificationMenu.style.display = 'none';
            notificationMenu.style.position = 'fixed';
            notificationMenu.style.right = '75px';
            notificationMenu.style.top = '50%';
            notificationMenu.style.transform = 'translateY(-50%)';
            notificationMenu.style.background = 'var(--panel-bg)';
            notificationMenu.style.border = '1px solid var(--border-color)';
            notificationMenu.style.borderRadius = '8px';
            notificationMenu.style.zIndex = '2100';
            notificationMenu.style.padding = '10px';
            notificationMenu.style.boxShadow = '0 2px 10px rgba(0,0,0,0.3)';
            
            notificationMenu.innerHTML = `
                <div class="notification-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <span style="font-weight: bold; color: var(--primary);">BİLDİRİMLER</span>
                    <div style="display: flex; gap: 5px;">
                        <button id="notification-history-btn" class="btn btn-tiny" title="Bildirim Geçmişi">📋</button>
                        <button id="clear-notifications" class="btn btn-tiny" title="Bildirimleri Temizle">🗑️</button>
                        <button id="toggle-notification-sound" class="btn btn-tiny" title="Sesi Aç/Kapat">🔊</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(notificationMenu);
            
            // Bildirim butonuna tıklandığında menüyü göster/gizle
            notificationsBtn.addEventListener('click', function() {
                const isMenuVisible = notificationMenu.style.display !== 'none';
                notificationMenu.style.display = isMenuVisible ? 'none' : 'block';
                notificationsBtn.classList.toggle('active', !isMenuVisible);
            });
            
            // Bildirimler konteynerinin göster/gizle mantığı
            const toggleNotifications = function() {
                const isVisible = notificationsContainer.style.display !== 'none';
                notificationsContainer.style.display = isVisible ? 'none' : 'block';
            };
            
            // Menüdeki butonlar için olay dinleyicileri
            document.getElementById('notification-history-btn')?.addEventListener('click', function() {
                if (window.app && window.app.notificationManager) {
                    window.app.notificationManager.showHistory();
                }
            });
            
            document.getElementById('clear-notifications')?.addEventListener('click', function() {
                if (window.app && window.app.notificationManager) {
                    window.app.notificationManager.clearAll();
                }
            });
            
            document.getElementById('toggle-notification-sound')?.addEventListener('click', function() {
                if (window.app && window.app.notificationManager) {
                    const notificationManager = window.app.notificationManager;
                    notificationManager.soundEnabled = !notificationManager.soundEnabled;
                    this.innerHTML = notificationManager.soundEnabled ? '🔊' : '🔇';
                    notificationManager.notify('Bildirim sesleri ' + (notificationManager.soundEnabled ? 'açıldı' : 'kapatıldı'), 'system', 1);
                }
            });
            
            // Sayfa dışına tıklandığında menüyü kapat
            document.addEventListener('click', function(event) {
                if (!notificationsBtn.contains(event.target) && 
                    !notificationMenu.contains(event.target) && 
                    notificationMenu.style.display !== 'none') {
                    notificationMenu.style.display = 'none';
                    notificationsBtn.classList.remove('active');
                }
            });
        }
        
        // Pantheon paneli kontrolü
        if(pantheonToggleBtn && pantheonUI) {
            pantheonToggleBtn.addEventListener('click', function() {
                // Mobil cihazlarda
                if(window.innerWidth <= 768) {
                    pantheonUI.classList.toggle('mobile-visible');
                } else {
                    // Masaüstü cihazlarda
                    pantheonUI.style.display = pantheonUI.style.display === 'none' ? 'block' : 'none';
                }
                pantheonToggleBtn.classList.toggle('active');
            });
        }
        
        // Enerji Yönetimi butonu
        if(energyToggleBtn) {
            energyToggleBtn.addEventListener('click', function() {
                if (window.app && window.app.energyManager) {
                    window.app.energyManager.toggleEnergyBox();
                    energyToggleBtn.classList.add('active');
                    setTimeout(() => energyToggleBtn.classList.remove('active'), 500);
                    
                    // Sesli bildirim
                    if (window.app.speak) {
                        window.app.speak("Enerji yönetim sistemi etkinleştirildi. Mevcut sistem enerjisi yüzde " + 
                            Math.round(window.app.energyManager.currentEnergy) + " seviyesinde.");
                    }
                }
            });
        }
        
        // Ritüel Sistemi butonu
        if(ritualToggleBtn) {
            ritualToggleBtn.addEventListener('click', function() {
                if (window.app && window.app.ritualManager) {
                    window.app.ritualManager.toggleRitualContainer();
                    ritualToggleBtn.classList.add('active');
                    setTimeout(() => ritualToggleBtn.classList.remove('active'), 500);
                    
                    // Sesli bildirim
                    if (window.app.speak) {
                        window.app.speak("Ritüel sistemi etkinleştirildi. Gizli güçlere erişim sağlanıyor.");
                    }
                }
            });
        }
        
        // Hızlı ayarlar butonu
        if(quickSettingsBtn) {
            quickSettingsBtn.addEventListener('click', function() {
                document.getElementById('settings-modal-overlay').classList.add('visible');
                quickSettingsBtn.classList.add('active');
                setTimeout(() => quickSettingsBtn.classList.remove('active'), 500);
            });
        }
        
        // İstatistikler butonu
        if(verticalStatsBtn) {
            verticalStatsBtn.addEventListener('click', function() {
                document.getElementById('honor-modal-overlay').style.display = 'flex';
                verticalStatsBtn.classList.add('active');
                setTimeout(() => verticalStatsBtn.classList.remove('active'), 500);
            });
        }
        
        // Log butonu
        if(verticalLogBtn) {
            verticalLogBtn.addEventListener('click', function() {
                document.getElementById('log-modal-overlay').classList.add('visible');
                verticalLogBtn.classList.add('active');
                setTimeout(() => verticalLogBtn.classList.remove('active'), 500);
            });
        }
        
        // Pantheon kapatma butonu
        const pantheonCloseBtn = document.querySelector('.pantheon-close');
        if(pantheonCloseBtn && pantheonUI) {
            pantheonCloseBtn.addEventListener('click', function() {
                if(window.innerWidth <= 768) {
                    pantheonUI.classList.remove('mobile-visible');
                } else {
                    pantheonUI.style.display = 'none';
                }
                if(pantheonToggleBtn) pantheonToggleBtn.classList.remove('active');
            });
        }
        
        // Sistemleri güvenli bir şekilde başlatma
        try {
            // App nesnesini başlat
            if (!window.app) {
                console.log('Trading Command Center başlatılıyor...');
                
                // UltimateTradingCommandCenter sınıfını kontrol et ve başlat
                if (typeof UltimateTradingCommandCenter === 'function') {
                    window.app = new UltimateTradingCommandCenter();
                    
                    // İleri düzey özellikleri başlat
                    if (typeof DBManager === 'function') {
                        window.app.dbManager = new DBManager();
                        window.app.dbManager.init();
                    }
                    
                    if (typeof EffectsManager === 'function') {
                        window.app.effectsManager = new EffectsManager();
                        window.app.effectsManager.init();
                    }
                    
                    // Panteon sistemini başlat
                    if (typeof PantheonSystem === 'function') {
                        window.app.panteonManager = new PantheonSystem();
                        if (window.app.panteonManager && typeof window.app.panteonManager.init === 'function') {
                            window.app.panteonManager.init();
                        }
                    }
                    
                    // Oracle (Mahşerin Atlıları) sistemini başlat
                    if (typeof TheOracle === 'function') {
                        window.app.oracle = new TheOracle(window.app);
                        window.app.oracle.init();
                    }
                    
                    // Çoklu zaman dilimi yöneticisini başlat
                    if (typeof MultiTimeframeManager === 'function') {
                        window.app.multiTimeframeManager = new MultiTimeframeManager(window.app);
                        window.app.multiTimeframeManager.init();
                    }
                    
                    // Confluence motorunu başlat
                    if (typeof ConfluenceEngine === 'function') {
                        window.app.confluenceEngine = new ConfluenceEngine(window.app);
                    }
                } else {
                    console.error('UltimateTradingCommandCenter sınıfı tanımlı değil!');
                }
            }
        } catch (e) {
            console.error('Sistemleri başlatırken hata:', e);
        }
        
        // Panteon güç yönetimini başlat
        if (window.app && !window.app.pantheonPower) {
            window.app.pantheonPower = {
                buy: 0,
                sell: 0,
                lastUpdate: Date.now()
            };
        }
        
        // Panteon metodlarını app nesnesine güvenli bir şekilde bağla
        if (window.panteon && window.app) {
            if (window.panteon.increasePantheonPower) {
                window.app.increasePantheonPower = window.panteon.increasePantheonPower.bind(window.panteon);
            }
            if (window.panteon.updatePantheonUI) {
                window.app.updatePantheonUI = window.panteon.updatePantheonUI.bind(window.panteon);
            }
            if (window.panteon.triggerElciSpecialAbility) {
                window.app.triggerElciSpecialAbility = window.panteon.triggerElciSpecialAbility.bind(window.panteon);
            }
        } else {
            console.warn('Panteon veya App nesneleri henüz hazır değil.');
        }
        
        // Panteon arayüzünü güncelle
        if (window.app && window.app.updatePantheonUI) {
            window.app.updatePantheonUI();
        }
    }
    
    // Sayfa yüklendiğinde başlatma işlemlerini sıraya koyuyoruz
    // Tüm sınıfların yüklenmesinin ardından çalışması için setTimeout kullanıyoruz
    document.addEventListener('DOMContentLoaded', function() {
        // Sınıfların yüklenmesi için bir mikrosaniye bekle
        setTimeout(function() {
            // İlk olarak ana uygulamayı başlat
            initApp();
            
            // Ardından ek sistemleri güvenli bir şekilde başlat
            try {
                // Önce UltimateTradingCommandCenter'ın başlatılmış olduğunu kontrol et
                if (!window.app && typeof UltimateTradingCommandCenter === 'function') {
                    window.app = new UltimateTradingCommandCenter();
                    console.log('UltimateTradingCommandCenter tekrar başlatıldı');
                }
                
                // Panteon Sistemini başlat (eğer henüz başlatılmadıysa)
                if (typeof PantheonSystem === 'function' && !window.panteon) {
                    window.panteon = new PantheonSystem();
                    console.log('Panteon Sistemi başlatıldı');
                }
                
                // Advanced Trading Visualization Manager
                if (typeof AdvancedTradingVisualizer === 'function' && window.app) {
                    window.advancedVisualizer = new AdvancedTradingVisualizer(window.app);
                }
                
                // Enhanced Risk Management System
                if (typeof EnhancedRiskManagement === 'function' && window.app) {
                    window.riskManager = new EnhancedRiskManagement(window.app);
                }
                
                // Panteon metodlarını app nesnesine güvenli bir şekilde bağla (eğer henüz bağlanmadıysa)
                if (window.panteon && window.app) {
                    const pantheonMethods = [
                        'increasePantheonPower',
                        'updatePantheonUI',
                        'triggerElciSpecialAbility'
                    ];
                    
                    // Her metodu kontrol et ve bağla
                    pantheonMethods.forEach(methodName => {
                        if (typeof window.panteon[methodName] === 'function' && !window.app[methodName]) {
                            window.app[methodName] = function(...args) {
                                if (window.panteon && typeof window.panteon[methodName] === 'function') {
                                    return window.panteon[methodName].apply(window.panteon, args);
                                } else {
                                    console.warn(`Panteon metodu ${methodName} artık mevcut değil.`);
                                    return null;
                                }
                            };
                        }
                    });
                    
                    console.log('Panteon metodları başarıyla bağlandı.');
                }
                
                console.log('Tüm sistemler başlatıldı ve hazır.');
            } catch (error) {
                console.error('Ek sistemler başlatılırken hata:', error);
            }
        }, 100); // 100ms bekleyerek tüm sınıfların yüklenmesini garanti edelim
    });
    </script>

    <style>
        :root {
            --primary-font: 'Orbitron', monospace;
            --secondary-font: 'Roboto Mono', monospace;
            
            /* Dark Theme - Default War Room */
            --bg-primary: #0a0a0f;
            --bg-secondary: #14141f;
            --bg-tertiary: #1a1a2e;
            --border-color: #2a2a3e;
            --text-primary: #e8e8ff;
            --text-secondary: #a8a8c8;
            --text-muted: #686888;
            
            /* Status Colors */
            --success: #00ff88;
            --danger: #ff3366;
            --warning: #ffaa00;
            --info: #00aaff;
            
            /* Special Effects */
            --glow-success: 0 0 20px rgba(0, 255, 136, 0.5);
            --glow-danger: 0 0 20px rgba(255, 51, 102, 0.5);
            --glow-warning: 0 0 20px rgba(255, 170, 0, 0.5);
            --glow-info: 0 0 20px rgba(0, 170, 255, 0.5);
            
            /* War Mode */
            --war-bg: linear-gradient(135deg, #1a0000 0%, #000000 50%, #1a0000 100%);
            --war-accent: #ff0040;
            --war-glow: 0 0 30px rgba(255, 0, 64, 0.8);

            /* Backward compatibility */
            --background-dark: var(--bg-primary); 
            --panel-bg-dark: var(--bg-secondary); 
            --text-main-dark: var(--text-primary);
            --text-secondary-dark: var(--text-secondary);
            --border-color-dark: var(--border-color);
            --input-bg-dark: #070711;
            --hover-bg-dark: #22223a;
            --primary-dark: var(--info);
            
            --background-light: #ffffff; 
            --panel-bg-light: #f6f8fa; 
            --text-main-light: #24292f; 
            --text-secondary-light: #57606a; 
            --border-color-light: #d0d7de; 
            --input-bg-light: #f0f2f5; 
            --hover-bg-light: #e8eaed; 
            --primary-light: #0969da;
            
            --war-mode-bg: var(--war-bg);
            --war-mode-panel-bg: rgba(255, 0, 0, 0.08); 
            --war-mode-border: #8B0000; 
            --war-mode-text: #ff5858; 
            --war-mode-primary: var(--war-accent);
            
            --positive: var(--success);
            --negative: var(--danger);
            --neutral: var(--warning);
            
            --ticker-height: 30px; 
            --signal-bar-height: 40px;
            --header-min-height: 40px;
            
            /* Panteon Renkleri - Geliştirilmiş */
            --metatron-color: #3b82f6; --metatron-glow: rgba(59, 130, 246, 0.3); --metatron-bg: rgba(59, 130, 246, 0.1);
            --uriel-color: #f59e0b; --uriel-glow: rgba(245, 158, 11, 0.3); --uriel-bg: rgba(245, 158, 11, 0.1);
            --raphael-color: #10b981; --raphael-glow: rgba(16, 185, 129, 0.3); --raphael-bg: rgba(16, 185, 129, 0.1);
            --gabriel-color: #8b5cf6; --gabriel-glow: rgba(139, 92, 246, 0.3); --gabriel-bg: rgba(139, 92, 246, 0.1);
            --michael-color: #ef4444; --michael-glow: rgba(239, 68, 68, 0.3); --michael-bg: rgba(239, 68, 68, 0.1);
        }
        /* Fullscreen modda gizlenecek elemanlar */
        body.fullscreen-chart #super-top-ticker,
        body.fullscreen-chart #signal-progress-bar-container,
        body.fullscreen-chart .header,
        body.fullscreen-chart .panel-title {
            display: none !important;
        }

        /* Fullscreen modda chart'ı büyütme */
        body.fullscreen-chart .container { padding-top: 0 !important; height: 100vh !important; }
        body.fullscreen-chart .main-grid { height: 100vh !important; margin: 0 !important; }
        body.fullscreen-chart .center-panel { flex-grow: 1 !important; height: 100vh !important; border-radius: 0 !important; margin: 0 !important; }
        body.fullscreen-chart .data-container { height: 100% !important; }
        body.fullscreen-chart #chart-container-view,
        body.fullscreen-chart #live-chart { height: 100% !important; flex-grow: 1 !important; }
        body.fullscreen-chart .heatmap-container { display: none !important; }
        body.fullscreen-chart .chart-zoom-controls { background: rgba(0,0,0,0.7); }
        body.fullscreen-chart #exit-fullscreen-btn { display: block !important; }
        body.fullscreen-chart #chart-countdown-overlay { display: block !important; }

        [data-theme="light"] { --background: var(--background-light); --panel-bg: var(--panel-bg-light); --text-main: var(--text-main-light); --text-secondary: var(--text-secondary-light); --border-color: var(--border-color-light); --input-bg: var(--input-bg-light); --hover-bg: var(--hover-bg-light); --primary: var(--primary-light); }
        [data-theme="dark"] { --background: var(--background-dark); --panel-bg: var(--panel-bg-dark); --text-main: var(--text-main-dark); --text-secondary: var(--text-secondary-dark); --border-color: var(--border-color-dark); --input-bg: var(--input-bg-dark); --hover-bg: var(--hover-bg-dark); --primary: var(--primary-dark); }
        [data-theme="war"] {
            --bg-primary: #0d0000;
            --bg-secondary: #1a0505;
            --bg-tertiary: #2a0a0a;
            --border-color: #4a0a0a;
            --text-primary: #ff6666;
            --text-secondary: #cc4444;
            --success: #ffff00;
            --danger: #ff0000;
            --background: var(--war-mode-bg);
            --panel-bg: var(--war-mode-panel-bg);
            --text-main: var(--war-mode-text);
            --text-secondary: #ffaaaa;
            --border-color: var(--war-mode-border);
            --input-bg: rgba(255, 255, 255, 0.05);
            --hover-bg: rgba(255, 255, 255, 0.1);
            --primary: var(--war-mode-primary);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: var(--secondary-font);
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            position: relative;
            transition: background 0.5s, color 0.5s;
        }

        /* Animasyonlu Arka Plan Izgarası */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 136, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 136, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: grid-move 10s linear infinite;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes grid-move {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }
        
        #super-top-ticker { display: flex; position: fixed; top: 0; left: 0; width: 100%; background: var(--panel-bg); border-bottom: 1px solid var(--border-color); padding: 2px 10px; z-index: 1100; align-items: center; justify-content: space-between; font-size: 11px; font-weight: 700; height: var(--ticker-height); }
        .super-top-left { display: flex; align-items: center; gap: 10px; flex-shrink: 0;}
        #ticker-bar-symbol { color: var(--primary); }
        #ticker-bar-price { color: var(--text-main); font-size: 12px; }
        .super-top-right-buttons { display: flex; gap: 5px; }

        .container { display: flex; flex-direction: column; height: 100vh; padding-top: calc(var(--ticker-height) + var(--signal-bar-height)); }

        .header { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 6px; flex-shrink: 0; box-shadow: 0 2px 10px rgba(0,0,0,0.2); margin: 5px; position: relative; }
        .header-top-bar { display: flex; align-items: center; width: 100%; padding: 5px 15px; min-height: var(--header-min-height); justify-content: space-between; cursor: pointer; font-weight: 700; font-size: 16px; color: var(--primary); }
        .header-collapsible-content { transition: max-height 0.35s ease-in-out, opacity 0.3s ease, padding 0.35s ease, visibility 0.35s; max-height: 300px; opacity: 1; overflow: hidden; visibility: visible; padding: 0 15px 8px 15px; }
        body.header-collapsed .header-collapsible-content { max-height: 0; opacity: 0; visibility: hidden; padding-top: 0; padding-bottom: 0; }

        .main-controls { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; padding-bottom: 8px; }
        .form-control { background: var(--input-bg); color: var(--text-main); border: 1px solid var(--border-color); border-radius: 4px; padding: 4px 8px; font-family: 'Roboto Mono', monospace; }
        
        .status { display: flex; align-items: center; gap: 5px; font-size: 11px; padding: 4px 8px; border: 1px solid var(--border-color); border-radius: 4px; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--negative); transition: background-color 0.5s; }
        .status-dot.online { background: var(--positive); animation: pulse 2s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 #28a745b3; } 70% { box-shadow: 0 0 0 6px #28a74500; } 100% { box-shadow: 0 0 0 0 #28a74500; } }
        [data-theme="war"] .status-dot.online { background: var(--war-mode-primary); animation: war-pulse 1s infinite; }
        @keyframes war-pulse { 0% { box-shadow: 0 0 0 0 #ffc107b3; } 70% { box-shadow: 0 0 0 6px #ffc10700; } 100% { box-shadow: 0 0 0 0 #28a74500; } }
        .btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, var(--bg-tertiary), var(--bg-secondary));
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 6px;
            cursor: pointer;
            font-family: var(--secondary-font);
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            border-color: var(--primary);
        }

        .btn-success {
            background: linear-gradient(135deg, #00aa44, #00ff88);
            border-color: var(--success);
            color: #000;
            box-shadow: var(--glow-success);
        }

        .btn-danger {
            background: linear-gradient(135deg, #cc0033, #ff3366);
            border-color: var(--danger);
            box-shadow: var(--glow-danger);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #cc8800, #ffaa00);
            border-color: var(--warning);
            color: #000;
            box-shadow: var(--glow-warning);
        }

        .btn-tiny {
            padding: 2px 6px;
            font-size: 10px;
            line-height: 1;
            min-width: 0;
            white-space: nowrap;
            letter-spacing: 0.5px;
        }
        
        .main-grid { display: grid; grid-template-columns: 1fr; gap: 5px; flex-grow: 1; margin: 5px; overflow: hidden; height: calc(100% - var(--header-min-height) - 10px - var(--ticker-height) - var(--signal-bar-height)); }
        body.header-collapsed .main-grid { height: calc(100vh - var(--ticker-height) - var(--signal-bar-height) - 10px); margin-top: 0; } 
        
        .panel {
            background: var(--bg-secondary);
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .panel-title {
            padding: 12px 16px;
            background: linear-gradient(135deg, var(--bg-tertiary), var(--bg-secondary));
            border-bottom: 1px solid var(--border-color);
            font-family: var(--primary-font);
            font-size: 12px;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-content { padding: 10px; overflow-y: auto; flex-grow: 1; }
        .settings-group { margin-bottom: 15px; } .form-group { margin-bottom: 8px; } .form-label { display: block; font-size: 11px; color: var(--text-secondary); margin-bottom: 4px; }
        .checkbox-label { display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 12px; padding: 4px 0;}
        
        .price-display { display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px; width: 100%; border: 1px solid var(--border-color); border-radius: 4px; padding: 8px; font-size: 10px; margin-top: 8px; } 
        .price-item .price-label { color: var(--text-secondary); } 
        .price-item .price-value { font-size: 18px; font-weight: 700; }
        .price-item.countdown { grid-column: 1 / span 2; display: flex; justify-content: center; align-items: center; font-size: 14px; font-weight: 700; color: var(--primary); padding-top: 5px;}
        
        .center-panel { display: grid; grid-template-rows: 1fr; gap: 5px; padding: 0 !important; } 
        .data-container { display: grid; grid-template-rows: 1fr auto; overflow: hidden; height: 100%; } 
        .data-grid { position: relative; overflow: hidden; min-height: 0; } 

        #live-chart { width: 100%; height: 100%; } 
        .heatmap-container { display: grid; grid-template-rows: auto 1fr; border-top: 1px solid var(--border-color); }
        #orderbook-heatmap { width: 100%; height: 100%; display: block; }

        .chart-zoom-controls { position: absolute; top: 10px; right: 10px; display: flex; gap: 5px; z-index: 100; }
        .chart-zoom-controls .btn-tiny { background: rgba(1, 4, 9, 0.7); backdrop-filter: blur(2px); }

        #exit-fullscreen-btn {
            position: absolute; top: 10px; right: 10px; z-index: 101; 
            background: rgba(1, 4, 9, 0.7); color: white; border-radius: 4px; 
            padding: 2px 6px; font-size: 16px; cursor: pointer; border: 1px solid var(--border-color);
            line-height: 1;
        }
        #chart-countdown-overlay {
            position: absolute; top: 10px; left: 10px; z-index: 100; 
            background: rgba(1, 4, 9, 0.7); padding: 4px 8px; border-radius: 4px; 
            color: var(--primary); font-size: 14px; font-weight: bold;
        }

        .data-table-container { width: 100%; height: 100%; overflow: auto; }
        .data-table { width: 100%; border-collapse: collapse; font-size: 11px; }
        .data-table th, .data-table td { padding: 6px 8px; text-align: left; border-bottom: 1px solid var(--border-color); white-space: nowrap;}
        .data-table th { font-weight: 700; position: sticky; top: 0; background: var(--panel-bg); z-index: 10;}
        .data-table tr:hover { background: var(--hover-bg); }
        .signal-buy { background-color: #28a74514; } .signal-sell { background-color: #dc354514; }
        .signal-tp { background-color: #28a74533; } .signal-sl { background-color: #dc354533; }
        .signal-pending { background-color: #ffc1071a; } /* Neutral/warning color with transparency */

        .stat-item { display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid var(--border-color); font-size: 12px; }
        .stat-item:last-child { border-bottom: none; } .stat-label { color: var(--text-secondary); } .stat-value { font-weight: 700; }
        .btn-sm { padding: 1px 4px; font-size: 9px; margin-left: 4px; border-radius: 3px; cursor: pointer;}
        ::-webkit-scrollbar { width: 6px; height: 6px; } ::-webkit-scrollbar-track { background: transparent; } ::-webkit-scrollbar-thumb { background: var(--text-secondary); border-radius: 3px; }
        /* Bildirimlerin yeni stili ve konumu - sol dikey panel içinde */
        .notifications { 
            position: fixed; 
            bottom: 15px; 
            left: 75px; /* Sol tarafta dikey ikonların yanında */
            z-index: 2000; 
            width: 280px; /* Daha dar */
            max-height: 80vh;
            overflow-y: auto;
            pointer-events: none; /* Sadece bildirimler tıklamalara geçirgen olsun */
        }
        .notification { 
            background: rgba(22, 27, 34, 0.9); /* Hafif transparan */
            backdrop-filter: blur(4px);
            border: 1px solid var(--border-color); 
            border-right-width: 4px; /* Sağ kenarda renkli bordür */
            border-radius: 4px; 
            padding: 8px 12px; /* Daha küçük padding */
            font-size: 12px; /* Daha küçük font */
            box-shadow: 0 2px 8px rgba(0,0,0,0.3); 
            margin-top: 8px; 
            animation: slide-in-left 0.3s ease-out;
            pointer-events: auto; /* Bildirimler tıklanabilir olsun */
        }
        @keyframes slide-in-left {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slide-in-right {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slide-in {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .notification.success { border-right-color: var(--positive); } 
        .notification.danger { border-right-color: var(--negative); } 
        .notification.warning { border-right-color: var(--neutral); }
        
        /* Bildirim Menüsü Stilleri */
        .notification-menu {
            min-width: 200px;
        }
        
        .notification-menu .notification-header {
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
            margin-bottom: 8px;
        }
        
        aside#settings-panel, aside#analytics-panel { display: none !important; }
        .hidden-view { display: none !important; } 

        /* YENİ LOG PANELİ STİLLERİ */
        #log-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: none; justify-content: center; align-items: center; z-index: 2550; }
        #log-modal-overlay.visible { display: flex; }
        .log-modal-content { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 8px; width: 95%; max-width: 1000px; height: 90%; display: flex; flex-direction: column; box-shadow: 0 8px 30px rgba(0,0,0,0.4); }
        .log-modal-header { padding: 10px 15px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; font-weight: 700; font-size: 14px; color: var(--primary); }
        .log-modal-header .close-btn { background: none; border: none; font-size: 20px; color: var(--text-secondary); cursor: pointer; padding: 0 5px; line-height: 1; }
        .log-modal-body { padding: 0; overflow-y: auto; flex-grow: 1; }
        #log-output { font-family: 'Roboto Mono', monospace; font-size: 11px; color: var(--text-secondary); padding: 10px; margin: 0; white-space: pre-wrap; word-break: break-all; }
        #log-output .log-error { color: var(--negative); }
        #log-output .log-warn { color: var(--neutral); }
        #log-output .log-info { color: var(--positive); }

        
        aside#settings-panel, aside#analytics-panel { display: none !important; }
        .hidden-view { display: none !important; } 

        #settings-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 2500; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; }
        #settings-modal-overlay.visible { opacity: 1; visibility: visible; }
        .settings-modal-content { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 8px; width: 90%; max-width: 900px; max-height: 90%; display: flex; flex-direction: column; box-shadow: 0 8px 30px rgba(0,0,0,0.4); transform: translateY(20px); transition: transform 0.3s ease; }
        #settings-modal-overlay.visible .settings-modal-content { transform: translateY(0); }
        .settings-modal-header { padding: 12px 15px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; font-weight: 700; font-size: 15px; color: var(--primary); }
        .settings-modal-header .close-btn { background: none; border: none; font-size: 20px; color: var(--text-secondary); cursor: pointer; padding: 0 5px; line-height: 1; }
        .settings-modal-header .close-btn:hover { color: var(--negative); }
        .settings-modal-body { padding: 15px; overflow-y: auto; flex-grow: 1; display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .settings-modal-footer { padding: 12px 15px; border-top: 1px solid var(--border-color); display: flex; justify-content: flex-end; gap: 10px; }

        /* Yeni Sinyal Barı */
        #signal-progress-bar-container {
            display: flex; gap: 5px; width: 100%; padding: 5px 10px; background: var(--panel-bg); 
            border-bottom: 1px solid var(--border-color); justify-content: space-around; align-items: center;
            position: fixed; top: var(--ticker-height); left: 0; z-index: 1099;
            height: var(--signal-bar-height);
        }
        .signal-bar-wrapper { flex: 1; text-align: center; }
        .signal-bar-label { font-size: 10px; color: var(--text-secondary); margin-bottom: 3px; }
        .signal-bar { width: 100%; height: 10px; background: var(--input-bg); border: 1px solid var(--border-color); border-radius: 5px; overflow: hidden; position: relative; }
        .signal-bar-fill { height: 100%; width: 0%; transition: width 0.2s ease-out; position: absolute; left: 0; top: 0; background: linear-gradient(90deg, transparent, var(--positive)); }
        .signal-bar-fill.buy { background: linear-gradient(90deg, transparent, var(--positive)); }
        .signal-bar-fill.sell { background: linear-gradient(90deg, transparent, var(--negative)); }
        .signal-score-text { font-size: 9px; margin-top: 2px; color: var(--primary); }

        /* Resizable Handle */
        .resize-handle { position: absolute; bottom: 0; left: 0; width: 100%; height: 8px; cursor: ns-resize; background: var(--border-color); z-index: 10; border-top: 1px solid var(--border-color); }
        .center-panel.resizing { user-select: none; }

        /* Dikey İkon Paneli Stilleri - Sol tarafta konumlandırıldı */
        .vertical-icon-panel {
            position: fixed;
            top: 50%;
            left: 0; /* Sağ yerine sol tarafa konumlandırma */
            transform: translateY(-50%);
            z-index: 2000;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-left: none; /* Sol kenara yapışık olduğu için sol kenar yok */
            border-radius: 0 10px 10px 0; /* Sağ köşeler yuvarlatıldı */
            padding: 10px 5px;
            z-index: 1001;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.2); /* Gölge sağ tarafa */
            display: flex;
            flex-direction: column;
            gap: 10px;
            opacity: 0.85;
            transition: opacity 0.3s ease;
        }
        
        .vertical-icon-panel:hover {
            opacity: 1;
        }
        
        .vertical-icon-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: var(--input-bg);
            border: 1px solid var(--border-color);
            color: var(--text-main);
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .vertical-icon-btn:hover {
            background: var(--hover-bg);
            transform: translateX(-3px);
        }
        
        .vertical-icon-btn.active {
            background: var(--primary);
            color: #000;
        }
        
        /* Panteon UI Stilleri - Sade ve Zarif */
        /* Panteon UI Stilleri - Sade ve Zarif - Sabit Boyutlu */
        .pantheon-ui {
            position: fixed;
            top: 20px;
            left: 20px; /* Sol üste taşındı */
            background: rgba(13, 17, 23, 0.9);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 10px;
            width: 200px; /* Daha küçük */
            height: auto;
            max-height: 250px; /* Daha küçük */
            z-index: 1200; /* Düşük z-index */
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(8px);
            opacity: 0.95;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        /* Mobil cihazlar için Pantheon UI stilleri - Sabit Boyutlu */
        @media screen and (max-width: 768px) {
            .vertical-icon-panel {
                top: auto;
                bottom: 70px;
                right: 0;
                transform: none;
                border-radius: 10px 0 0 10px;
                padding: 10px 5px;
            }
            
            .pantheon-ui {
                opacity: 0;
                visibility: hidden;
                transform: translateY(20px);
                width: 180px;
                height: auto;
                max-height: 200px;
                left: 10px; /* Sol üstte mobilde */
                top: 10px;
                transition: opacity 0.3s ease, transform 0.3s ease, visibility 0.3s;
            }
            
            .pantheon-content {
                max-height: 350px;
            }
            
            .pantheon-ui.mobile-visible {
                opacity: 1;
                visibility: visible;
                transform: translateY(0);
            }
            
            .god {
                height: 55px;
            }
            
            .ability {
                height: 45px;
            }
        }
        
        .pantheon-ui:hover {
            opacity: 1;
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .pantheon-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .pantheon-title {
            font-weight: 700;
            color: var(--primary);
            font-size: 12px;
            letter-spacing: 1px;
            text-transform: uppercase;
            background: linear-gradient(90deg, var(--primary), #9ca3af);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .pantheon-controls {
            display: flex;
            gap: 8px;
        }
        
        .pantheon-toggle-btn,
        .pantheon-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 14px;
            cursor: pointer;
            line-height: 1;
            padding: 0;
            width: 22px;
            height: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }
        
        .pantheon-toggle-btn:hover,
        .pantheon-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-main);
        }
        
        .pantheon-close:hover {
            color: var(--negative);
        }
        
        .pantheon-content {
            display: flex;
            flex-direction: column;
            gap: 12px;
            height: auto;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
        }
        
        /* Custom scrollbar for webkit browsers */
        .pantheon-content::-webkit-scrollbar {
            width: 5px;
        }
        
        .pantheon-content::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .pantheon-content::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        
        .pantheon-content::-webkit-scrollbar-thumb:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }
        
        .pantheon-gods {
            display: flex;
            flex-direction: column;
            gap: 6px;
            width: 100%;
        }
        
        .god {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 8px;
            height: 60px;
            border-radius: 6px;
            background: rgba(22, 27, 34, 0.6);
            transition: all 0.2s ease;
            border: 1px solid rgba(255, 255, 255, 0.03);
            box-sizing: border-box;
        }
        
        .god:hover {
            background: rgba(33, 38, 45, 0.8);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
        }
        
        .god-info {
            display: flex;
            align-items: center;
            gap: 10px;
            height: 32px;
            width: 100%;
        }
        
        .god-icon {
            font-size: 18px;
            min-width: 30px;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .god-details {
            flex: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .god-name {
            font-weight: 500;
            font-size: 13px;
            color: var(--text-main);
        }
        
        .god-power {
            font-size: 12px;
            font-weight: 600;
            color: var(--primary);
        }
        
        .god-progress {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .god-progress-fill {
            height: 100%;
            width: 0%;
            border-radius: 2px;
            transition: width 0.3s ease, opacity 0.3s ease;
        }
        
        /* Enhanced god-specific gradients */
        .metatron .god-progress-fill { background: linear-gradient(90deg, var(--metatron-color), #7e6be8); }
        .uriel .god-progress-fill { background: linear-gradient(90deg, var(--uriel-color), #e06c75); }
        .raphael .god-progress-fill { background: linear-gradient(90deg, var(--raphael-color), #98c379); }
        .gabriel .god-progress-fill { background: linear-gradient(90deg, var(--gabriel-color), #61afef); }
        .michael .god-progress-fill { background: linear-gradient(90deg, var(--michael-color), #d19a66); }
        
        .pantheon-abilities {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-top: 4px;
            width: 100%;
        }
        
        .ability {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            height: 50px;
            border-radius: 6px;
            background: rgba(22, 27, 34, 0.6);
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.03);
            cursor: pointer;
            transition: all 0.2s ease;
            box-sizing: border-box;
        }
        
        .ability:hover {
            background: rgba(33, 38, 45, 0.8);
            transform: translateY(-1px);
        }
        
        .ability-icon {
            font-size: 16px;
            margin-right: 12px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 50%;
        }
        
        .ability-details {
            flex: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 100%;
            width: calc(100% - 40px);
        }
        
        .ability-name {
            font-weight: 500;
            font-size: 13px;
            color: var(--text-main);
        }
        
        .ability-status {
            font-size: 11px;
            font-weight: 500;
            color: #98c379;
        }
        
        .ability.on-cooldown .ability-status {
            color: #e06c75;
        }
        
        .ability-cooldown {
            position: absolute;
            left: 0;
            bottom: 0;
            height: 2px;
            width: 100%;
            background: linear-gradient(90deg, var(--primary), #56b6c2);
            transform-origin: left;
            transform: scaleX(1);
        }
        
        .ability.on-cooldown::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            pointer-events: none;
        }
        
        .god-icon {
            font-size: 13px;
            margin-bottom: 2px;
            text-align: center;
        }
        
        .god-name {
            font-weight: 600;
            font-size: 9px;
            text-align: center;
            margin-bottom: 2px;
        }
        
        .god-power {
            font-size: 8px;
            text-align: center;
            margin-bottom: 2px;
            font-family: 'Roboto Mono', monospace;
        }
        
        .god-progress {
            width: 100%;
            height: 4px; /* Çok daha ince çubuk */
            background: var(--border-color);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .god-progress-fill {
            height: 100%;
            width: 0%;
            transition: width 0.3s ease, background-color 0.3s ease;
        }
        
        /* Her tanrı için özel renkler */
        .metatron .god-progress-fill { background: var(--metatron-color); }
        .uriel .god-progress-fill { background: var(--uriel-color); }
        .raphael .god-progress-fill { background: var(--raphael-color); }
        .gabriel .god-progress-fill { background: var(--gabriel-color); }
        .michael .god-progress-fill { background: var(--michael-color); }
        
        .pantheon-abilities {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* 3 sütunlu grid */
            gap: 4px;
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid var(--border-color);
        }
        
        .ability {
            background: var(--input-bg);
            border-radius: 5px;
            padding: 4px 2px; /* Minimum padding */
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
        .ability:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .ability-icon {
            font-size: 13px;
            margin-bottom: 1px;
        }
        
        .ability-name {
            font-size: 8px; /* Daha da küçük font */
            font-weight: 600;
        }
        
        .ability-cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: var(--primary);
            width: 100%;
            transform-origin: left;
            transform: scaleX(0);
            transition: transform 0.1s linear;
        }
        
        /* Animasyonlar */
        @keyframes pulse {
            0% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.6; transform: scale(1); }
        }
        
        .ability.active {
            animation: pulse 1.5s infinite;
        }

                        /* DÜZELTME: Metinlerin yanlışlıkla seçilmesini engelle */
        .btn, .panel-title, .header-top-bar, .signal-bar-label, .form-label {
            user-select: none; /* Standart */
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* Internet Explorer/Edge */
        }

                                /* Ritüel Sistemi Stilleri */
        .ritual-container {
            position: fixed;
            bottom: 75px;
            right: 75px;
            width: 320px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.7);
            color: var(--text-primary);
            z-index: 100;
            font-family: var(--primary-font);
            transform: translateY(0);
            transition: transform 0.5s ease-in-out, opacity 0.5s ease-in-out;
        }
        
        .ritual-container.hidden {
            transform: translateY(150%);
            opacity: 0;
        }
        
        .ritual-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: linear-gradient(90deg, var(--bg-tertiary), var(--panel-bg));
            border-bottom: 1px solid var(--border-color);
            border-radius: 8px 8px 0 0;
        }
        
        .ritual-title {
            font-weight: bold;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .ritual-icon {
            display: inline-block;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, var(--warning), var(--danger));
            border-radius: 50%;
            position: relative;
            overflow: hidden;
        }
        
        .ritual-icon::after {
            content: "✧";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .ritual-close {
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
            font-size: 16px;
        }
        
        .ritual-close:hover {
            opacity: 1;
            color: var(--danger);
        }
        
        .ritual-description {
            padding: 12px 15px;
            font-size: 12px;
            line-height: 1.4;
            color: var(--text-secondary);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .ritual-list {
            max-height: 280px;
            overflow-y: auto;
            padding: 5px;
        }
        
        .ritual-list::-webkit-scrollbar {
            width: 5px;
        }
        
        .ritual-list::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
        }
        
        .ritual-list::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 5px;
        }
        
        .ritual-item {
            padding: 10px;
            margin: 5px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .ritual-item:hover {
            background: rgba(255, 255, 255, 0.07);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .ritual-item.active {
            background: linear-gradient(135deg, rgba(255, 170, 0, 0.1), rgba(255, 51, 102, 0.1));
            border-color: rgba(255, 170, 0, 0.3);
        }
        
        .ritual-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .ritual-item-title {
            font-weight: 600;
            font-size: 12px;
            color: var(--text-primary);
        }
        
        .ritual-item-duration {
            font-size: 10px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 3px;
        }
        
        .ritual-item-description {
            font-size: 11px;
            color: var(--text-secondary);
            margin: 5px 0;
        }
        
        .ritual-item-effect {
            font-size: 10px;
            color: var(--success);
            margin-top: 5px;
        }
        
        .ritual-item-cost {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 10px;
            color: var(--warning);
        }
        
        .ritual-item-progress {
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin-top: 8px;
            overflow: hidden;
        }
        
        .ritual-item-progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--warning), var(--success));
            transition: width 0.5s ease;
        }
        
        .ritual-actions {
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .ritual-btn {
            background: linear-gradient(135deg, var(--bg-tertiary), var(--border-color));
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 12px;
            font-size: 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            margin: 0 5px;
            text-align: center;
        }
        
        .ritual-btn:hover {
            background: linear-gradient(135deg, var(--border-color), var(--bg-tertiary));
            border-color: var(--text-secondary);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
        }
        
        .ritual-btn:active {
            transform: scale(0.98);
        }
        
        .ritual-btn.primary {
            background: linear-gradient(135deg, var(--warning), var(--danger));
            border-color: var(--warning);
        }
        
        .ritual-btn.primary:hover {
            background: linear-gradient(135deg, var(--danger), var(--warning));
        }
        
        .ritual-status {
            padding: 10px 15px;
            font-size: 11px;
            text-align: center;
            color: var(--text-secondary);
            background: rgba(0, 0, 0, 0.2);
            border-radius: 0 0 8px 8px;
        }
        
        .ritual-active-label {
            position: absolute;
            top: -10px;
            right: -10px;
            background: var(--success);
            color: black;
            font-size: 8px;
            padding: 2px 5px;
            border-radius: 3px;
            transform: rotate(10deg);
            z-index: 1;
        }
        
        /* Ritüel animasyonları */
        @keyframes ritualActivate {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.5; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        @keyframes ritualPulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 170, 0, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(255, 170, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 170, 0, 0); }
        }
        
        .ritual-active {
            animation: ritualPulse 2s infinite;
        }
        
        .ritual-activate-effect {
            animation: ritualActivate 0.5s ease-in-out;
        }
        
        /* Ritüel efektleri - Grafik stillerine eklemeler */
        .ritual-effect-trend #live-chart {
            box-shadow: 0 0 15px rgba(0, 170, 255, 0.5);
        }
        
        .ritual-effect-confluence #live-chart {
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }
        
        .ritual-effect-liquidity #live-chart {
            box-shadow: 0 0 15px rgba(255, 170, 0, 0.5);
        }
        
        .ritual-effect-orderflow #live-chart {
            box-shadow: 0 0 15px rgba(255, 51, 102, 0.5);
        }
        
        .ritual-effect-protection #live-chart {
            box-shadow: 0 0 15px rgba(132, 0, 255, 0.5);
        }
        
        @media screen and (max-width: 768px) {
            .desktop-only { display: none !important; }
            .mobile-only { display: flex !important; align-items: center; }

            .container { 
                padding-top: calc(var(--ticker-height) + var(--signal-bar-height)); 
                padding-bottom: var(--header-min-height); 
            }
            #signal-progress-bar-container { top: var(--ticker-height); }
            
            .header { 
                order: 2; 
                position: fixed;
                bottom: 0; 
                left: 0;
                right: 0;
                width: 100%; 
                z-index: 1000; 
                margin: 0; 
                border-radius: 0; 
                border: none; 
                border-top: 1px solid var(--border-color); 
            }
            /* DÜZELTME: Butonlar ve başlık için yeni ve daha basit düzen */
            .header-top-bar { 
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 0 10px; 
                min-height: var(--header-min-height);
            }
            .header-center-title {
                cursor: pointer;
                flex-grow: 1;
                text-align: center;
            }
            .header-left-controls, .header-right-controls {
                display: flex;
                gap: 8px;
            }
            #mobile-toggle-controls-btn, .header-right-controls .btn {
                font-size: 16px;
                padding: 5px 10px;
            }
            /* Mobilde masaüstü başlığını gizle */
            .header-center-title .header-title-text {
                display: none;
            }

            .header-collapsible-content { padding: 0; }
            .header-collapsible-content .main-controls { flex-direction: column; align-items: center; padding: 0; width: 100%; }
            .form-control, .btn, .status { width: 100%; text-align: center; padding: 8px 10px; font-size: 11px; }
            .status { justify-content: center; }
            .price-display { grid-template-columns: repeat(2, 1fr); margin-top: 10px; }
            .price-item .price-value { font-size: 14px; } 
            
            .main-grid { 
                order: 1; 
                margin: 0;
                height: 100%;
                display: flex;
                flex-direction: column;
            }
            .center-panel { 
                order: 1; 
                flex-grow: 1;
                height: 100%;
                border: none;
                border-radius: 0; 
                background: transparent;
                box-shadow: none; 
                margin: 0; 
            }
            .center-panel > .panel-title { display: none; }
            .data-container { 
                flex-direction: column; 
                height: 100%; 
                padding: 5px;
            }
            .data-grid { 
                height: 100%;
                flex-grow: 1;
            }
            #live-chart { height: 100%; width: 100%; } 
            .heatmap-container { height: 150px; flex-shrink: 0; margin-top: 10px; border-top: 1px solid var(--border-color); padding-top: 10px; }
            .heatmap-container .panel-title { border-bottom: none; margin-bottom: 5px; }
            .settings-modal-content { width: 95%; margin: 10px; }
            .settings-modal-body { grid-template-columns: 1fr; gap: 15px; }
            .super-top-right-buttons { display: none; }
            .resize-handle { display: none; }
            #chart-countdown-overlay { font-size: 12px; padding: 3px 6px; }

            body.fullscreen-chart .main-grid { height: 100vh; }
            body.fullscreen-chart .center-panel { height: 100vh; }
        }




    </style>
</head>
<body class="header-collapsed" data-theme="dark">
    <!-- Panteon Paneli -->
    <aside id="panteon-panel" aria-label="Panteon Paneli">
        <div class="pp-title">
            <span>⚡ Panteon</span>
            <span id="pp-env">v3.5</span>
            <button class="pp-expand-btn" id="pp-expand-btn" title="Panel Genişlet/Daralt">⚙️</button>
        </div>
        <div class="pp-body">
            <div class="panteon-stats">
                <div class="regime-indicator">
                    <span>Rejim:</span>
                    <span class="current-regime">NORMAL</span>
                </div>
                <div class="state-indicator">
                    <span>Kolektif:</span>
                    <span class="collective-state">Dengeli</span>
                </div>
            </div>
            
            <div class="panteon-panel">
                <!-- Metatron - Bilgelik Elçisi -->
                <div class="ambassador" data-name="metatron" data-mode="İNANÇLI" data-role="wisdom">
                    <div class="ambassador-header">
                        <div class="ambassador-name">Metatron</div>
                        <div class="ambassador-toggle" title="Aktif/Pasif">✓</div>
                    </div>
                    <div class="ambassador-info">
                        <div class="ambassador-role">Bilgelik, Analiz</div>
                        <div class="ambassador-status">
                            <span class="ambassador-mode">İNANÇLI</span>
                            <span class="reputation">İtibar: <span class="reputation-score">0.0</span></span>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="confidence">
                            <span>Güven</span>
                            <div class="confidence-bar">
                                <div class="confidence-level" style="width:75%">75%</div>
                            </div>
                        </div>
                        <div class="power">
                            <span>Güç</span>
                            <div class="power-bar">
                                <div class="power-level" style="width:0%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="strategy-select">
                        <button data-strategy="SupportResistanceStrategy">Destek/Direnç</button>
                        <button data-strategy="MeanReversionStrategy">Ort. Geri Dönüş</button>
                        <button data-strategy="OrderBookImbalanceStrategy">Emir Defteri</button>
                    </div>
                </div>
                
                <!-- Uriel - Cesaret Elçisi -->
                <div class="ambassador" data-name="uriel" data-mode="İNANÇLI" data-role="courage">
                    <div class="ambassador-header">
                        <div class="ambassador-name">Uriel</div>
                        <div class="ambassador-toggle" title="Aktif/Pasif">✓</div>
                    </div>
                    <div class="ambassador-info">
                        <div class="ambassador-role">Cesaret, Hız</div>
                        <div class="ambassador-status">
                            <span class="ambassador-mode">İNANÇLI</span>
                            <span class="reputation">İtibar: <span class="reputation-score">0.0</span></span>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="confidence">
                            <span>Güven</span>
                            <div class="confidence-bar">
                                <div class="confidence-level" style="width:75%">75%</div>
                            </div>
                        </div>
                        <div class="power">
                            <span>Güç</span>
                            <div class="power-bar">
                                <div class="power-level" style="width:0%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="strategy-select">
                        <button data-strategy="BreakoutPatternStrategy">Kırılma</button>
                        <button data-strategy="MomentumStrategy">Momentum</button>
                        <button data-strategy="TrendFollowingStrategy">Trend Takip</button>
                    </div>
                </div>
                
                <!-- Raphael - Şifa Elçisi -->
                <div class="ambassador" data-name="raphael" data-mode="İNANÇLI" data-role="healing">
                    <div class="ambassador-header">
                        <div class="ambassador-name">Raphael</div>
                        <div class="ambassador-toggle" title="Aktif/Pasif">✓</div>
                    </div>
                    <div class="ambassador-info">
                        <div class="ambassador-role">Şifa, Denge</div>
                        <div class="ambassador-status">
                            <span class="ambassador-mode">İNANÇLI</span>
                            <span class="reputation">İtibar: <span class="reputation-score">0.0</span></span>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="confidence">
                            <span>Güven</span>
                            <div class="confidence-bar">
                                <div class="confidence-level" style="width:75%">75%</div>
                            </div>
                        </div>
                        <div class="power">
                            <span>Güç</span>
                            <div class="power-bar">
                                <div class="power-level" style="width:0%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="strategy-select">
                        <button data-strategy="StatArbitrageStrategy">İstatistik Arb.</button>
                        <button data-strategy="LiquidityGapStrategy">Likidite Boşl.</button>
                        <button data-strategy="OverboughtOversoldStrategy">Aşırı Al/Sat</button>
                    </div>
                </div>
                
                <!-- Gabriel - İletişim Elçisi -->
                <div class="ambassador" data-name="gabriel" data-mode="İNANÇLI" data-role="communication">
                    <div class="ambassador-header">
                        <div class="ambassador-name">Gabriel</div>
                        <div class="ambassador-toggle" title="Aktif/Pasif">✓</div>
                    </div>
                    <div class="ambassador-info">
                        <div class="ambassador-role">İletişim, Bilgi</div>
                        <div class="ambassador-status">
                            <span class="ambassador-mode">İNANÇLI</span>
                            <span class="reputation">İtibar: <span class="reputation-score">0.0</span></span>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="confidence">
                            <span>Güven</span>
                            <div class="confidence-bar">
                                <div class="confidence-level" style="width:75%">75%</div>
                            </div>
                        </div>
                        <div class="power">
                            <span>Güç</span>
                            <div class="power-bar">
                                <div class="power-level" style="width:0%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="strategy-select">
                        <button data-strategy="SmartMoneyStrategy">Akıllı Para</button>
                        <button data-strategy="VolumeProfileStrategy">Hacim Profili</button>
                        <button data-strategy="SentimentAnalysisStrategy">Duygu Analizi</button>
                    </div>
                </div>
                
                <!-- Michael - Savaş Elçisi -->
                <div class="ambassador" data-name="michael" data-mode="İNANÇLI" data-role="warfare">
                    <div class="ambassador-header">
                        <div class="ambassador-name">Michael</div>
                        <div class="ambassador-toggle" title="Aktif/Pasif">✓</div>
                    </div>
                    <div class="ambassador-info">
                        <div class="ambassador-role">Savaş, Güç</div>
                        <div class="ambassador-status">
                            <span class="ambassador-mode">İNANÇLI</span>
                            <span class="reputation">İtibar: <span class="reputation-score">0.0</span></span>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="confidence">
                            <span>Güven</span>
                            <div class="confidence-bar">
                                <div class="confidence-level" style="width:75%">75%</div>
                            </div>
                        </div>
                        <div class="power">
                            <span>Güç</span>
                            <div class="power-bar">
                                <div class="power-level" style="width:0%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="strategy-select">
                        <button data-strategy="AggressiveCandleStrategy">Agresif Mum</button>
                        <button data-strategy="LiquidationCascadeStrategy">Likid. Kaskad</button>
                        <button data-strategy="VolatilityBreakoutStrategy">Volatilite</button>
                    </div>
                </div>
                
                <!-- Yetenek Düğmeleri -->
                <div class="pantheon-abilities">
                    <div class="pantheon-ability ready" data-ability="council">
                        <div class="ability-icon">👑</div>
                        <div class="ability-name">Konsey</div>
                        <div class="cooldown-indicator">Hazır</div>
                    </div>
                    <div class="pantheon-ability ready" data-ability="reset">
                        <div class="ability-icon">🔄</div>
                        <div class="ability-name">Sıfırla</div>
                        <div class="cooldown-indicator">Hazır</div>
                    </div>
                </div>
            </div>
                    <div class="pp-power-bar"><div class="pp-power-fill" style="width:0%"></div></div>
                </div>
            </div>
            <div class="pp-amb" id="amb-uriel" data-role="courage">
                <span class="pp-name">Uriel</span>
                <span class="pp-rep" data-rep="0">0</span>
                <span class="pp-mode" data-mode="İNANÇLI">İNANÇLI</span>
                <div class="pp-details">
                    <div class="pp-strategies">Momentum, Kırılım (Breakout)</div>
                    <div class="pp-power-bar"><div class="pp-power-fill" style="width:0%"></div></div>
                </div>
            </div>
            <div class="pp-amb" id="amb-raphael" data-role="healing">
                <span class="pp-name">Raphael</span>
                <span class="pp-rep" data-rep="0">0</span>
                <span class="pp-mode" data-mode="İNANÇLI">İNANÇLI</span>
                <div class="pp-details">
                    <div class="pp-strategies">İstatistiksel Arbitraj, Likidite</div>
                    <div class="pp-power-bar"><div class="pp-power-fill" style="width:0%"></div></div>
                </div>
            </div>
            <div class="pp-amb" id="amb-gabriel" data-role="communication">
                <span class="pp-name">Gabriel</span>
                <span class="pp-rep" data-rep="0">0</span>
                <span class="pp-mode" data-mode="İNANÇLI">İNANÇLI</span>
                <div class="pp-details">
                    <div class="pp-strategies">Akıllı Para, Hacim Profili, Duygu</div>
                    <div class="pp-power-bar"><div class="pp-power-fill" style="width:0%"></div></div>
                </div>
            </div>
            <div class="pp-amb" id="amb-michael" data-role="warfare">
                <span class="pp-name">Michael</span>
                <span class="pp-rep" data-rep="0">0</span>
                <span class="pp-mode" data-mode="İNANÇLI">İNANÇLI</span>
                <div class="pp-details">
                    <div class="pp-strategies">Agresif Mum, Likidasyon Çağlayanları</div>
                    <div class="pp-power-bar"><div class="pp-power-fill" style="width:0%"></div></div>
                </div>
            </div>
        </div>
        <div class="pp-footer">
            <div class="pp-collective-state">
                <span class="pp-state-label">Kolektif Durum:</span>
                <span class="pp-state-value" id="pp-collective-state">Dengeli</span>
            </div>
            <div class="pp-actions">
                <button class="pp-action-btn" id="pp-action-council" title="Meclis Toplantısı">🏛️</button>
                <button class="pp-action-btn" id="pp-action-reset" title="İtibarları Sıfırla">🔄</button>
            </div>
        </div>
    </aside>
    
    <!-- Kehanet Paneli -->
    <aside id="kehanet-panel" aria-label="Kehanet Paneli">
        <div class="kp-title">
            <span>🜲 Kehanet</span>
            <span id="kp-session">—</span>
            <button class="kp-expand-btn" id="kp-expand-btn" title="Panel Genişlet/Daralt">⚙️</button>
        </div>
        <div class="kp-body">
            <div class="kp-row">
                <span class="kp-key">🛡️ Koruma</span>
                <span class="kp-val" id="kp-guardian">Aktif</span>
            </div>
            <div class="kp-row">
                <span class="kp-key">⚖️ Rejim</span>
                <span class="kp-val" id="kp-regime">—</span>
            </div>
            <div class="kp-row">
                <span class="kp-key">⚔️ Nabız</span>
                <span class="kp-val" id="kp-pulse">—</span>
            </div>
            <div class="kp-row">
                <span class="kp-key">🎯 Eğilim</span>
                <span class="kp-val" id="kp-trend">—</span>
            </div>
            <div class="kp-divider"></div>
            <div class="kp-advanced" id="kp-advanced">
                <div class="kp-row">
                    <span class="kp-key">🧠 Tahmin</span>
                    <span class="kp-val" id="kp-prediction">—</span>
                </div>
                <div class="kp-row">
                    <span class="kp-key">🔮 Olasılık</span>
                    <span class="kp-val" id="kp-probability">—</span>
                </div>
                <div class="kp-row">
                    <span class="kp-key">⏱️ Zaman Hedefi</span>
                    <span class="kp-val" id="kp-timeframe">—</span>
                </div>
                <div class="kp-row">
                    <span class="kp-key">🌊 Likidite</span>
                    <span class="kp-val" id="kp-liquidity">—</span>
                </div>
                <div class="kp-row">
                    <span class="kp-key">💧 Baskı</span>
                    <span class="kp-val" id="kp-pressure">—</span>
                </div>
                <div class="kp-chart-container">
                    <div id="kp-mini-chart" class="kp-mini-chart"></div>
                </div>
            </div>
        </div>
        <div class="kp-footer">
            <div class="kp-confidence-bar">
                <div class="kp-confidence-fill" id="kp-confidence-fill"></div>
                <div class="kp-confidence-label" id="kp-confidence-label">Güven: %75</div>
            </div>
            <button class="kp-refresh-btn" id="kp-refresh-btn" title="Tahminleri Yenile">⟳</button>
        </div>
    </aside>
    
    <!-- Ana Menü Sistemi -->
    <div id="main-menu-container" class="main-menu-container">
        <button id="menu-toggle-btn" class="menu-toggle-btn">
            <span class="menu-icon">☰</span>
        </button>
        
        <div id="main-menu" class="main-menu">
            <div class="menu-header">
                <h3>🏛️ Komuta Merkezi</h3>
                <button id="menu-close-btn" class="menu-close-btn">✖</button>
            </div>
            
            <div class="menu-sections">
                <!-- Panteon Bölümü -->
                <div class="menu-section">
                    <div class="section-header" data-section="panteon">
                        <span class="section-icon">⚡</span>
                        <span class="section-title">Panteon Sistemi</span>
                        <span class="section-toggle">▼</span>
                    </div>
                    <div class="section-content" id="panteon-content">
                        <div class="panteon-stats">
                            <div class="regime-indicator">
                                <span class="pp-state-label">Rejim:</span>
                                <span class="current-regime" id="pp-current-regime">NORMAL</span>
                            </div>
                            <div class="state-indicator">
                                <span class="pp-state-label">Durum:</span>
                                <span class="collective-state" id="pp-collective-state">HAZIR</span>
                            </div>
                        </div>
                        
                        <div class="panteon-panel">
                            <div class="pp-amb" id="amb-metatron" data-role="wisdom">
                                <div class="pp-amb-header">
                                    <span class="pp-amb-name">👁️ Metatron</span>
                                    <button class="pp-expand-btn">⚙️</button>
                                </div>
                                <div class="pp-amb-info">
                                    <span class="pp-role">Bilgelik</span>
                                    <div class="pp-amb-status">
                                        <span class="pp-mode">İNANÇLI</span>
                                        <span class="reputation">Rep: <span class="pp-rep">100</span></span>
                                    </div>
                                </div>
                                <div class="pp-power-container">
                                    <span>Güç:</span>
                                    <div class="pp-power-bar">
                                        <div class="pp-power-fill" style="width: 75%"></div>
                                    </div>
                                    <span class="pp-power-val">75%</span>
                                </div>
                            </div>
                            
                            <div class="pp-amb" id="amb-uriel" data-role="courage">
                                <div class="pp-amb-header">
                                    <span class="pp-amb-name">🔥 Uriel</span>
                                    <button class="pp-expand-btn">⚙️</button>
                                </div>
                                <div class="pp-amb-info">
                                    <span class="pp-role">Cesaret</span>
                                    <div class="pp-amb-status">
                                        <span class="pp-mode">İNANÇLI</span>
                                        <span class="reputation">Rep: <span class="pp-rep">85</span></span>
                                    </div>
                                </div>
                                <div class="pp-power-container">
                                    <span>Güç:</span>
                                    <div class="pp-power-bar">
                                        <div class="pp-power-fill" style="width: 60%"></div>
                                    </div>
                                    <span class="pp-power-val">60%</span>
                                </div>
                            </div>
                            
                            <div class="pp-amb" id="amb-raphael" data-role="healing">
                                <div class="pp-amb-header">
                                    <span class="pp-amb-name">💚 Raphael</span>
                                    <button class="pp-expand-btn">⚙️</button>
                                </div>
                                <div class="pp-amb-info">
                                    <span class="pp-role">Şifa</span>
                                    <div class="pp-amb-status">
                                        <span class="pp-mode">İNANÇLI</span>
                                        <span class="reputation">Rep: <span class="pp-rep">90</span></span>
                                    </div>
                                </div>
                                <div class="pp-power-container">
                                    <span>Güç:</span>
                                    <div class="pp-power-bar">
                                        <div class="pp-power-fill" style="width: 80%"></div>
                                    </div>
                                    <span class="pp-power-val">80%</span>
                                </div>
                            </div>
                            
                            <div class="pp-amb" id="amb-gabriel" data-role="communication">
                                <div class="pp-amb-header">
                                    <span class="pp-amb-name">📢 Gabriel</span>
                                    <button class="pp-expand-btn">⚙️</button>
                                </div>
                                <div class="pp-amb-info">
                                    <span class="pp-role">İletişim</span>
                                    <div class="pp-amb-status">
                                        <span class="pp-mode">ŞÜPHECİ</span>
                                        <span class="reputation">Rep: <span class="pp-rep">70</span></span>
                                    </div>
                                </div>
                                <div class="pp-power-container">
                                    <span>Güç:</span>
                                    <div class="pp-power-bar">
                                        <div class="pp-power-fill" style="width: 45%"></div>
                                    </div>
                                    <span class="pp-power-val">45%</span>
                                </div>
                            </div>
                            
                            <div class="pp-amb" id="amb-michael" data-role="warfare">
                                <div class="pp-amb-header">
                                    <span class="pp-amb-name">⚔️ Michael</span>
                                    <button class="pp-expand-btn">⚙️</button>
                                </div>
                                <div class="pp-amb-info">
                                    <span class="pp-role">Savaş</span>
                                    <div class="pp-amb-status">
                                        <span class="pp-mode">KIYAMET</span>
                                        <span class="reputation">Rep: <span class="pp-rep">95</span></span>
                                    </div>
                                </div>
                                <div class="pp-power-container">
                                    <span>Güç:</span>
                                    <div class="pp-power-bar">
                                        <div class="pp-power-fill" style="width: 90%"></div>
                                    </div>
                                    <span class="pp-power-val">90%</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="pantheon-abilities">
                            <div class="pp-ability" data-ability="revelation">
                                <span class="ability-icon">🔮</span>
                                <span class="ability-name">Vahiy</span>
                                <span class="ability-status">Hazır</span>
                            </div>
                            <div class="pp-ability" data-ability="valor">
                                <span class="ability-icon">⚡</span>
                                <span class="ability-name">Cesaret</span>
                                <span class="ability-status">Hazır</span>
                            </div>
                            <div class="pp-ability" data-ability="restoration">
                                <span class="ability-icon">💚</span>
                                <span class="ability-name">Şifa</span>
                                <span class="ability-status">Bekleme</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Kehanet Bölümü -->
                <div class="menu-section">
                    <div class="section-header" data-section="kehanet">
                        <span class="section-icon">🔮</span>
                        <span class="section-title">Kehanet Sistemi</span>
                        <span class="section-toggle">▼</span>
                    </div>
                    <div class="section-content" id="kehanet-content">
                        <div class="kp-stats">
                            <div class="kp-row">
                                <span class="kp-key">Rejim:</span>
                                <span class="kp-val" id="kp-regime">NORMAL</span>
                            </div>
                            <div class="kp-row">
                                <span class="kp-key">Seans:</span>
                                <span class="kp-val" id="kp-session">AVRUPA</span>
                            </div>
                            <div class="kp-row">
                                <span class="kp-key">Koruyucu:</span>
                                <span class="kp-val" id="kp-guardian">Aktif</span>
                            </div>
                            <div class="kp-row">
                                <span class="kp-key">Nabız:</span>
                                <span class="kp-val" id="kp-pulse">0.15%</span>
                            </div>
                        </div>
                        
                        <div class="kp-divider"></div>
                        
                        <div class="kp-predictions">
                            <div class="kp-row">
                                <span class="kp-key">Eğilim:</span>
                                <span class="kp-val trend-up" id="kp-trend">↗️ Yükseliş</span>
                            </div>
                            <div class="kp-row">
                                <span class="kp-key">Tahmin:</span>
                                <span class="kp-val" id="kp-prediction">YUKARI</span>
                            </div>
                            <div class="kp-row">
                                <span class="kp-key">Olasılık:</span>
                                <span class="kp-val" id="kp-probability">%78</span>
                            </div>
                            <div class="kp-row">
                                <span class="kp-key">Zaman:</span>
                                <span class="kp-val" id="kp-timeframe">25 dk</span>
                            </div>
                        </div>
                        
                        <div class="kp-confidence-container">
                            <span class="kp-key">Güven:</span>
                            <div class="kp-confidence-bar">
                                <div class="kp-confidence-fill" style="width: 75%"></div>
                            </div>
                            <span class="kp-confidence-label">75%</span>
                        </div>
                        
                        <div class="kp-actions">
                            <button class="kp-refresh-btn" id="kp-refresh-btn" title="Tahminleri Yenile">🔄 Yenile</button>
                        </div>
                    </div>
                </div>
                
                <!-- Enerji Yönetimi -->
                <div class="menu-section">
                    <div class="section-header" data-section="energy">
                        <span class="section-icon">⚡</span>
                        <span class="section-title">Enerji Yönetimi</span>
                        <span class="section-toggle">▼</span>
                    </div>
                    <div class="section-content" id="energy-content">
                        <div class="energy-info">
                            <div class="energy-level-display">
                                <span class="energy-percentage" id="energy-percentage">80%</span>
                                <span class="energy-status-text" id="energy-status-text">Normal</span>
                            </div>
                        </div>
                        
                        <div class="energy-meter">
                            <div class="energy-fill" id="energy-fill" style="width: 80%;"></div>
                        </div>
                        
                        <div class="energy-actions">
                            <button class="energy-action-btn" onclick="window.app?.energyManager?.boostEnergy()">⚡ Güçlendir</button>
                            <button class="energy-action-btn" onclick="window.app?.energyManager?.optimizeEnergy()">🔧 Optimize</button>
                            <button class="energy-action-btn" onclick="window.app?.energyManager?.recycleEnergy()">♻️ Geri Dönüştür</button>
                        </div>
                    </div>
                </div>
                
                <!-- Ritüel Sistemi -->
                <div class="menu-section">
                    <div class="section-header" data-section="ritual">
                        <span class="section-icon">✨</span>
                        <span class="section-title">Ritüel Sistemi</span>
                        <span class="section-toggle">▼</span>
                    </div>
                    <div class="section-content" id="ritual-content">
                        <div class="ritual-status">
                            <span>Aktif Ritüel: </span>
                            <span id="active-ritual-name">Yok</span>
                        </div>
                        
                        <div class="ritual-list-mini">
                            <div class="ritual-item-mini" data-ritual="trend">
                                <span class="ritual-icon">📈</span>
                                <span class="ritual-name">Trend Gücü</span>
                                <span class="ritual-status-mini">Hazır</span>
                            </div>
                            <div class="ritual-item-mini" data-ritual="protection">
                                <span class="ritual-icon">🛡️</span>
                                <span class="ritual-name">Koruma</span>
                                <span class="ritual-status-mini">Hazır</span>
                            </div>
                            <div class="ritual-item-mini" data-ritual="insight">
                                <span class="ritual-icon">💡</span>
                                <span class="ritual-name">İçgörü</span>
                                <span class="ritual-status-mini">Bekleme</span>
                            </div>
                        </div>
                        
                        <div class="ritual-actions">
                            <button class="ritual-action-btn" onclick="window.app?.ritualManager?.toggleRitualContainer(true)">⚙️ Detaylar</button>
                        </div>
                    </div>
                </div>
                
                <!-- Ayarlar -->
                <div class="menu-section">
                    <div class="section-header" data-section="settings">
                        <span class="section-icon">⚙️</span>
                        <span class="section-title">Sistem Ayarları</span>
                        <span class="section-toggle">▼</span>
                    </div>
                    <div class="section-content" id="settings-content">
                        <div class="quick-settings">
                            <div class="setting-item">
                                <label class="setting-label">
                                    <input type="checkbox" id="quick-tts-toggle" checked>
                                    <span>🔊 Sesli Bildirimler</span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">
                                    <input type="checkbox" id="quick-auto-optimize" checked>
                                    <span>🤖 Otomatik Optimizasyon</span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">
                                    <input type="checkbox" id="quick-combat-mode">
                                    <span>⚔️ Savaş Modu</span>
                                </label>
                            </div>
                        </div>
                        
                        <div class="settings-actions">
                            <button class="settings-action-btn" onclick="document.getElementById('open-settings-modal-btn').click()">⚙️ Gelişmiş Ayarlar</button>
                            <button class="settings-action-btn" onclick="window.app?.resetAllSettings?.()">🔄 Sıfırla</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Kozmik Efektler Katmanı -->
    <div id="cosmic-effects-layer"></div>
    <!-- Canvas for visual effects -->
    <canvas id="effects-canvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999;"></canvas> 
    
    <!-- Ultra Kompakt Panteon Sistemi UI -->
    <div id="pantheon-ui" class="pantheon-ui">
        <div class="pantheon-header">
            <span class="pantheon-title">PANTHEON</span>
            <div class="pantheon-controls">
                <button class="pantheon-toggle-btn" title="Toggle view">▼</button>
                <button class="pantheon-close" title="Close Pantheon">×</button>
            </div>
        </div>
        
        <div class="pantheon-content">
            <div class="pantheon-gods">
                <div class="god metatron" data-god="metatron">
                    <div class="god-info">
                        <div class="god-icon">👁️</div>
                        <div class="god-details">
                            <div class="god-name">Metatron</div>
                            <div class="god-power">0%</div>
                        </div>
                    </div>
                    <div class="god-progress"><div class="god-progress-fill"></div></div>
                </div>
                
                <div class="god uriel" data-god="uriel">
                    <div class="god-info">
                        <div class="god-icon">⚔️</div>
                        <div class="god-details">
                            <div class="god-name">Uriel</div>
                            <div class="god-power">0%</div>
                        </div>
                    </div>
                    <div class="god-progress"><div class="god-progress-fill"></div></div>
                </div>
                
                <div class="god raphael" data-god="raphael">
                    <div class="god-info">
                        <div class="god-icon">💊</div>
                        <div class="god-details">
                            <div class="god-name">Raphael</div>
                            <div class="god-power">0%</div>
                        </div>
                    </div>
                    <div class="god-progress"><div class="god-progress-fill"></div></div>
                </div>
                
                <div class="god gabriel" data-god="gabriel">
                    <div class="god-info">
                        <div class="god-icon">📢</div>
                        <div class="god-details">
                            <div class="god-name">Gabriel</div>
                            <div class="god-power">0%</div>
                        </div>
                    </div>
                    <div class="god-progress"><div class="god-progress-fill"></div></div>
                </div>
                
                <div class="god michael" data-god="michael">
                    <div class="god-info">
                        <div class="god-icon">⚖️</div>
                        <div class="god-details">
                            <div class="god-name">Michael</div>
                            <div class="god-power">0%</div>
                        </div>
                    </div>
                    <div class="god-progress"><div class="god-progress-fill"></div></div>
                </div>
            </div>
            
            <div class="pantheon-abilities">
                <div class="ability" id="ability-revelation" data-ability="revelation">
                    <div class="ability-icon">🔍</div>
                    <div class="ability-details">
                        <div class="ability-name">Vahiy</div>
                        <div class="ability-status">Ready</div>
                    </div>
                    <div class="ability-cooldown"></div>
                </div>
                <div class="ability" id="ability-valor" data-ability="valor">
                    <div class="ability-icon">🛡️</div>
                    <div class="ability-details">
                        <div class="ability-name">Cesaret</div>
                        <div class="ability-status">Ready</div>
                    </div>
                    <div class="ability-cooldown"></div>
                </div>
                <div class="ability" id="ability-restoration" data-ability="restoration">
                    <div class="ability-icon">💫</div>
                    <div class="ability-details">
                        <div class="ability-name">Şifa</div>
                        <div class="ability-status">Ready</div>
                    </div>
                    <div class="ability-cooldown"></div>
                </div>
            </div>
        </div>
    </div>
    
        <div id="super-top-ticker">
        <div class="super-top-left">
            <span id="ticker-bar-symbol">BTC/USDT</span>
            <span id="ticker-bar-price">$43,250.75</span>
            <span class="price-change positive">+2.45%</span>
        </div>
        
        <!-- YENİ EMOJİ STICKER BAR -->
        <div class="emoji-sticker-bar">
            <div class="sticker-item" data-action="menu" title="Ana Menü">
                <span class="sticker-emoji">🏛️</span>
            </div>
            <div class="sticker-item" data-action="notifications" title="Bildirimler">
                <span class="sticker-emoji">📢</span>
                <span class="notification-badge" id="notification-count">3</span>
            </div>
            <div class="sticker-item" data-action="energy" title="Enerji: 80%">
                <span class="sticker-emoji">⚡</span>
                <div class="mini-energy-bar">
                    <div class="mini-energy-fill" style="width: 80%"></div>
                </div>
            </div>
            <div class="sticker-item" data-action="signals" title="Aktif Sinyaller">
                <span class="sticker-emoji">🎯</span>
                <span class="signal-badge" id="signal-count">2</span>
            </div>
            <div class="sticker-item" data-action="pantheon" title="Panteon Gücü">
                <span class="sticker-emoji">👑</span>
                <div class="mini-power-indicator">
                    <div class="power-dot active"></div>
                    <div class="power-dot active"></div>
                    <div class="power-dot"></div>
                </div>
            </div>
            <div class="sticker-item" data-action="regime" title="Piyasa Rejimi: Normal">
                <span class="sticker-emoji" id="regime-emoji">🌊</span>
            </div>
            <div class="sticker-item" data-action="prophet" title="Kehanet Güveni: 75%">
                <span class="sticker-emoji">🔮</span>
                <div class="mini-confidence-circle">
                    <span class="confidence-text">75</span>
                </div>
            </div>
            <div class="sticker-item" data-action="status" title="Sistem Durumu">
                <span class="sticker-emoji">💚</span>
            </div>
        </div>
        <!-- MASAÜSTÜ BUTONLARI -->
        <div class="super-top-right-buttons desktop-only">
            <button id="main-controls-btn" class="btn btn-tiny">Komuta Merkezi</button>
            <button id="chart-view-btn" class="btn btn-tiny">Grafik</button>
            <button id="heatmap-view-btn" class="btn btn-tiny">Isı Haritası</button>
            <button id="fullscreen-chart-btn" class="btn btn-tiny">Tam Ekran Grafik</button>
            <button id="honor-board-btn" class="btn btn-tiny">Şeref Tablosu</button>
            <button id="banned-board-btn" class="btn btn-tiny">Banlılar</button>
            <button id="open-settings-modal-btn" class="btn btn-tiny">Ayarlar</button>
        </div>
                <!-- YENİ MOBİL BUTONLARI -->
        <div class="super-top-right-buttons mobile-only">
            <button id="mobile-fullscreen-chart-btn" class="btn btn-tiny">Tam Ekran</button>
            <!-- DÜZELTME: Yeni Log butonu eklendi -->
            <button id="mobile-open-log-modal-btn" class="btn btn-tiny">📜 Log</button>
            <button id="mobile-open-settings-modal-btn" class="btn btn-tiny btn-success">Ayarlar</button>
        </div>

    </div>


    <!-- Yeni Sinyal Barı -->
    <div id="signal-progress-bar-container">
        <div class="signal-bar-wrapper">
            <div class="signal-bar-label">BUY SINYAL GÜCÜ</div>
            <div class="signal-bar">
                <div id="buy-signal-bar-fill" class="signal-bar-fill buy"></div>
            </div>
            <div id="buy-signal-score-text" class="signal-score-text">0.0</div>
        </div>
        <div class="signal-bar-wrapper">
            <div class="signal-bar-label">SELL SINYAL GÜCÜ</div>
            <div class="signal-bar">
                <div id="sell-signal-bar-fill" class="signal-bar-fill sell"></div>
            </div>
            <div id="sell-signal-score-text" class="signal-score-text">0.0</div>
        </div>
    </div>

    <div class="container">
                                <header class="header">
            <div id="header-main-bar" class="header-top-bar">
                <div class="header-left-controls">
                    <button id="mobile-toggle-controls-btn" class="btn btn-tiny mobile-only" title="Kontrolleri Aç/Kapat">☰</button>
                </div>
                <div class="header-center-title" title="Paneli aç/kapatmak için çift tıkla">
                    <span class="header-title-text">KOMUTA MERKEZİ KONTROLLERİ</span>
                </div>
                <div class="header-right-controls">
                    <!-- DÜZELTME: Eksik olan Grafik butonu eklendi -->
                    <button id="mobile-chart-view-btn" class="btn btn-tiny mobile-only" title="Grafik">📈</button>
                    <button id="mobile-heatmap-view-btn" class="btn btn-tiny mobile-only" title="Isı Haritası">🔥</button>
                    <button id="mobile-honor-board-btn" class="btn btn-tiny mobile-only" title="Şeref Tablosu">🏆</button>
                    <button id="mobile-banned-board-btn" class="btn btn-tiny mobile-only" title="Banlılar">BAN</button>
                </div>
            </div>
            <div class="header-collapsible-content">
                <div class="main-controls">
                    <input type="text" id="symbol-input" class="form-control" placeholder="Örn: BTC, ETH, SOL">
                    <select id="timeframe-select" class="form-control">
                        <option value="1m">1m</option><option value="5m">5m</option><option value="15m" selected>15m</option><option value="1h">1h</option><option value="4h">4h</option>
                    </select>
                    <div class="status">
                        <div id="connection-status" class="status-dot"></div>
                        <span id="connection-text">BAĞLANTI YOK</span>
                    </div>
                    <button id="theme-toggle-btn" class="btn">Tema</button>
                    <button id="start-btn" class="btn btn-success">SİSTEMİ BAŞLAT</button>
                    <button id="stop-btn" class="btn btn-danger" disabled>DURDUR</button>
                    <button id="clear-markers-btn" class="btn">Grafik Sinyallerini Sil</button> 
                </div>
                <div class="price-display">
                    <div class="price-item"><div class="price-label">FİYAT</div><div class="price-value" id="current-price">-</div></div>
                    <div class="price-item"><div class="price-label">24s DEĞİŞİM</div><div class="price-value" id="price-change-24h">-</div></div>
                    <div class="price-item"><div class="price-label">24s HACİM</div><div class="price-value" id="volume-24h">-</div></div>
                    <div class="price-item"><div class="price-label">VOLATİLİTE (ATR)</div><div class="price-value" id="atr-value">-</div></div>
                    <div class="price-item countdown"><span id="candle-countdown">--:--</span></div>
                </div>
            </div>
        </header>




        <main class="main-grid">
            <section class="center-panel panel">
                <div class="data-container">
                    <div class="data-grid" id="chart-container-view">
                        <div id="live-chart"></div>
                        <div class="chart-zoom-controls"> 
                            <button id="chart-zoom-in" class="btn btn-tiny">+</button>
                            <button id="chart-zoom-out" class="btn btn-tiny">-</button>
                            <button id="chart-zoom-reset" class="btn btn-tiny">Sıfırla</button>
                        </div>
                        <button id="exit-fullscreen-btn" class="btn btn-tiny hidden-view" title="Tam Ekrandan Çık">&times;</button>
                        <div id="chart-countdown-overlay" class="hidden-view">--:--</div>
                    </div>
                    <div class="heatmap-container" id="heatmap-container-view">
                        <div class="panel-title" style="border-top: 1px solid var(--border-color); border-bottom: none;">EMİR DEFTERİ ISI HARİTASI</div>
                        <canvas id="orderbook-heatmap"></canvas>
                    </div>
                </div>
                <div class="resize-handle"></div>
            </section>
        </main>
    </div>
    
    <div id="notifications-container" class="notifications"></div>
    
    <!-- Enerji Kutusu -->
    <div id="energy-box" class="energy-box">
        <div class="energy-box-header">
            <div class="energy-box-title">Sistem Enerjisi</div>
            <div class="energy-box-close" onclick="window.app.energyManager.toggleEnergyBox(false)">✖</div>
        </div>
        <div class="energy-meter">
            <div id="energy-fill" class="energy-fill" style="width: 80%;"></div>
        </div>
        <div class="energy-info">
            <span id="energy-level">80%</span>
            <span id="energy-time">12:05:21</span>
        </div>
        <div class="energy-status" id="energy-status">Normal işleyiş sürüyor</div>
        <div class="energy-actions">
            <div class="energy-action-btn" onclick="window.app.energyManager.boostEnergy()">Güçlendir</div>
            <div class="energy-action-btn" onclick="window.app.energyManager.optimizeEnergy()">Optimize Et</div>
            <div class="energy-action-btn" onclick="window.app.energyManager.recycleEnergy()">Geri Dönüştür</div>
        </div>
    </div>
    
    <!-- Ritüel Sistemi -->
    <div id="ritual-container" class="ritual-container hidden">
        <div class="ritual-header">
            <div class="ritual-title">
                <div class="ritual-icon"></div>
                Ritüel Sistemi
            </div>
            <div class="ritual-close" onclick="window.app.ritualManager.toggleRitualContainer(false)">✖</div>
        </div>
        
        <div class="ritual-description">
            Ritüeller, piyasa gücünüzü artıran özel eylemlerdir. Her ritüel farklı etkilere ve sürelere sahiptir. Ritüeller enerji gerektirir ve aktifleştirmek için hazırlık süreci gerekir.
        </div>
        
        <div class="ritual-list" id="ritual-list">
            <!-- Ritüeller JavaScript tarafından dinamik olarak eklenecek -->
        </div>
        
        <div class="ritual-actions">
            <div class="ritual-btn" onclick="window.app.ritualManager.prepareSelectedRitual()">Hazırla</div>
            <div class="ritual-btn primary" onclick="window.app.ritualManager.activateSelectedRitual()">Aktifleştir</div>
        </div>
        
        <div class="ritual-status" id="ritual-status">
            Aktif ritüel yok. Bir ritüel seçip hazırlayın.
        </div>
    </div>

    <!-- Dikey İkon Paneli -->
    <div class="vertical-icon-panel">
        <button id="notifications-btn" class="vertical-icon-btn" title="Bildirimler">📢</button>
        <button id="pantheon-toggle-btn" class="vertical-icon-btn" title="Panteon Sistemi">👑</button>
        <button id="energy-toggle-btn" class="vertical-icon-btn" title="Enerji Yönetimi">⚡</button>
        <button id="ritual-toggle-btn" class="vertical-icon-btn" title="Ritüel Sistemi">✨</button>
        <button id="quick-settings-btn" class="vertical-icon-btn" title="Hızlı Ayarlar">⚙️</button>
        <button id="vertical-stats-btn" class="vertical-icon-btn" title="İstatistikler">📊</button>
        <button id="vertical-log-btn" class="vertical-icon-btn" title="Log">📜</button>
    </div>

    <!-- AYARLAR MODAL -->
    <div id="settings-modal-overlay">
        <div class="settings-modal-content">
            <div class="settings-modal-header">
                <span>AYARLAR & OPTİMİZASYON</span>
                <button class="close-btn" id="close-settings-modal-btn">&times;</button>
            </div>
            <div class="settings-modal-body">
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Temel Parametreler</div>
                    <div class="form-group"><label class="form-label">Min. Uyum Skoru (1-10)</label><input type="range" id="modal-confluence-threshold" class="form-control" min="1" max="10" value="3" step="1"></div>
                    <div class="form-group"><label class="form-label">RSI Periyodu</label><input type="number" id="modal-param-rsi-period" class="form-control" value="14"></div>
                    <div class="form-group"><label class="form-label">ATR Periyodu</label><input type="number" id="modal-param-atr-period" class="form-control" value="14"></div>
                    <div class="form-group"><label class="form-label">Duvar Tespiti (BTC Miktarı)</label><input type="number" id="modal-param-wall-btc" class="form-control" value="20"></div>
                    <div class="form-group"><label class="form-label">Risk/Ödül Oranı (R/R)</label><input type="number" id="modal-param-rr-ratio" class="form-control" value="1.5" step="0.1"></div>
                </div>
                <div
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Cooldown Ayarları</div>
                    <div class="form-group"><label class="form-label">Genel Sinyal Cooldown (ms)</label><input type="number" id="modal-signal-cooldown-ms" class="form-control" value="15000" min="0" step="100"></div>
                    <div class="form-group"><label class="form-label">Aynı Yön Sinyal Cooldown (ms)</label><input type="number" id="modal-same-direction-cooldown-ms" class="form-control" value="30000" min="0" step="100"></div>
                    <div class="form-group"><label class="form-label">Ters Yön Cooldown (ms)</label><input type="number" id="modal-opposite-direction-cooldown-ms" class="form-control" value="20000" min="0" step="100"></div>
                    <div class="form-group"><label class="form-label">Ters Yön Histerezis (+Puan)</label><input type="number" id="modal-reverse-hysteresis-points" class="form-control" value="2" min="0" step="1"></div>
                    <div class="form-group"><label class="form-label">Proposal Timeout (ms)</label><input type="number" id="modal-proposal-timeout-ms" class="form-control" value="3000" min="500" step="100"></div>
                    <div class="form-group"><label class="form-label">Strateji Teklifi Cooldown (ms)</label><input type="number" id="modal-strategy-proposal-cooldown-ms" class="form-control" value="10000" min="0" step="100"></div>
                </div>
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Gelişmiş Özellikler</div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-spoof-detection" class="feature-toggle" checked> Spoof Tespiti</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-cusum-drift" class="feature-toggle" checked> CUSUM Sapma Tespiti</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-risk-guardian" class="feature-toggle" checked> Risk Koruyucu (Kill Switch)</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-auto-optimize" class="feature-toggle" checked> Oto-Optimizasyon</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-auto-toggle-strat" class="feature-toggle" checked> Stratejileri Oto-Ayarla</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-breakeven-trail" class="feature-toggle" checked> Maliyete Çek/Takip Eden SL</label></div>
                    <div class="form-group"><label class="form-label">BE R Oranı</label><input type="number" id="modal-be-at-r" class="form-control" value="0.8" step="0.1"></div>
                    <div class="form-group"><label class="form-label">Trailing Başlangıç R Oranı</label><input type="number" id="modal-trail-after-r" class="form-control" value="1.5" step="0.1"></div>
                    <div class="form-group"><label class="form-label">Trailing Kârı R Oranı</label><input type="number" id="modal-trail-to-r" class="form-control" value="0.5" step="0.1"></div>
                </div>

                <!-- YENİ EKLENEN BÖLÜM BAŞLANGICI -->
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Sinyal Teyit & Gelişmiş Filtreleme</div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-candle-confirm" class="feature-toggle" checked> Sinyal için Mum Kapanışını Bekle</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-mtf-confirm" class="feature-toggle" checked> Üst Zaman Dilimi Trend Teyidi</label></div>
                    <div class="form-group">
                        <label class="form-label">MTF Zaman Dilimi</label>
                        <select id="modal-mtf-timeframe" class="form-control">
                            <option value="5m">5m</option>
                            <option value="15m" selected>15m</option>
                            <option value="1h">1h</option>
                            <option value="4h">4h</option>
                        </select>
                    </div>
                     <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-dynamic-sizing" class="feature-toggle" checked> Sinyal Gücüne Göre Dinamik Boyutlandırma</label></div>
                    <hr style="border-color: var(--border-color); margin: 10px 0;">
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-tts" class="feature-toggle" checked> Sesli Bildirimler</label></div>
                    <div class="form-group">
                        <label class="form-label">Ses Seçimi</label>
                        <select id="modal-tts-voice-select" class="form-control"></select>
                    </div>
                </div>
                <!-- YENİ EKLENEN BÖLÜM SONU -->

                <div class="settings-group" style="grid-column: 1 / -1;">
                     <div class="panel-title" style="margin-bottom: 10px;">Aktif Stratejiler</div>
                    <div id="modal-strategy-toggles" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 5px;"></div>
                </div>
                <div class="settings-group" style="grid-column: 1 / -1;">
                    <div class="panel-title" style="margin-bottom: 10px;">Sinyal Geçmişi ve Analiz</div>
                    <div class="data-table-container" style="max-height: 300px;">
                        <table class="data-table">
                            <thead>
                                <tr>
                                    <th>Zaman</th>
                                    <th>Sembol</th>
                                    <th>Tip</th>
                                    <th>Fiyat</th>
                                    <th>TP</th>
                                    <th>SL</th>
                                    <th>Skor</th>
                                    <th>Katkı</th>
                                    <th>Boyut</th>
                                    <th>Durum</th>
                                    <th>Not</th>
                                </tr>
                            </thead>
                            <tbody id="modal-signals-body"></tbody>
                        </table>
                    </div>
                    <button id="modal-clear-signals-btn" class="btn btn-danger btn-sm" style="margin-top: 10px;">Tüm Sinyalleri Sil</button>
                    <div id="modal-stats-container" style="margin-top: 15px;"></div>
                </div>
            </div>
            <div class="settings-modal-footer">
                <button id="reset-all-settings-btn" class="btn btn-danger">AYARLARI SIFIRLA</button>
                <button id="save-settings-btn" class="btn btn-success">AYARLARI KAYDET</button>
            </div>
        </div>
    </div>
    <!-- YENİ LOG PANELİ (MODAL) -->
    <div id="log-modal-overlay">
        <div class="log-modal-content">
            <div class="log-modal-header">
                <span>SİSTEM LOGLARI & GÜNLÜK</span>
                <div>
                    <button id="export-logs-btn" class="btn btn-sm btn-success">Logları Dışa Aktar</button>
                    <button class="close-btn" id="close-log-modal-btn">&times;</button>
                </div>
            </div>
            <div class="log-modal-body">
                <pre id="log-output"></pre>
            </div>
        </div>
    </div>

   

    <!-- ŞEREF TABLOSU MODAL -->
    <div id="honor-modal-overlay" style="position:fixed; inset:0; background:rgba(0,0,0,0.7); display:none; z-index:2600; align-items:center; justify-content:center;">
      <div style="background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; width:90%; max-width:900px; max-height:90%; overflow:auto;">
        <div style="padding:10px; border-bottom:1px solid var(--border-color); display:flex; justify-content:space-between; align-items:center;">
          <div style="font-weight:700; color:var(--primary)">Şeref Tablosu</div>
          <button id="close-honor-modal" class="btn btn-tiny">Kapat</button>
        </div>
        <div id="honor-modal-body" style="padding:12px;"></div>
      </div>
    </div>

<script>
    // Sinyal sesleri
    function playSignal(type) {
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            if (type === 'buy') {
                oscillator.type = 'triangle'; oscillator.frequency.value = 1000;
            } else if (type === 'sell') {
                oscillator.type = 'square'; oscillator.frequency.value = 400;
            } else if (type === 'combat') {
                oscillator.type = 'sawtooth'; oscillator.frequency.value = 800; 
                gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1);
                oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 1);
                return;
            }
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.5);
        } catch (error) { console.log('Ses çalınamadı:', error); }
    }
    
    // Ses sentez motoruyla gelişmiş sesli bildirim fonksiyonu
    function playSoundAlert(type, priority = 1) {
        try {
            if (!window.audioContext) {
                window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            const audioContext = window.audioContext;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filterNode = audioContext.createBiquadFilter();
            
            oscillator.connect(filterNode);
            filterNode.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Bildirim türüne göre ses ayarları
            switch (type) {
                case 'success':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(660, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(880, audioContext.currentTime + 0.1);
                    filterNode.type = 'lowpass';
                    filterNode.frequency.value = 1500;
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.4);
                    break;
                    
                case 'warning':
                case 'alert':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(330, audioContext.currentTime + 0.15);
                    filterNode.type = 'bandpass';
                    filterNode.frequency.value = 500;
                    filterNode.Q.value = 3;
                    gainNode.gain.setValueAtTime(0.25 * Math.min(priority/2, 1), audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
                    
                case 'error':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(196, audioContext.currentTime + 0.2);
                    filterNode.type = 'highpass';
                    filterNode.frequency.value = 150;
                    gainNode.gain.setValueAtTime(0.3 * Math.min(priority/2, 1), audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.6);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.6);
                    break;
                    
                case 'notification':
                default:
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 523.25; // C5
                    filterNode.type = 'lowpass';
                    filterNode.frequency.value = 800;
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
            }
            
            // Yüksek öncelikli bildirimlerde ikincil ses
            if (priority >= 4) {
                setTimeout(() => {
                    const osc2 = audioContext.createOscillator();
                    const gain2 = audioContext.createGain();
                    osc2.connect(gain2);
                    gain2.connect(audioContext.destination);
                    
                    osc2.type = 'sine';
                    osc2.frequency.value = 880;
                    gain2.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gain2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    
                    osc2.start(audioContext.currentTime);
                    osc2.stop(audioContext.currentTime + 0.15);
                }, 300);
            }
            
        } catch (error) {
            console.error('Ses sentezleme hatası:', error);
        }
    }

    /* =========================
       GÖRSELLEŞTİRME YÖNETİCİLERİ
       ========================= */
        class AdvancedNotificationCenter {
        constructor(app) {
            this.app = app;
            this.container = document.getElementById('notifications-container');
            this.notifications = [];
            this.maxHistory = 50; // Maximum number of notifications to keep in history
            this.maxVisibleNotifications = 10; // How many notifications to show at once
            this.groupSimilarTimeWindow = 5000; // Group similar notifications within 5 seconds
            
            // Load history from localStorage if available
            this.loadHistory();
            
            // Create notification categories
            this.categories = {
                system: { icon: '🔧', sound: false, color: 'var(--text-secondary)' },
                trade: { icon: '📊', sound: true, color: 'var(--primary)' },
                alert: { icon: '⚠️', sound: true, color: 'var(--neutral)' },
                success: { icon: '✅', sound: true, color: 'var(--positive)' },
                error: { icon: '❌', sound: true, color: 'var(--negative)' }
            };
            
            this.soundEnabled = true;
            this.priorityThreshold = 2; // Priority level for playing sounds (1-5)
            
            // Initialize UI
            this.initStyles();
            this.initNotificationPanel();
        }
        
        initStyles() {
            // Add custom styles for notifications if not already added
            if (!document.getElementById('notification-center-styles')) {
                const style = document.createElement('style');
                style.id = 'notification-center-styles';
                style.textContent = `
                    /* Advanced Notification Center Styles */
                    .notifications { 
                        position: fixed; 
                        bottom: 15px; 
                        left: 15px;
                        z-index: 2000; 
                        width: 320px;
                        max-height: 80vh;
                        overflow-y: auto;
                        display: flex;
                        flex-direction: column;
                        gap: 8px;
                        padding-right: 8px;
                    }

                    .notification { 
                        background: rgba(22, 27, 34, 0.95);
                        backdrop-filter: blur(5px);
                        border: 1px solid var(--border-color); 
                        border-left-width: 4px; 
                        border-radius: 6px; 
                        padding: 10px 12px;
                        font-size: 12px;
                        box-shadow: 0 3px 10px rgba(0,0,0,0.3); 
                        animation: slide-in 0.3s ease-out;
                        transition: opacity 0.3s ease, transform 0.3s ease;
                        overflow: hidden;
                    }

                    .notification-control-panel {
                        background: var(--panel-bg);
                        border: 1px solid var(--border-color);
                        border-radius: 4px;
                        padding: 5px 8px;
                        margin-bottom: 8px;
                    }

                    .notification-header {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        margin-bottom: 5px;
                        font-size: 11px;
                        font-weight: bold;
                        color: var(--text-secondary);
                    }

                    .notification-header div {
                        display: flex;
                        gap: 5px;
                    }

                    .notification-icon {
                        font-size: 14px;
                        margin-right: 8px;
                        flex-shrink: 0;
                    }

                    .notification-priority {
                        font-size: 9px;
                        color: var(--primary);
                        letter-spacing: 1px;
                    }

                    .notification-close {
                        cursor: pointer;
                        font-size: 16px;
                        line-height: 1;
                        opacity: 0.7;
                        transition: opacity 0.2s;
                    }

                    .notification-close:hover {
                        opacity: 1;
                    }

                    .notification-content {
                        flex-grow: 1;
                        line-height: 1.4;
                        word-break: break-word;
                        position: relative;
                    }

                    .notification-time {
                        font-size: 9px;
                        color: var(--text-secondary);
                        margin-top: 2px;
                    }

                    .notification-count {
                        position: absolute;
                        top: -8px;
                        right: -5px;
                        background: var(--primary);
                        color: #000;
                        border-radius: 10px;
                        padding: 1px 6px;
                        font-size: 10px;
                        font-weight: bold;
                    }

                    /* Category-specific styles */
                    .notification.system { border-left-color: var(--text-secondary); }
                    .notification.trade { border-left-color: var(--primary); }
                    .notification.alert { border-left-color: var(--neutral); }
                    .notification.success { border-left-color: var(--positive); }
                    .notification.error { border-left-color: var(--negative); }
                    
                    .high-priority {
                        border-left-width: 6px !important;
                        animation: pulse-highlight 2s infinite;
                    }

                    /* Animation keyframes */
                    @keyframes slide-in {
                        from { transform: translateX(-100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    
                    @keyframes pulse-highlight {
                        0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4); }
                        70% { box-shadow: 0 0 0 8px rgba(255, 255, 255, 0); }
                        100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
                    }
                    
                    /* Notification history modal */
                    #notification-history-modal .modal-body {
                        max-height: 400px;
                        overflow-y: auto;
                    }
                    
                    .notification-filters {
                        display: flex;
                        gap: 5px;
                        margin-bottom: 10px;
                        flex-wrap: wrap;
                    }
                    
                    .notification-filters .filter {
                        padding: 3px 8px;
                        border-radius: 12px;
                        background: var(--panel-bg);
                        border: 1px solid var(--border-color);
                        font-size: 11px;
                        cursor: pointer;
                    }
                    
                    .notification-filters .filter.active {
                        background: var(--primary);
                        color: #000;
                    }
                    
                    #notification-history-list {
                        display: flex;
                        flex-direction: column;
                        gap: 8px;
                    }
                    
                    /* Responsive adjustments */
                    @media screen and (max-width: 768px) {
                        .notifications {
                            width: 85%;
                            max-width: 320px;
                        }
                        
                        .notification {
                            padding: 8px 10px;
                            font-size: 11px;
                        }
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
        initNotificationPanel() {
            // Create container if it doesn't exist
            if (!this.container) {
                this.container = document.createElement('div');
                this.container.id = 'notifications-container';
                this.container.className = 'notifications';
                document.body.appendChild(this.container);
            }
            
            // Create history modal but don't attach to DOM yet
            this.createHistoryModal();
            
            // Not adding notification control panel here anymore
            // It's now handled in the initApp() function with the vertical icon panel
        }
        
        /**
         * Create the notification history modal
         */
        createHistoryModal() {
            // Remove existing modal if any
            const existingModal = document.getElementById('notification-history-modal');
            if (existingModal) existingModal.remove();
            
            const modal = document.createElement('div');
            modal.id = 'notification-history-modal';
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>Bildirim Geçmişi</h3>
                        <span class="close-modal">&times;</span>
                    </div>
                    <div class="modal-body">
                        <div class="notification-filters">
                            <button class="filter active" data-filter="all">Tümü</button>
                            <button class="filter" data-filter="trade">İşlem</button>
                            <button class="filter" data-filter="alert">Uyarı</button>
                            <button class="filter" data-filter="success">Başarılı</button>
                            <button class="filter" data-filter="error">Hata</button>
                            <button class="filter" data-filter="system">Sistem</button>
                        </div>
                        <div id="notification-history-list"></div>
                    </div>
                    <div class="modal-footer">
                        <button id="clear-notifications-history" class="btn btn-danger">Geçmişi Temizle</button>
                    </div>
                </div>
            `;
            
            // Append to body but keep it hidden
            document.body.appendChild(modal);
            
            // Add event listeners
            const closeBtn = modal.querySelector('.close-modal');
            closeBtn.addEventListener('click', () => {
                modal.style.display = 'none';
            });
            
            const filters = modal.querySelectorAll('.filter');
            filters.forEach(filter => {
                filter.addEventListener('click', (e) => {
                    filters.forEach(f => f.classList.remove('active'));
                    e.target.classList.add('active');
                    this.filterHistory(e.target.getAttribute('data-filter'));
                });
            });
            
            document.getElementById('clear-notifications-history').addEventListener('click', () => {
                this.clearHistory();
                this.notify('Bildirim geçmişi temizlendi', 'system', 1);
                modal.style.display = 'none';
            });
        }
        
        /**
         * Display a new notification
         * @param {string} message - The notification message
         * @param {string} category - Notification category (system, trade, alert, success, error)
         * @param {number} priority - Priority level (1-5)
         * @param {number} timeout - How long to display (ms)
         */
        notify(message, category = 'system', priority = 2, timeout = 5000) {
            if (!this.container) return;
            
            // Default category if invalid
            if (!this.categories[category]) category = 'system';
            
            // Check for similar recent notifications to avoid spam
            if (this.shouldGroupWithSimilar(message, category)) {
                return;
            }
            
            // Generate unique ID
            const notificationId = 'notify-' + Date.now() + '-' + Math.random().toString(36).substr(2, 5);
            const timestamp = new Date();
            
            // Create notification element
            const notification = document.createElement('div');
            notification.id = notificationId;
            notification.className = `notification ${category}`;
            notification.setAttribute('data-id', notificationId);
            if (priority >= 4) notification.classList.add('high-priority');
            
            // Build notification content
            const catInfo = this.categories[category];
            notification.innerHTML = `
                <div class="notification-header">
                    <span class="notification-icon">${catInfo.icon}</span>
                    <span class="notification-priority">${'•'.repeat(priority)}</span>
                    <span class="notification-close">&times;</span>
                </div>
                <div class="notification-content">
                    ${message}
                    <div class="notification-time">${timestamp.toLocaleTimeString()}</div>
                </div>
            `;
            
            // Add to DOM
            const controlPanel = this.container.querySelector('.notification-control-panel');
            if (controlPanel && controlPanel.nextSibling) {
                this.container.insertBefore(notification, controlPanel.nextSibling);
            } else {
                this.container.appendChild(notification);
            }
            
            // Add to history
            this.addToHistory({
                id: notificationId,
                message,
                category,
                priority,
                timestamp
            });
            
            // Play sound for high priority notifications
            if (this.soundEnabled && priority >= this.priorityThreshold) {
                this.playNotificationSound(category, priority);
            }
            
            // Add close event
            const closeBtn = notification.querySelector('.notification-close');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    notification.remove();
                });
            }
            
            // Clean up old notifications
            this.cleanupOldNotifications();
            
            // Auto-remove after timeout
            setTimeout(() => {
                if (notification.parentNode) {
                    // Add fade-out animation
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateX(-100%)';
                    setTimeout(() => notification.remove(), 300);
                }
            }, timeout);
            
            return notification;
        }
        
        /**
         * Determine if a similar notification was recently shown
         */
        shouldGroupWithSimilar(message, category) {
            const now = Date.now();
            const similar = this.notifications.find(n => 
                n.category === category && 
                this.isSimilarMessage(n.message, message) && 
                (now - n.timestamp < this.groupSimilarTimeWindow)
            );
            
            if (similar) {
                // Update the existing notification instead of creating a new one
                const existingNotification = document.querySelector(`.notification.${category}[data-id="${similar.id}"]`);
                if (existingNotification) {
                    const countBadge = existingNotification.querySelector('.notification-count');
                    if (countBadge) {
                        countBadge.textContent = (parseInt(countBadge.textContent) || 1) + 1;
                    } else {
                        const contentDiv = existingNotification.querySelector('.notification-content');
                        if (contentDiv) {
                            contentDiv.innerHTML += `<span class="notification-count">2</span>`;
                        }
                    }
                    // Reset the timestamp for this notification
                    similar.timestamp = now;
                    return true;
                }
            }
            
            return false;
        }
        
        /**
         * Compare messages for similarity
         */
        isSimilarMessage(msg1, msg2) {
            // Basic similarity check - can be enhanced with more sophisticated comparison
            if (msg1 === msg2) return true;
            
            // Check for pattern-based similarities (e.g., only numbers differ)
            const normalized1 = msg1.replace(/\d+(\.\d+)?%?/g, 'X');
            const normalized2 = msg2.replace(/\d+(\.\d+)?%?/g, 'X');
            
            return normalized1 === normalized2;
        }
        
        /**
         * Add notification to history and save
         */
        addToHistory(notification) {
            // Add to history array
            this.notifications.unshift(notification);
            
            // Trim history if needed
            if (this.notifications.length > this.maxHistory) {
                this.notifications = this.notifications.slice(0, this.maxHistory);
            }
            
            // Save to localStorage
            this.saveHistory();
        }
        
        /**
         * Play sound notification
         */
        playNotificationSound(category, priority) {
            try {
                // Try to use app's built-in sound if available
                if (this.app.settings?.features?.enableTts && priority >= 3 && this.categories[category].sound) {
                    if (typeof this.app.playSignal === 'function') {
                        // Use existing signal player if available
                        if (category === 'error' || category === 'alert') {
                            this.app.playSignal('alert');
                        } else if (category === 'success' || category === 'trade') {
                            this.app.playSignal('combat');
                        }
                        return;
                    }
                }
                
                // Fallback to Web Audio API
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Different sounds for different categories
                switch(category) {
                    case 'success':
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(880, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(1320, audioContext.currentTime + 0.1);
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                    case 'alert':
                    case 'error':
                        oscillator.type = 'triangle';
                        oscillator.frequency.setValueAtTime(660, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(330, audioContext.currentTime + 0.15);
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.4);
                        break;
                    case 'trade':
                        oscillator.type = 'sawtooth';
                        oscillator.frequency.setValueAtTime(priority >= 4 ? 880 : 440, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;
                    default:
                        oscillator.type = 'sine';
                        oscillator.frequency.value = 440;
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.1);
                }
            } catch (error) {
                console.error('Bildirim sesi çalınamadı:', error);
            }
        }
        
        /**
         * Remove old notifications to maintain visibility limit
         */
        cleanupOldNotifications() {
            // Get all current notification elements (excluding control panel)
            const notifElements = Array.from(this.container.querySelectorAll('.notification')).filter(
                el => !el.classList.contains('notification-control-panel')
            );
            
            // If we're over the limit, remove oldest ones
            if (notifElements.length > this.maxVisibleNotifications) {
                const toRemove = notifElements.slice(this.maxVisibleNotifications);
                toRemove.forEach(el => el.remove());
            }
        }
        
        /**
         * Clear all visible notifications
         */
        clearAll() {
            const notifications = this.container.querySelectorAll('.notification');
            notifications.forEach(notification => {
                // Don't remove the control panel
                if (!notification.classList.contains('notification-control-panel')) {
                    notification.remove();
                }
            });
        }
        
        /**
         * Clear notification history and save
         */
        clearHistory() {
            this.notifications = [];
            this.saveHistory();
        }
        
        /**
         * Save notification history to localStorage
         */
        saveHistory() {
            try {
                localStorage.setItem('utc_notifications', JSON.stringify(this.notifications));
            } catch (e) {
                console.error('Failed to save notification history', e);
            }
        }
        
        /**
         * Load notification history from localStorage
         */
        loadHistory() {
            try {
                const saved = localStorage.getItem('utc_notifications');
                if (saved) {
                    this.notifications = JSON.parse(saved);
                    
                    // Convert date strings back to Date objects
                    this.notifications.forEach(n => {
                        if (typeof n.timestamp === 'string') {
                            n.timestamp = new Date(n.timestamp).getTime();
                        }
                    });
                }
            } catch (e) {
                console.error('Failed to load notification history', e);
                this.notifications = [];
            }
        }
        
        /**
         * Show notification history in a modal
         */
        showHistory() {
            const modal = document.getElementById('notification-history-modal');
            if (!modal) return;
            
            // Update the history list
            this.filterHistory('all');
            
            // Show the modal
            modal.style.display = 'block';
        }
        
        /**
         * Filter history by category
         */
        filterHistory(filter = 'all') {
            const historyList = document.getElementById('notification-history-list');
            if (!historyList) return;
            
            // Clear current list
            historyList.innerHTML = '';
            
            // Filter notifications
            const filtered = filter === 'all' 
                ? [...this.notifications]
                : this.notifications.filter(n => n.category === filter);
            
            if (filtered.length === 0) {
                historyList.innerHTML = '<div class="empty-state">Bu kategoride bildirim bulunmuyor.</div>';
                return;
            }
            
            // Add notifications to history list
            filtered.forEach(n => {
                const item = document.createElement('div');
                item.className = `notification ${n.category}`;
                
                const catInfo = this.categories[n.category] || this.categories.system;
                const date = new Date(n.timestamp);
                const dateStr = date.toLocaleString();
                
                item.innerHTML = `
                    <div class="notification-header">
                        <span class="notification-icon">${catInfo.icon}</span>
                        <span class="notification-priority">${'•'.repeat(n.priority || 1)}</span>
                    </div>
                    <div class="notification-content">
                        ${n.message}
                        <div class="notification-time">${dateStr}</div>
                    </div>
                `;
                
                historyList.appendChild(item);
            });
        }
    }

    class ChartManager {
        constructor(chartContainerId) {
            this.chartContainer = document.getElementById(chartContainerId);
            if (!this.chartContainer) throw new Error("Chart container bulunamadı!");
            this.chart = null; this.series = {}; this.signalMarkers = [];
            this.bbandsSeries = null;
            this._initChart();
        }
        _initChart() {
            this.chart = LightweightCharts.createChart(this.chartContainer, this._getChartOptions());
            this.series.candles = this.chart.addCandlestickSeries(this._getCandlestickOptions());
            this.series.volume = this.chart.addHistogramSeries(this._getVolumeOptions());
            
            const lineStyle = { color: 'rgba(255, 255, 0, 0.6)', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted };
            this.series.bbUpper = this.chart.addLineSeries(lineStyle);
            this.series.bbMiddle = this.chart.addLineSeries(lineStyle);
            this.series.bbLower = this.chart.addLineSeries(lineStyle);

            window.addEventListener('resize', () => { 
                if (this.chart && this.chartContainer.clientWidth > 0 && this.chartContainer.clientHeight > 0) {
                    this.chart.resize(this.chartContainer.clientWidth, this.chartContainer.clientHeight);
                }
            });

            // --- YENİ: Grafik görünümünü kaydetmek için olay dinleyici ---
            this.chart.timeScale().subscribeVisibleLogicalRangeChange(logicalRange => {
                if (logicalRange) {
                    localStorage.setItem('utc_chart_view', JSON.stringify(logicalRange));
                }
            });
        }

        // --- YENİ: Kaydedilmiş görünümü geri yükleme fonksiyonu ---
        restoreView() {
            const savedView = localStorage.getItem('utc_chart_view');
            if (savedView) {
                try {
                    const logicalRange = JSON.parse(savedView);
                    this.chart.timeScale().setVisibleLogicalRange(logicalRange);
                } catch (e) {
                    console.error("Kaydedilmiş grafik görünümü yüklenemedi:", e);
                    this.chart.timeScale().fitContent();
                }
            } else {
                this.chart.timeScale().fitContent();
            }
        }

        updateTheme() {
            if(!this.chart) return;
            this.chart.applyOptions(this._getChartOptions());
            this.series.candles.applyOptions(this._getCandlestickOptions());
            this.series.volume.applyOptions(this._getVolumeOptions());
            const lineStyle = { color: 'rgba(255, 255, 0, 0.6)', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted };
            this.series.bbUpper.applyOptions(lineStyle);
            this.series.bbMiddle.applyOptions(lineStyle);
            this.series.bbLower.applyOptions(lineStyle);
        }
        setData(candles) {
            if (!this.series.candles) return;
            const candleData = candles.map(c => ({ time: c.time / 1000, open: c.open, high: c.high, low: c.low, close: c.close }));
            const volumeData = candles.map(c => ({ time: c.time / 1000, value: c.volume, color: c.close >= c.open ? 'rgba(40, 167, 69, 0.5)' : 'rgba(220, 53, 69, 0.5)' }));
            this.series.candles.setData(candleData);
            this.series.volume.setData(volumeData);
            
            // --- DÜZELTME: Veri yüklendikten sonra kaydedilmiş görünümü uygula ---
            this.restoreView();
        }

        drawBollingerBands(bbandsData) {
            if (!this.series.bbUpper || !bbandsData) return;
            const mapToChartTime = (d) => ({ time: d.time / 1000, value: d.value });
            this.series.bbUpper.setData(bbandsData.upper.map(mapToChartTime));
            this.series.bbMiddle.setData(bbandsData.middle.map(mapToChartTime));
            this.series.bbLower.setData(bbandsData.lower.map(mapToChartTime));
        }

        updateRealtime(kline) {
             if (!this.series.candles) return;
             const candle = { time: kline.t / 1000, open: parseFloat(kline.o), high: parseFloat(kline.h), low: parseFloat(kline.l), close: parseFloat(kline.c) };
             const volume = { time: kline.t / 1000, value: parseFloat(kline.v), color: candle.close >= candle.open ? 'rgba(40, 167, 69, 0.5)' : 'rgba(220, 53, 69, 0.5)' };
             this.series.candles.update(candle);
             this.series.volume.update(volume);
        }
        addSignalMarker(signal) {
            if (!this.series.candles) return;
            const styles = getComputedStyle(document.body);
            const isMobile = window.innerWidth <= 768;
            let text = '';

            if (isMobile) {
                text = `S:${typeof signal.score === 'number' ? signal.score.toFixed(1) : signal.score}`;
            } else {
                text = `Skor: ${typeof signal.score === 'number' ? signal.score.toFixed(1) : signal.score} @ ${this._formatMarkerPrice(signal.price)}`;
                if (signal.recommendedSize) {
                    text += ` | ${signal.recommendedSize}`;
                }
            }

            const marker = {
                id: signal.id,
                time: signal.timestamp / 1000,
                position: signal.direction === 'buy' ? 'belowBar' : 'aboveBar',
                color: signal.direction === 'buy' ? styles.getPropertyValue('--positive').trim() : styles.getPropertyValue('--negative').trim(),
                shape: signal.direction === 'buy' ? 'arrowUp' : 'arrowDown',
                text: text
            };
            if (signal.status === 'pending') {
                marker.color = styles.getPropertyValue('--neutral').trim();
                marker.shape = 'circle';
            }
            
            this.signalMarkers = this.signalMarkers.filter(m => m.id !== signal.id);
            this.signalMarkers.push(marker);
            this.series.candles.setMarkers(this.signalMarkers);
        }
        clearMarkers() { if (!this.series.candles) return; this.signalMarkers = []; this.series.candles.setMarkers([]); }
        zoom(factor) {
            if (!this.chart) return;
            const timeScale = this.chart.timeScale();
            const currentLogicalRange = timeScale.getVisibleLogicalRange();
            if (!currentLogicalRange) return;
            const newLogicalRange = { from: currentLogicalRange.from * factor, to: currentLogicalRange.to * factor };
            timeScale.setVisibleLogicalRange(newLogicalRange);
        }
        zoomIn() { this.zoom(0.9); }
        zoomOut() { this.zoom(1.1); }
        resetZoom() { 
            if (this.chart) {
                this.chart.timeScale().fitContent(); 
                // --- YENİ: Sıfırlama sonrası hafızayı da temizle ---
                localStorage.removeItem('utc_chart_view');
            }
        }

        _getDecimalPlacesBasedOnPrice(price) { if(!price) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
        _formatMarkerPrice(price) { const d = this._getDecimalPlacesBasedOnPrice(price); return price.toFixed(d); }
        _getChartOptions() {
            const styles = getComputedStyle(document.body);
            return {
                width: this.chartContainer.clientWidth, height: this.chartContainer.clientHeight,
                layout: { backgroundColor: 'transparent', textColor: styles.getPropertyValue('--text-main').trim(), fontFamily: "'Roboto Mono', monospace" },
                grid: { vertLines: { color: styles.getPropertyValue('--border-color').trim() }, horzLines: { color: styles.getPropertyValue('--border-color').trim() } },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                timeScale: { borderColor: styles.getPropertyValue('--border-color').trim(), timeVisible: true, secondsVisible: false, rightOffset: 10 }
            };
        }
        _getCandlestickOptions() {
             const styles = getComputedStyle(document.body);
             return { 
                upColor: styles.getPropertyValue('--positive').trim(), downColor: styles.getPropertyValue('--negative').trim(),
                borderVisible: false, wickUpColor: styles.getPropertyValue('--positive').trim(), wickDownColor: styles.getPropertyValue('--negative').trim(),
                priceFormat: { type: 'price', precision: 6, minMove: 0.000001 }
             };
        }
        _getVolumeOptions() { return { priceFormat: { type: 'volume' }, priceScaleId: '', scaleMargins: { top: 0.8, bottom: 0 } }; }
    }


    class HeatmapManager {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            if (!this.canvas) throw new Error("Heatmap canvas bulunamadı!");
            this.ctx = this.canvas.getContext('2d');
            this._resizeCanvas();
            window.addEventListener('resize', () => this._resizeCanvas());
        }
        draw(orderBook, symbolPrice) {
            if (!orderBook.bids || !Array.isArray(orderBook.bids) || orderBook.bids.length === 0 || !orderBook.asks || !Array.isArray(orderBook.asks) || orderBook.asks.length === 0) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                return;
            }
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            const asks = orderBook.asks.slice().reverse(); const bids = orderBook.bids;
            const allLevels = [...bids, ...asks]; const maxQty = Math.max(...allLevels.map(l => l[1]));
            this._drawSection(asks, 'asks', maxQty, symbolPrice); this._drawSection(bids, 'bids', maxQty, symbolPrice);
        }
        updateTheme() { this._resizeCanvas(); }
        _drawSection(levels, type, maxQty, symbolPrice) {
            const styles = getComputedStyle(document.body);
            const baseColor = type === 'asks' ? styles.getPropertyValue('--negative').trim() : styles.getPropertyValue('--positive').trim();
            if (levels.length === 0) return;
            const heightPerLevel = (this.canvas.height / 2) / levels.length;
            const priceDecimals = this._getDecimalPlaces(symbolPrice);
            const labelSkipInterval = heightPerLevel < 12 ? Math.ceil(12 / heightPerLevel) : 1;
            levels.forEach((level, index) => {
                const [price, qty] = level;
                const intensity = Math.min(Math.sqrt(qty / maxQty), 1.0);
                this.ctx.fillStyle = this._hexToRgba(baseColor, intensity * 0.6 + 0.1);
                const y = type === 'asks' ? index * heightPerLevel : (this.canvas.height / 2) + (index * heightPerLevel);
                const barWidth = this.canvas.width * intensity;
                this.ctx.fillRect(0, y, barWidth, heightPerLevel);
                if (index % labelSkipInterval === 0) {
                    this.ctx.fillStyle = intensity > 0.5 ? '#FFFFFF' : styles.getPropertyValue('--text-secondary').trim();
                    this.ctx.font = '10px "Roboto Mono"'; this.ctx.textAlign = 'left';
                    this.ctx.fillText(`${(qty).toFixed(2)} @ ${price.toFixed(priceDecimals)}`, 10, y + heightPerLevel - 3);
                }
            });
        }
        _getDecimalPlaces(price) { if (!price) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
        _hexToRgba(hex, alpha) {
            if(!hex.startsWith('#')) return `rgba(120,120,120,${alpha})`;
            let r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        _resizeCanvas() { 
            if(this.canvas.parentElement) {
                this.canvas.width = this.canvas.parentElement.clientWidth; 
                this.canvas.height = this.canvas.parentElement.clientHeight; 
            }
        }
    }

    /* =========================
       GELİŞMİŞ ÖZELLİK YÖNETİCİLERİ
       ========================= */

    // Çoklu Zaman Dilimi Yöneticisi (Multi-Timeframe Manager) - Gelişmiş
    class LegacyMultiTimeframeManager {
        constructor(bot) {
            this.bot = bot;
            this.data = {}; // { '1h': { candles: [], ema20: null }, '15m': { ... } }
            this.intervals = {};
            this.isInitialized = false;
        }

        async initialize(symbol, timeframes = []) {
            if (this.isInitialized) this.cleanup();
            this.isInitialized = true;
            this.bot.logToJournal(`MTF Manager başlatılıyor: ${timeframes.join(', ')}`);
            for (const tf of timeframes) {
                this.data[tf] = { candles: [], ema20: null };
                await this.fetchHistoricalData(symbol, tf);
                this.intervals[tf] = setInterval(() => this.fetchRealtimeData(symbol, tf), this._timeframeToMs(tf));
            }
        }

        async fetchHistoricalData(symbol, timeframe) {
            try {
                const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${timeframe}&limit=100`;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`API Hatası: ${response.statusText}`);
                const data = await response.json();
                this.data[timeframe].candles = data.map(d => ({ time: d[0], close: parseFloat(d[4]) }));
                this.calculateIndicators(timeframe);
                this.bot.logToJournal(`${timeframe} için ${this.data[timeframe].candles.length} mum yüklendi.`);
            } catch (error) {
                console.error(`MTF geçmiş veri hatası (${timeframe}):`, error);
            }
        }

        async fetchRealtimeData(symbol, timeframe) {
            try {
                const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${timeframe}&limit=2`;
                const response = await fetch(url);
                if (!response.ok) return;
                const data = await response.json();
                const newCandle = { time: data[0][0], close: parseFloat(data[0][4]) };
                const lastCandle = this.data[timeframe].candles[this.data[timeframe].candles.length - 1];
                if (lastCandle && lastCandle.time === newCandle.time) {
                    this.data[timeframe].candles[this.data[timeframe].candles.length - 1] = newCandle;
                } else {
                    this.data[timeframe].candles.push(newCandle);
                    if(this.data[timeframe].candles.length > 101) this.data[timeframe].candles.shift();
                }
                this.calculateIndicators(timeframe);
            } catch (error) {
                 console.error(`MTF anlık veri hatası (${timeframe}):`, error);
            }
        }
        
        calculateIndicators(timeframe) {
            const candles = this.data[timeframe]?.candles;
            if (!candles || candles.length < 20) return;
            const closes = candles.map(c => c.close);
            this.data[timeframe].ema20 = this._calculateEMA(closes, 20);
        }

        _calculateEMA(prices, period) {
            const k = 2 / (period + 1);
            let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
            for (let i = period; i < prices.length; i++) {
                ema = (prices[i] * k) + (ema * (1 - k));
            }
            return ema;
        }

        getTrend(timeframe) {
            const tfData = this.data[timeframe];
            if (!tfData || !tfData.ema20) return 'neutral';
            
            const price = this.bot.marketData.price;
            const ema = tfData.ema20;
            if (!price || !ema) return 'neutral';

            const diff = Math.abs(price - ema) / ema;
            
            // Belirsizlik durumu için eşik değer (%0.1)
            if (diff < 0.001) return 'neutral';
            
            return price > ema ? 'up' : 'down';
        }
        
        _timeframeToMs(tf) {
            const unit = tf.slice(-1);
            const val = parseInt(tf.slice(0, -1));
            if (unit === 'm') return val * 60 * 1000;
            if (unit === 'h') return val * 60 * 60 * 1000;
            return 60000;
        }

        cleanup() {
            this.isInitialized = false;
            Object.values(this.intervals).forEach(clearInterval);
            this.data = {};
            this.intervals = {};
            this.bot.logToJournal("MTF Manager durduruldu ve temizlendi.");
        }
    }

    // Sahte Emir Tespiti (Spoof Detector)
        class SpoofDetector {
        constructor(bot) {
            this.bot = bot;
            // --- YENİ OPTİMİZASYON DEĞİŞKENLERİ ---
            this.largeOrderThreshold = 10; // BTC cinsinden BAŞLANGIÇ eşiği
            this.pendingChecks = []; // Onay bekleyen tespitler
            this.confirmationStats = { confirmed: 0, rejected: 0 }; // İstatistikler
            // --- BİTTİ ---
            this.trackedOrders = new Map();
            this.NOTIFICATION_COOLDOWN_MS = 30000;
            this.lastNotificationTime = 0;
            this.PRICE_PROXIMITY_PERCENT = 0.0005;
        }

        trackOrderBook(orderBook) {
            const now = Date.now();
            const currentBids = new Map(orderBook.bids.map(([p, q]) => [p, q]));
            const currentAsks = new Map(orderBook.asks.map(([p, q]) => [p, q]));
            this._detectSpoofing(now, currentBids, currentAsks);
            this._trackNewLargeOrders(now, orderBook);
        }

        _detectSpoofing(now, currentBids, currentAsks) {
            const ordersToDelete = [];
            for (const [price, order] of this.trackedOrders.entries()) {
                if (now - order.timestamp > 15000) {
                    ordersToDelete.push(price);
                    continue;
                }
                const book = order.type === 'bid' ? currentBids : currentAsks;
                const priceTolerance = price * this.PRICE_PROXIMITY_PERCENT;
                let stillExists = false;
                for (const [currentPrice, currentQty] of book.entries()) {
                    if (Math.abs(currentPrice - price) <= priceTolerance) {
                        if (currentQty >= order.qty * 0.8) {
                            stillExists = true;
                            break;
                        }
                    }
                }
                if (!stillExists) {
                    if (now - this.lastNotificationTime > this.NOTIFICATION_COOLDOWN_MS) {
                        let notificationText = '';
                        let ttsKey = '';
                        let expectedDirection = '';

                        if (order.type === 'bid') {
                            notificationText = `Sahte Alış Emri Çekildi! Düşüş gelebilir. Dikkat et hacı abi.`;
                            ttsKey = 'spoofBidRemoved';
                            expectedDirection = 'down';
                        } else {
                            notificationText = `Sahte Satış Emri Çekildi! Alım gelebilir. Dikkat et komutanım.`;
                            ttsKey = 'spoofAskRemoved';
                            expectedDirection = 'up';
                        }

                        this.bot.showNotification(notificationText, 'warning');
                        this.bot.speak(this.bot.getRandomMessage(ttsKey));
                        
                        // --- YENİ: TESPİTİ ONAY İÇİN KAYDET ---
                        this.pendingChecks.push({
                            timestamp: now,
                            priceAtDetection: this.bot.marketData.price,
                            expectedDirection: expectedDirection,
                            checkAfterCandles: 5 // 5 mum sonra kontrol et
                        });
                        // --- BİTTİ ---

                        this.lastNotificationTime = now;
                    }
                    ordersToDelete.push(price);
                }
            }
            ordersToDelete.forEach(price => this.trackedOrders.delete(price));
        }

        _trackNewLargeOrders(now, orderBook) {
            const processBook = (book, type) => {
                for (const [price, qty] of book) {
                    const btcValue = (this.bot.currentSymbol === 'BTCUSDT') ?
                        qty :
                        (qty * price) / (this.bot.marketData.btcPrice || 70000);
                    if (btcValue > this.largeOrderThreshold) { // Değişken eşiği kullan
                        if (!this.trackedOrders.has(price)) {
                            this.trackedOrders.set(price, { qty, timestamp: now, type });
                        }
                    }
                }
            };
            processBook(orderBook.bids, 'bid');
            processBook(orderBook.asks, 'ask');
        }

        // --- YENİ OPTİMİZASYON FONKSİYONLARI ---
        checkConfirmations() {
            const candleCount = this.bot.candles.length;
            if (candleCount < 10) return;

            this.pendingChecks = this.pendingChecks.filter(check => {
                const candlesSince = candleCount - this.bot.candles.findIndex(c => c.time >= check.timestamp);
                if (candlesSince < check.checkAfterCandles) {
                    return true; // Henüz kontrol zamanı gelmedi, listede kalsın
                }

                const priceNow = this.bot.candles[candleCount - 1].close;
                const priceChange = (priceNow - check.priceAtDetection) / check.priceAtDetection;
                
                let confirmed = false;
                if (check.expectedDirection === 'up' && priceChange > 0.001) { // %0.1'den fazla yükseldiyse
                    confirmed = true;
                } else if (check.expectedDirection === 'down' && priceChange < -0.001) { // %0.1'den fazla düştüyse
                    confirmed = true;
                }

                if (confirmed) {
                    this.confirmationStats.confirmed++;
                } else {
                    this.confirmationStats.rejected++;
                }
                return false; // Kontrol edildi, listeden kaldır
            });
        }

        autoOptimizeThreshold() {
            const totalChecks = this.confirmationStats.confirmed + this.confirmationStats.rejected;
            if (totalChecks < 10) return; // Yeterli veri birikene kadar bekle

            const rejectionRate = this.confirmationStats.rejected / totalChecks;

            if (rejectionRate > 0.6) { // Reddedilme oranı %60'tan fazlaysa (çok hassas)
                this.largeOrderThreshold *= 1.10; // Eşiği %10 artır (daha az hassas yap)
                this.bot.logToJournal(`Spoof Detector optimizasyonu: Eşik ${this.largeOrderThreshold.toFixed(2)} BTC'ye yükseltildi.`);
            } else if (rejectionRate < 0.3) { // Reddedilme oranı %30'dan azsa (çok kaba olabilir)
                this.largeOrderThreshold *= 0.95; // Eşiği %5 düşür (daha hassas yap)
                this.bot.logToJournal(`Spoof Detector optimizasyonu: Eşik ${this.largeOrderThreshold.toFixed(2)} BTC'ye düşürüldü.`);
            }

            // Eşiğin mantıklı sınırlar içinde kalmasını sağla
            this.largeOrderThreshold = Math.max(5, Math.min(50, this.largeOrderThreshold));

            // İstatistikleri sıfırla ki yeni eşikle tekrar ölçüm yapılsın
            this.confirmationStats = { confirmed: 0, rejected: 0 };
        }
        // --- BİTTİ ---
    }



    // CUSUM Sapma Tespiti (CUSUM Drift Detector)
    class CUSUMDriftDetector {
        constructor() {
            this.K = 0.5;
            this.H = 3;
            this.Cp = 0;
            this.Cn = 0;
            this.dataPoints = 0; 
        }
        update(isWin) {
            this.dataPoints++;
            const Xn = isWin ? 1 : 0;
            this.Cp = Math.max(0, this.Cp + (Xn - this.K));
            this.Cn = Math.max(0, this.Cn + ((1 - Xn) - this.K));
            let driftDetected = false;
            if (this.Cp > this.H) { driftDetected = false; this.reset(); }
            if (this.Cn > this.H) { driftDetected = true; this.reset(); }
            return driftDetected;
        }
        reset() { this.Cp = 0; this.Cn = 0; this.dataPoints = 0; }
    }

    // Piyasa Seans Profilleri (Session Profiler)
    class SessionProfiler {
        constructor(bot) { // bot instance'ını alması için constructor'a eklendi
            this.bot = bot;
            this.sessions = {
                'asia': { start: 0, end: 8, name: 'Asya' },
                'europe': { start: 8, end: 13, name: 'Avrupa' },
                'america': { start: 13, end: 22, name: 'Amerika' },
                'overlap': { start: 13, end: 16, name: 'Avr-Ame Çakışması' },
                'transition': { start: 22, end: 24, name: 'Geçiş' }
            };
        }
        getCurrentSession() {
            const now = new Date();
            const utcHour = now.getUTCHours();
            if (utcHour >= this.sessions.overlap.start && utcHour < this.sessions.overlap.end) return this.sessions.overlap.name;
            else if (utcHour >= this.sessions.america.start && utcHour < this.sessions.america.end) return this.sessions.america.name;
            else if (utcHour >= this.sessions.europe.start && utcHour < this.sessions.europe.end) return this.sessions.europe.name;
            else if (utcHour >= this.sessions.asia.start && utcHour < this.sessions.asia.end) return this.sessions.asia.name;
            else return this.sessions.transition.name;
        }
    }

    // Risk Koruyucu (Risk Guardian - Kill Switch)
    class RiskGuardian {
        constructor(bot) {
            this.bot = bot;
            this.killSwitchActivated = false;
        }
        checkKillSwitch() {
            // DÜZELTME: Kill switch aktifse, yeni teklifleri anında temizle
            if (this.killSwitchActivated) {
                if (this.bot.confluenceEngine.proposals.length > 0) {
                    this.bot.confluenceEngine.proposals = [];
                }
                return true; // Aktifse başka kontrol yapma
            }

            if (!this.bot.settings.features.enableRiskGuardian) {
                this.killSwitchActivated = false; return false;
            }
            const totalSignals = this.bot.stats.total;
            const tpSignals = this.bot.stats.tp;
            const winRate = totalSignals > 0 ? (tpSignals / totalSignals) * 100 : 100; // Başlangıçta 100 kabul et
            
            // Güvenlik kontrolü - riskGuardian ayarları yoksa veya killSwitchWinRate tanımlı değilse varsayılan değeri kullan
            const riskSettings = this.bot.settings.riskGuardian || {};
            const drawdownWinRateThreshold = riskSettings.killSwitchWinRate || 35.0; // Default threshold
            
            if (totalSignals >= 10 && winRate < drawdownWinRateThreshold && !this.killSwitchActivated) {
                this.killSwitchActivated = true;
                this.bot.showNotification(`!!! ACİL DURDURMA !!! Kazanma oranı ${winRate.toFixed(1)}% (${drawdownWinRateThreshold}% altı). Sistem durduruldu.`, 'danger');
                this.bot.speak(`Uyarı! Acil durdurma Protokolü aktif edildi. Kazanma oranı eşiğin altında. Sistemi acilen kontrol edin.`);
                this.bot.stop();
                return true;
            }
            return false;
        }
    }

    /* =========================
       STRATEJİLER (YENİ VE MEVCUT)
       ========================= */
    class Strategy {
        constructor(bot, name) { 
            this.bot = bot; this.name = name; this.displayName = this._getDisplayName(name); 
            this.lastProposalTime = {};
            this.DEFAULT_PROPOSAL_COOLDOWN_MS = 10000;
            this._isLive = false;
        }
        setIsLive(status) { this._isLive = status; }
        propose(symbol, direction, reason, score) {
            try {
                if (!this.bot.strategyStats[this.name] || !this.bot.strategyStats[this.name].overall) {
                    const baseStat = { alpha: 3, beta: 2, proposals: 0, contrib: 0, wins: 0, losses: 0, shadowWins: 0, shadowLosses: 0, shadowProposals: 0, lastUpdate: Date.now() };
                    this.bot.strategyStats[this.name] = {
                        overall: { ...baseStat },
                        trend: { ...baseStat },
                        range: { ...baseStat },
                        transition: { ...baseStat }
                    };
                }
                const stratStats = this.bot.strategyStats[this.name];

                stratStats.overall.proposals = (stratStats.overall.proposals || 0) + 1;
                stratStats.overall.lastUpdate = Date.now();
                this.bot.saveStrategyStats();

                if (!this._isLive) {
                    this.bot.recordShadowProposal(this.name, direction, reason, score);
                    return;
                }
                if (this.bot.settings.features.enableRiskGuardian && this.bot.riskGuardian.killSwitchActivated) return;

                const now = Date.now();
                const key = `${symbol}-${direction}`;
                const cooldown = (this.DEFAULT_PROPOSAL_COOLDOWN_MS ?? 10000);
                if (now - (this.lastProposalTime[key] || 0) < cooldown) return;
                this.bot.confluenceEngine.propose(this.name, direction, reason, score);
                this.lastProposalTime[key] = now;
            } catch (error) {
                console.error(`[${this.name}] Propose Error:`, error);
            }
        }

        _getDisplayName(name) { return name.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()); }
        analyzeOrderBook(orderBook) {}
        processTrade(trade) {}
        periodicAnalyze() {}
    }

    class WallBounceStrategy extends Strategy {
        constructor(bot) { super(bot, 'wallBounce'); this.DISTANCE_THRESHOLD_PERCENT = 0.05 / 100; }
        analyzeOrderBook(orderBook) {
            const currentPrice = this.bot.marketData.price; if (!currentPrice) return;
            const btcPrice = this.bot.marketData.btcPrice || 70000;
            const wallQuantityThreshold = (this.bot.settings.params.wallBtc * btcPrice) / currentPrice;
            for (const [price, qty] of orderBook.asks) { 
                if (qty > wallQuantityThreshold) { 
                    const distance = (price - currentPrice) / currentPrice; 
                    if (distance > 0 && distance < this.DISTANCE_THRESHOLD_PERCENT) { 
                        this.propose(this.bot.currentSymbol, 'sell', `Satış Duvarı ${price.toFixed(this.bot.getDecimalPlaces(price))}`, 3); return; 
                    } 
                } 
            }
            for (const [price, qty] of orderBook.bids) { 
                if (qty > wallQuantityThreshold) { 
                    const distance = (currentPrice - price) / currentPrice; 
                    if (distance > 0 && distance < this.DISTANCE_THRESHOLD_PERCENT) { 
                        this.propose(this.bot.currentSymbol, 'buy', `Alış Duvarı ${price.toFixed(this.bot.getDecimalPlaces(price))}`, 3); return; 
                    } 
                } 
            }
        }
    }
    class VelocityScalpingStrategy extends Strategy {
        constructor(bot) { super(bot, 'velocityScalping'); this.pricePoints = []; this.VELOCITY_WINDOW_MS = 2000; this.MIN_POINTS = 20; this.VELOCITY_THRESHOLD_PERCENT = 0.10 / 100; }
        processTrade(trade) {
            const now = Date.now(); 
            this.pricePoints.push({ time: now, price: trade.price }); 
            this.pricePoints = this.pricePoints.filter(p => now - p.time < this.VELOCITY_WINDOW_MS); 
            if (this.pricePoints.length < this.MIN_POINTS) return;
            const firstPoint = this.pricePoints[0]; const lastPoint = this.pricePoints[this.pricePoints.length - 1]; 
            const priceChange = (lastPoint.price - firstPoint.price) / firstPoint.price;
            if (priceChange > this.VELOCITY_THRESHOLD_PERCENT) { 
                this.propose(this.bot.currentSymbol, 'buy', `Fiyat Hızı: +${(priceChange * 100).toFixed(2)}%`, 4); this.pricePoints = []; 
            } else if (priceChange < -this.VELOCITY_THRESHOLD_PERCENT) { 
                this.propose(this.bot.currentSymbol, 'sell', `Fiyat Hızı: ${(priceChange * 100).toFixed(2)}%`, 4); this.pricePoints = []; 
            }
        }
    }
    class RsiDivergenceStrategy extends Strategy {
        constructor(bot) { super(bot, 'rsiDivergence'); }
        periodicAnalyze() {
            const candles = this.bot.candles; const rsiValues = this.bot.indicators.rsi; const lookback = this.bot.settings.params.rsiPeriod;
            if (!rsiValues || rsiValues.length < lookback || !candles || candles.length < lookback) return;
            const recentRsi = rsiValues.slice(-lookback);
            const lastCandle = candles[candles.length - 1]; 
            const prevCandle = candles[candles.length - lookback]; 
            const lastRsi = recentRsi[recentRsi.length - 1]; 
            const prevRsi = recentRsi[0];
            if (!lastCandle || !prevCandle || !isFinite(lastRsi) || !isFinite(prevRsi)) return;
            if (lastCandle.high > prevCandle.high && lastRsi < prevRsi) { 
                this.propose(this.bot.currentSymbol, 'sell', 'RSI Ayı Uyuşmazlığı', 5); 
            }
            if (lastCandle.low < prevCandle.low && lastRsi > prevRsi) { 
                this.propose(this.bot.currentSymbol, 'buy', 'RSI Boğa Uyuşmazlığı', 5); 
            }
        }
    }
    class OrderFlowMomentumStrategy extends Strategy {
        constructor(bot) { super(bot, 'orderFlowMomentum'); this.trades = []; this.WINDOW_MS = 5000; }
        processTrade(trade) {
            const now = Date.now(); 
            this.trades.push(trade); 
            this.trades = this.trades.filter(t => now - t.timestamp < this.WINDOW_MS); 
            if (this.trades.length < 50) return;
            const buys = this.trades.filter(t => !t.isBuyerMaker).reduce((sum, t) => sum + t.quantity, 0); 
            const sells = this.trades.filter(t => t.isBuyerMaker).reduce((sum, t) => sum + t.quantity, 0);
            const total = buys + sells; if (total === 0) return; 
            if (buys / total > 0.7) { this.propose(this.bot.currentSymbol, 'buy', `Alıcı Akışı: %${(buys / total * 100).toFixed(0)}`, 4); this.trades = []; }
            else if (sells / total > 0.7) { this.propose(this.bot.currentSymbol, 'sell', `Satıcı Akışı: %${(sells / total * 100).toFixed(0)}`, 4); this.trades = []; }
        }
    }
    class LiquidityGapsStrategy extends Strategy {
        constructor(bot) { super(bot, 'liquidityGaps'); this.GAP_THRESHOLD_PERCENT = 0.1 / 100; }
        analyzeOrderBook(orderBook) {
            if (!orderBook.asks || orderBook.asks.length === 0 || !orderBook.bids || orderBook.bids.length === 0) return;
            for (let i = 0; i < orderBook.asks.length - 1; i++) { 
                const gap = orderBook.asks[i + 1][0] - orderBook.asks[i][0]; 
                if ((gap / orderBook.asks[i][0]) > this.GAP_THRESHOLD_PERCENT) { 
                    this.propose(this.bot.currentSymbol, 'buy', `Likidite Boşluğu ${orderBook.asks[i][0].toFixed(this.bot.getDecimalPlaces(orderBook.asks[i][0]))}`, 3); return; 
                } 
            }
            for (let i = 0; i < orderBook.bids.length - 1; i++) { 
                const gap = orderBook.bids[i][0] - orderBook.bids[i + 1][0]; 
                if ((gap / orderBook.bids[i][0]) > this.GAP_THRESHOLD_PERCENT) { 
                    this.propose(this.bot.currentSymbol, 'sell', `Likidite Boşluğu ${orderBook.bids[i][0].toFixed(this.bot.getDecimalPlaces(orderBook.bids[i][0]))}`, 3); return; 
                } 
            }
        }
    }
    class BreakoutPatternStrategy extends Strategy {
        constructor(bot) { super(bot, 'breakoutPattern'); this.LOOKBACK = 30; this.VOL_SPIKE = 1.4; this.BREAK_PCT = 0.03/100; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.LOOKBACK + 1) return;
            const recent = c.slice(-this.LOOKBACK-1);
            const highs = recent.map(x=>x.high), lows = recent.map(x=>x.low), vols = recent.map(x=>x.volume);
            const last = recent[recent.length-1]; 
            const maxH = Math.max(...highs.slice(0, -1)); const minL = Math.min(...lows.slice(0, -1));
            const volSma = vols.reduce((a,b)=>a+b,0) / (vols.length-1);
            if (last.close > maxH * (1 + this.BREAK_PCT) && last.volume > volSma * this.VOL_SPIKE) {
                this.propose(this.bot.currentSymbol, 'buy', 'Aralık Üstü Hacimli Kırılım', 4);
            } else if (last.close < minL * (1 - this.BREAK_PCT) && last.volume > volSma * this.VOL_SPIKE) {
                this.propose(this.bot.currentSymbol, 'sell', 'Aralık Altı Hacimli Kırılım', 4);
            }
        }
    }
    class SupportResistanceStrategy extends Strategy {
        constructor(bot) { super(bot, 'supportResistance'); this.LOOKBACK = 60; this.THRESH = 0.15/100; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.LOOKBACK) return;
            const slice = c.slice(-this.LOOKBACK);
            const last = slice[slice.length-1];
            const maxH = Math.max(...slice.map(x=>x.high)); const minL = Math.min(...slice.map(x=>x.low));
            const distTop = (maxH - last.close)/last.close; const distBot = (last.close - minL)/last.close;
            if (distTop >= 0 && distTop < this.THRESH && last.close < last.open) {
                this.propose(this.bot.currentSymbol, 'sell', 'Direnç Bölgesi Reddi', 3);
            }
            if (distBot >= 0 && distBot < this.THRESH && last.close > last.open) {
                this.propose(this.bot.currentSymbol, 'buy', 'Destek Bölgesi Tepkisi', 3);
            }
        }
    }
    class FibonacciRetracementStrategy extends Strategy {
        constructor(bot) { super(bot, 'fibonacciRetracement'); this.LOOKBACK = 120; this.TOL = 0.2/100; this.levels = [0.382, 0.5, 0.618]; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.LOOKBACK) return;
            const slice = c.slice(-this.LOOKBACK);
            let high = -Infinity, low = Infinity, hT=0, lT=0;
            slice.forEach(k => { if(k.high > high){high=k.high; hT=k.time;} if(k.low < low){low=k.low; lT=k.time;} });
            if (!isFinite(high) || !isFinite(low) || high===low) return;
            const last = slice[slice.length-1];
            if (hT > lT) {
                const retr = (high - last.close) / (high - low);
                for (const L of this.levels) {
                    if (Math.abs(retr - L) < this.TOL) { this.propose(this.bot.currentSymbol, 'buy', `Fibo ${Math.round(L*100)}% Bölgesi`, 3); break; }
                }
            } else {
                const retr = (last.close - low) / (high - low);
                for (const L of this.levels) {
                    if (Math.abs(retr - L) < this.TOL) { this.propose(this.bot.currentSymbol, 'sell', `Fibo ${Math.round(L*100)}% Bölgesi`, 3); break; }
                }
            }
        }
    }
    class VolumeProfileStrategy extends Strategy {
        constructor(bot) { super(bot, 'volumeProfile'); this.PERIOD = 20; this.SPIKE = 2.0; this.CLOSE_POS = 0.7; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.PERIOD + 1) return;
            const last = c[c.length-1];
            const vols = c.slice(-this.PERIOD-1, -1).map(x=>x.volume);
            const volSma = vols.reduce((a,b)=>a+b,0)/vols.length;
            if (last.volume > volSma * this.SPIKE && (last.close - last.low) / Math.max(1e-8,(last.high - last.low)) > this.CLOSE_POS) {
                this.propose(this.bot.currentSymbol, 'buy', 'Hacim Spike - Üst Kapanış', 3);
            } else if (last.volume > volSma * this.SPIKE && (last.high - last.close) / Math.max(1e-8,(last.high - last.low)) > this.CLOSE_POS) {
                this.propose(this.bot.currentSymbol, 'sell', 'Hacim Spike - Alt Kapanış', 3);
            }
        }
    }
    class SmartMoneyConceptsStrategy extends Strategy {
        constructor(bot) { super(bot, 'smartMoneyConcepts'); this.GAP_MIN_PCT = 0.05/100; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < 3) return;
            const a = c[c.length-3], b = c[c.length-2], d = c[c.length-1];
            if ((d.low - b.high > 0) && (b.low - a.high > 0) && ((d.low - a.high)/Math.max(1e-8, d.low) > this.GAP_MIN_PCT)) {
                 this.propose(this.bot.currentSymbol, 'buy', 'Bullish FVG (IMB)', 4);
            }
            if ((a.low - b.high > 0) && (b.low - d.high > 0) && ((a.low - d.high)/Math.max(1e-8, d.high) > this.GAP_MIN_PCT)) {
                this.propose(this.bot.currentSymbol, 'sell', 'Bearish FVG (IMB)', 4);
            }
        }
    }
    class DivergenceDetectionStrategy extends Strategy {
        constructor(bot) { super(bot, 'divergenceDetection'); this.LOOKBACK = 40; this.SWING_PERIOD = 3; }
        periodicAnalyze() {
            const c = this.bot.candles; const rsi = this.bot.indicators.rsi; 
            if (!rsi || c.length < this.LOOKBACK || rsi.length < this.LOOKBACK) return;
            const slice = c.slice(-this.LOOKBACK), r = rsi.slice(-this.LOOKBACK);
            const pivLows = []; const pivHighs = [];
            for (let i = this.SWING_PERIOD; i < slice.length - this.SWING_PERIOD; i++) {
                const isPivotLow = slice[i].low < Math.min(...slice.slice(i-this.SWING_PERIOD, i).map(x=>x.low)) && 
                                   slice[i].low < Math.min(...slice.slice(i+1, i+1+this.SWING_PERIOD).map(x=>x.low));
                const isPivotHigh = slice[i].high > Math.max(...slice.slice(i-this.SWING_PERIOD, i).map(x=>x.high)) && 
                                    slice[i].high > Math.max(...slice.slice(i+1, i+1+this.SWING_PERIOD).map(x=>x.high));
                if (isPivotLow) pivLows.push(i);
                if (isPivotHigh) pivHighs.push(i);
            }
            if (pivLows.length >= 2) {
                const i1 = pivLows[pivLows.length-2], i2 = pivLows[pivLows.length-1];
                if (slice[i2].low < slice[i1].low && r[i2] > r[i1]) {
                    this.propose(this.bot.currentSymbol, 'buy', 'Boğa Sapması (RSI)', 5);
                }
            }
            if (pivHighs.length >= 2) {
                const i1 = pivHighs[pivHighs.length-2], i2 = pivHighs[pivHighs.length-1];
                if (slice[i2].high > slice[i1].high && r[i2] < r[i1]) {
                    this.propose(this.bot.currentSymbol, 'sell', 'Ayı Sapması (RSI)', 5);
                }
            }
        }
    }
    class MarketStructureStrategy extends Strategy {
        constructor(bot) { super(bot, 'marketStructure'); this.SWING = 3; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < 2*this.SWING+5) return;
            const pivotHighs = [], pivotLows = [];
            for (let i = this.SWING; i < c.length - this.SWING; i++) {
                if (c[i].high > Math.max(...c.slice(i-this.SWING, i).map(x=>x.high)) && c[i].high > Math.max(...c.slice(i+1, i+1+this.SWING).map(x=>x.high))) pivotHighs.push(i);
                if (c[i].low < Math.min(...c.slice(i-this.SWING, i).map(x=>x.low)) && c[i].low < Math.min(...c.slice(i+1, i+1+this.SWING).map(x=>x.low))) pivotLows.push(i);
            }
            const last = c[c.length-1];
            if (pivotHighs.length) {
                const ph = c[pivotHighs[pivotHighs.length-1]].high;
                if (last.close > ph) this.propose(this.bot.currentSymbol, 'buy', 'Yapı Kırılımı (BOS Up)', 4);
            }
            if (pivotLows.length) {
                const pl = c[pivotLows[pivotLows.length-1]].low;
                if (last.close < pl) this.propose(this.bot.currentSymbol, 'sell', 'Yapı Kırılımı (BOS Down)', 4);
            }
        }
    }
    class InstitutionalOrderFlowStrategy extends Strategy {
        constructor(bot) { super(bot, 'institutionalOrderFlow'); this.TOP_N = 5; this.IMB_THRESHOLD = 2.0; }
        analyzeOrderBook(orderBook) {
            if (!orderBook.bids || orderBook.bids.length === 0 || !orderBook.asks || orderBook.asks.length === 0) return;
            const topB = orderBook.bids.slice(0, this.TOP_N).reduce((s,[,q])=>s+q,0);
            const topA = orderBook.asks.slice(0, this.TOP_N).reduce((s,[,q])=>s+q,0);
            if (topB / Math.max(1e-8, topA) > this.IMB_THRESHOLD) {
                this.propose(this.bot.currentSymbol, 'buy', 'Orderbook İmbalansı (Bid Ağırlık)', 3);
            } else if (topA / Math.max(1e-8, topB) > this.IMB_THRESHOLD) {
                this.propose(this.bot.currentSymbol, 'sell', 'Orderbook İmbalansı (Ask Ağırlık)', 3);
            }
        }
    }
    class MicroSpreadArbitrageStrategy extends Strategy {
        constructor(bot) { super(bot, 'microSpreadArbitrage'); this.SPREAD_PCT = 0.08/100; }
        analyzeOrderBook(orderBook) {
            if (!orderBook.bids || orderBook.bids.length === 0 || !orderBook.asks || orderBook.asks.length === 0) return;
            const bestBid = orderBook.bids[0][0], bestAsk = orderBook.asks[0][0];
            const mid = (bestAsk + bestBid)/2;
            const spreadPct = (bestAsk - bestBid) / mid;
            if (spreadPct > this.SPREAD_PCT) {
                const current = this.bot.marketData.price || mid;
                if (current < mid) this.propose(this.bot.currentSymbol, 'buy', 'Geniş Spread - Mean Reversion', 2);
                else this.propose(this.bot.currentSymbol, 'sell', 'Geniş Spread - Mean Reversion', 2);
            }
        }
    }
    class VWAPReversionStrategy extends Strategy {
        constructor(bot) { super(bot, 'vwapReversion'); this.MULT = 1.0; }
        periodicAnalyze() {
            const price = this.bot.marketData.price, vwap = this.bot.indicators.vwap, atr = this.bot.indicators.atr;
            if (!price || !vwap || !atr) return;
            const dev = atr / price; 
            const diffPct = (price - vwap) / vwap;
            if (diffPct > this.MULT * dev) this.propose(this.bot.currentSymbol, 'sell', 'VWAP Üstü Aşırı Sapma', 3);
            if (diffPct < -this.MULT * dev) { this.propose(this.bot.currentSymbol, 'buy', 'VWAP Altı Aşırı Sapma', 3); }
        }
    }
    class SuperTrendStrategy extends Strategy {
        constructor(bot) { super(bot, 'superTrend'); this.MULT = 3.0; this.PERIOD = 14; }
        periodicAnalyze() {
            const c = this.bot.candles; const atr = this.bot.indicators.atr;
            if (!atr || c.length < 2) return;
            const last = c[c.length-1];
            const m = (last.high + last.low) / 2;
            const upper = m + this.MULT * atr, lower = m - this.MULT * atr;
            if (last.close > upper) this.propose(this.bot.currentSymbol, 'buy', 'ATR Kanal Üstü Kırılım (SuperTrend)', 4);
            else if (last.close < lower) { this.propose(this.bot.currentSymbol, 'sell', 'ATR Kanal Altı Kırılım (SuperTrend)', 4); }
        }
    }

    // YENİ STRATEJİLER
    class VolatilityBreakoutStrategy extends Strategy {
        constructor(bot) { 
            super(bot, 'volatilityBreakout'); 
            this.SQUEEZE_LOOKBACK = 20;
            this.SQUEEZE_MULT = 1.0; // ATR'ye göre sıkışma tespiti için çarpan
            this.BREAKOUT_VOL_MULT = 1.5; // Kırılım anındaki hacim artışı
        }
        periodicAnalyze() {
            const { bbands, atr, volSma20 } = this.bot.indicators;
            const c = this.bot.candles;
            if (!bbands || !atr || !volSma20 || c.length < this.SQUEEZE_LOOKBACK || !bbands.upper || bbands.upper.length === 0) return;

            const lastBandUpper = bbands.upper[bbands.upper.length-1];
            const lastBandMiddle = bbands.middle[bbands.middle.length-1];
            const lastBandLower = bbands.lower[bbands.lower.length-1];

            if (!lastBandUpper || !lastBandMiddle || !lastBandLower || lastBandMiddle.value === 0) return;

            const bandwidth = (lastBandUpper.value - lastBandLower.value) / lastBandMiddle.value;
            
            const isSqueeze = bandwidth < (atr * this.SQUEEZE_MULT / (c[c.length-1]?.close || 1));
            if(!isSqueeze) return;

            const lastCandle = c[c.length-1];
            if (!lastCandle) return;

            if (lastCandle.close > lastBandUpper.value && lastCandle.volume > volSma20 * this.BREAKOUT_VOL_MULT) {
                this.propose(this.bot.currentSymbol, 'buy', 'Volatilite Sıkışma Kırılımı (Yukarı)', 5);
            } else if (lastCandle.close < lastBandLower.value && lastCandle.volume > volSma20 * this.BREAKOUT_VOL_MULT) {
                this.propose(this.bot.currentSymbol, 'sell', 'Volatilite Sıkışma Kırılımı (Aşağı)', 5);
            }
        }
    }

    class CandleCharacterStrategy extends Strategy {
        constructor(bot) {
            super(bot, 'candleCharacter');
            this.MIN_BODY_TO_WICK_RATIO = 0.6; // Gövde / Toplam Mum Boyu oranı
            this.ANALYSIS_WINDOW_PERCENT = 0.2; // Mumun son %20'sinde çalışır
        }
        periodicAnalyze() {
            if (this.bot.candles.length < 1) return;
            const candle = this.bot.candles[this.bot.candles.length-1];
            const timeframeMs = this.bot._timeframeToMs(this.bot.currentTimeframe);
            const candleAge = Date.now() - candle.time;
            
            // Sadece mumun sonlarına doğru çalış
            if (candleAge < timeframeMs * (1 - this.ANALYSIS_WINDOW_PERCENT)) return;

            const { open, high, low, close } = candle;
            const bodySize = Math.abs(close - open);
            const totalSize = high - low;
            if (totalSize === 0) return; // Doji veya veri hatası

            const bodyRatio = bodySize / totalSize;
            if(bodyRatio < this.MIN_BODY_TO_WICK_RATIO) return; // Güçsüz gövde, kararsızlık

            if (close > open) { // Yeşil mum
                const upperWick = high - close;
                // Eğer üst fitil toplam mum boyutunun %20'sinden azsa, gövde güçlüdür
                if (upperWick / totalSize < 0.2) { 
                    this.propose(this.bot.currentSymbol, 'buy', 'Güçlü Alıcı Mumu', 4);
                }
            } else { // Kırmızı mum
                const lowerWick = close - low;
                // Eğer alt fitil toplam mum boyutunu %20'sinden azsa, gövde güçlüdür
                if(lowerWick / totalSize < 0.2) { 
                    this.propose(this.bot.currentSymbol, 'sell', 'Güçlü Satıcı Mumu', 4);
                }
            }
        }
    }

     class FundingRateReversalStrategy extends Strategy {
        constructor(bot) {
            super(bot, 'fundingRateReversal');
            this.fundingRate = 0;
            this.openInterest = 0;
            this.lastFetchTime = 0;
            this.FETCH_INTERVAL_MS = 60 * 1000; // 1 dakikada bir veri çek
            this.EXTREME_FUNDING_THRESHOLD = 0.001; // %0.1 fonlama oranı eşiği
        }

        async periodicAnalyze() {
            const now = Date.now();
            if (now - this.lastFetchTime > this.FETCH_INTERVAL_MS) {
                this.lastFetchTime = now;
                try {
                    const response = await fetch(`https://fapi.binance.com/fapi/v1/premiumIndex?symbol=${this.bot.currentSymbol}`);
                    if (!response.ok) {
                        console.error(`Funding Rate/Open Interest API Hatası: ${response.statusText}`);
                        return;
                    }
                    const data = await response.json();
                    this.fundingRate = parseFloat(data.lastFundingRate);
                    this.openInterest = parseFloat(data.openInterest) || 0; 

                } catch (e) { 
                    console.error("Fonlama Oranı/Açık Faiz verisi çekilemedi:", e); 
                    return;
                }
            }

            const currentPrice = this.bot.marketData.price;
            if (!currentPrice || !isFinite(this.fundingRate) || this.fundingRate === 0 || this.bot.candles.length < 2) return;

            if (this.fundingRate > this.EXTREME_FUNDING_THRESHOLD) {
                if (currentPrice < this.bot.candles[this.bot.candles.length - 2]?.close) { 
                     this.propose(this.bot.currentSymbol, 'sell', `Aşırı Pozitif Fonlama & Fiyat Düşüşü (${(this.fundingRate*100).toFixed(3)}%)`, 4);
                }
            } else if (this.fundingRate < -this.EXTREME_FUNDING_THRESHOLD) {
                 if (currentPrice > this.bot.candles[this.bot.candles.length - 2]?.close) { 
                    this.propose(this.bot.currentSymbol, 'buy', `Aşırı Negatif Fonlama & Fiyat Yükselişi (${(this.fundingRate*100).toFixed(3)}%)`, 4);
                }
            }
        }
    }


    /* =========================
       UYUM MOTORU V2 (CONFLUENCE ENGINE V2)
       ========================= */
    class AdvancedConfluenceEngine {
        constructor(bot) { 
            this.bot = bot; 
            this.proposals = []; 
            this.lastSignalTime = 0; 
            this.lastSignalTimeByDirection = { buy: 0, sell: 0 };
            this.lastDirection = null;
            this.buyScore = 0;
            this.sellScore = 0;
        }
        propose(strategy, direction, reason, score) {
            const now = Date.now();
            this.proposals = this.proposals.filter(p => !(p.strategy === strategy && p.direction === direction));
            this.proposals.push({ strategy, direction, reason, score, timestamp: now });
            this.checkConfluence();
        }
        _computeDirectional(direction) {
            const now = Date.now();
            const decaySec = this.bot.settings.optimization.timeDecaySec || 3;
            const groupSums = { trending: 0, meanReversion: 0, neutral: 0 };
            const used = [];
            const groupsUsed = new Set();
            const activeProposals = this.proposals.filter(p => {
                const strategyInstance = this.bot.strategies[p.strategy];
                return strategyInstance && strategyInstance._isLive && p.direction === direction;
            });

            for (const p of activeProposals) {
                const w = this.bot.getStrategyWeight(p.strategy);
                const ageSec = (now - p.timestamp)/1000;
                const decay = Math.exp(-ageSec / decaySec);
                // DÜZELTME: NaN kontrolü eklendi
                const eff = isNaN(p.score * w * decay) ? 0 : p.score * w * decay;
                const grp = this.bot.getStrategyGroup(p.strategy);
                groupsUsed.add(grp);
                groupSums[grp] = (groupSums[grp] || 0) + eff;
                used.push({ strategy: p.strategy, baseScore: p.score, weight: w, decay, effScore: eff });
            }
            const score = Object.values(groupSums).reduce((sum, val) => sum + val, 0); 
            return { score, contributors: used, groupSums, groupsCount: groupsUsed.size, contributorsCount: used.length };
        }
       
        checkConfluence() {
            const now = Date.now();
            const settings = this.bot.settings;
            const cd = settings.cooldowns || {};
            const proposalTimeout = cd.proposalTimeoutMs ?? 3000;
            const signalCooldown = cd.signalMs ?? 15000;
            const sameDirCooldown = cd.sameDirectionMs ?? 30000;
            const oppCooldown = cd.oppositeDirectionMs ?? 20000;
            const reverseHys = cd.reverseHysteresisPoints ?? 2;
            const dirMargin = settings.optimization.dirMargin ?? 0.5;
            const minThreshold = this.bot.getEffectiveThreshold();

            if (now - this.lastSignalTime < signalCooldown) return;
            this.proposals = this.proposals.filter(p => now - p.timestamp < proposalTimeout);

            const buy = this._computeDirectional('buy');
            const sell = this._computeDirectional('sell');

            let buyScoreAdj = buy.score;
            let sellScoreAdj = sell.score;

            if (settings.features.enableMtfConfirm) {
                const mtfTrend = this.bot.multiTimeframeManager.getTrend(settings.features.mtfTimeframe);
                if (mtfTrend === 'down') buyScoreAdj *= 0.6;
                if (mtfTrend === 'up') sellScoreAdj *= 0.6;
            }

            const buyPenalty = settings.optimization.gating.enabled ? this.bot.marketGatingPenalty('buy') : 0;
            const sellPenalty = settings.optimization.gating.enabled ? this.bot.marketGatingPenalty('sell') : 0;
            buyScoreAdj -= buyPenalty;
            sellScoreAdj -= sellPenalty;

            const q = settings.optimization.signalQuality || { minContributors: 1, minGroups: 1 };
            const buyOk = (buy.contributorsCount >= q.minContributors) && (buy.groupsCount >= q.minGroups);
            const sellOk = (sell.contributorsCount >= q.minContributors) && (sell.groupsCount >= q.minGroups);

            buyScoreAdj = buyOk ? buyScoreAdj : -Infinity;
            sellScoreAdj = sellOk ? sellScoreAdj : -Infinity;

            this.buyScore = buyScoreAdj;
            this.sellScore = sellScoreAdj;

            if (buyScoreAdj >= minThreshold && (buyScoreAdj > sellScoreAdj + dirMargin)) {
                if (now - this.lastSignalTimeByDirection.buy < sameDirCooldown) return;
                if (this.lastDirection === 'sell' && (now - this.lastSignalTime) < oppCooldown) {
                    if (buyScoreAdj < (minThreshold + reverseHys)) return;
                }
                this.generateFinalSignal('buy', buy.contributors, buyScoreAdj);
            } else if (sellScoreAdj >= minThreshold && (sellScoreAdj > buyScoreAdj + dirMargin)) {
                if (now - this.lastSignalTimeByDirection.sell < sameDirCooldown) return;
                if (this.lastDirection === 'buy' && (now - this.lastSignalTime) < oppCooldown) {
                    if (sellScoreAdj < (minThreshold + reverseHys)) return;
                }
                this.generateFinalSignal('sell', sell.contributors, sellScoreAdj);
            }
        }

        generateFinalSignal(direction, contributors, finalScore) {
            const contributingStrats = contributors.map(c => this.bot.strategies[c.strategy]?.displayName || c.strategy).join(', ');
            const status = this.bot.settings.features.enableCandleConfirm ? 'pending' : 'active';
            
            const signal = { 
                id: `sig_${Date.now()}`, timestamp: Date.now(), symbol: this.bot.currentSymbol, 
                direction, price: this.bot.marketData.price, score: finalScore, 
                reason: contributingStrats, contributors, status: status, note: '',
                mfeR: 0, beDone: false, trailingStage: 0, entrySlDistance: 0, entryTpDistance: 0,
                recommendedSize: this.bot.getRecommendedPositionSize(finalScore)
            };

            this.bot.calculateDynamicTpSl(signal);

            if (status === 'pending') {
                this.bot.addPendingSignal(signal);
            } else {
                this.bot.activateSignal(signal);
            }
            
            this.proposals = [];
            const now = Date.now();
            this.lastSignalTime = now;
            this.lastSignalTimeByDirection[direction] = now;
            this.lastDirection = direction;
        }
    }

    /* =========================
       ANA UYGULAMA
       ========================= */
    class UltimateTradingCommandCenter {
        constructor() {
            this.allStrategiesMap = {
                'wallBounce': WallBounceStrategy, 'velocityScalping': VelocityScalpingStrategy, 'rsiDivergence': RsiDivergenceStrategy, 
                'orderFlowMomentum': OrderFlowMomentumStrategy, 'liquidityGaps': LiquidityGapsStrategy, 'fibonacciRetracement': FibonacciRetracementStrategy, 
                'volumeProfile': VolumeProfileStrategy, 'smartMoneyConcepts': SmartMoneyConceptsStrategy, 'divergenceDetection': DivergenceDetectionStrategy, 
                'breakoutPattern': BreakoutPatternStrategy, 'supportResistance': SupportResistanceStrategy, 'marketStructure': MarketStructureStrategy, 
                'institutionalOrderFlow': InstitutionalOrderFlowStrategy, 'microSpreadArbitrage': MicroSpreadArbitrageStrategy,
                'vwapReversion': VWAPReversionStrategy, 'superTrend': SuperTrendStrategy,
                'volatilityBreakout': VolatilityBreakoutStrategy,
                'candleCharacter': CandleCharacterStrategy,
                'fundingRateReversal': FundingRateReversalStrategy
            };
            this.allStrategyKeys = Object.keys(this.allStrategiesMap); 

            this.isRunning = false; 
            this.sockets = {}; 
            
            this.currentSymbol = this.loadData('utc_current_symbol') || 'BTCUSDT'; 
            this.currentTimeframe = this.loadData('utc_current_timeframe') || '15m';
            this.headerCollapsed = this.loadData('utc_header_collapsed') !== null ? (this.loadData('utc_header_collapsed') === 'true') : true; 
            this.currentMainView = this.loadData('utc_current_view') || 'chart';

            this.marketData = { price: 0, change24h: 0, volume24h: 0, symbol: this.currentSymbol, btcPrice: 70000 }; 
            this.orderBook = { bids: [], asks: [], lastUpdateId: null }; 

            this.aggTrades = []; 
            this.candles = [];
            this.indicators = { rsi: [], atr: null, sma20: null, sma50: null, volSma20: null, vwap: null, adx: null, bbands: null }; 
            this.signals = this.loadData('utc_signals') || [];
            this.pendingSignals = [];
            this.stats = this.loadData('utc_stats') || { total: 0, tp: 0, sl: 0 };

            this.strategyStats = this.loadData('utc_strategy_stats') || this.initDefaultStrategyStats();
            this.marketRegime = 'unknown';
            this.riskState = 'neutral'; 
            this.sessionState = 'unknown';

            this.strategyGroups = {
                trending: ['breakoutPattern','orderFlowMomentum','marketStructure','volumeProfile','smartMoneyConcepts','superTrend', 'volatilityBreakout'],
                meanReversion: ['vwapReversion','wallBounce','liquidityGaps','fibonacciRetracement','supportResistance','microSpreadArbitrage','divergenceDetection','rsiDivergence','institutionalOrderFlow', 'fundingRateReversal'],
                neutral: ['candleCharacter']
            };
            
            this.settings = this.loadSettings();
            this.strategies = {}; 
            
            this.combatModeActive = false;
            this.manipulationDetector = null;
            this.reconnectAttempts = 0;
            this.reconnectDelay = 3000;

            this.shadowProposals = [];

            this.chartManager = new ChartManager('live-chart');
            this.heatmapManager = new HeatmapManager('orderbook-heatmap');
            this.confluenceEngine = new ConfluenceEngine(this);
            // MultiTimeframeManager oluştur - hangisi mevcutsa onu kullan
            if (typeof MultiTimeframeManager === 'function') {
                this.multiTimeframeManager = new MultiTimeframeManager(this); 
            } else if (typeof LegacyMultiTimeframeManager === 'function') {
                this.multiTimeframeManager = new LegacyMultiTimeframeManager(this);
            }
            this.spoofDetector = new SpoofDetector(this);               
            this.cusumDetector = new CUSUMDriftDetector();               
            this.sessionProfiler = new SessionProfiler(this);
            this.riskGuardian = new RiskGuardian(this);                   
            this.notificationCenter = new AdvancedNotificationCenter(this);
            
            this.renderInterval = null; 
            this.analysisInterval = null;
            this.cooldownTuneInterval = null;
            this.thresholdTuneInterval = null;
            this.paramTuneInterval = null;
            this.sessionUpdateInterval = null;
            this.countdownInterval = null; 
            this.performanceMonitorInterval = null; // DÜZELTME: Performans izleyici için

            this.lastAutoToggleTs = 0;
            this.runtimeThresholdOffset = 0; 
            this.lastCalculatedCandle = null; // DÜZELTME: İndikatör optimizasyonu için
            this.renderTimeout = null; // DÜZELTME: Render debounce için

            this.synth = window.speechSynthesis || null;
            this.speechQueue = []; // DÜZELTME: Konuşma kuyruğu
            this.isSpeaking = false; // DÜZELTME: Konuşma durumu
            this.voices = [];
            
            // Enerji Yönetim Sistemi
            this.energyManager = null;
            
            // Ritüel Sistemi
            this.ritualManager = null;
            
            // DÜZELTME: Eksik TTS metinleri eklendi
                        this.speechTexts = {
                buy: [
                    "Harika bir fırsat! [Sembol] için alım sinyali geldi. Yeşil ışık yanıyor! Skor [Skor].",
                    "Piyasa nefes aldı, [Sembol] yükselişe geçiyor. Bu trene binmek ister misin? Skor [Skor].",
                    "Komutanım, hesaplamalar net: [Sembol] için güçlü bir alım. Devler uyanıyor! Skor [Skor].",
                    "Cüzdanlarınıza dikkat, [Sembol] için bir yükseliş trendi başlangıcı. Fırsat kapınızı çaldı! Skor [Skor].",
                    "Gözünü dört aç! [Sembol] için büyük bir potansiyel görüyorum. Roket kalkışa hazır! Skor [Skor].",
                    "Bugün şanslı günün olabilir! [Sembol] alım için çağırıyor. İç sesine kulak ver! Skor [Skor].",
                    "Duy sesimi Komutanım! [Sembol] için alım sinyali. Hadi, pazarın nabzını tutalım! Skor [Skor].",
                    "Piyasa dans etmeye başladı, [Sembol] yükselişle eşlik ediyor. Katılmak ister misin? Skor [Skor].",
                    "Bana güven, [Sembol] için enerji pozitif. Bu işlemi kaçırmak istemezsin. Skor [Skor].",
                    "Ulan [Sembol] için alım sinyali patladı, hala ne bekliyorsun lanet olası! Kalk ve parayı kap, yoksa pişmanlık seni yer bitirir! Skor [Skor]."
                ],
                sell: [
                    "Piyasa biraz yorulmuş gibi, [Sembol] için satış sinyali geldi. Karları garantiye alalım! Skor [Skor].",
                    "Komutanım, [Sembol] için aşağı yönlü bir hareketlilik bekliyorum. Tetikte ol! Skor [Skor].",
                    "Bazen geri çekilmek de kazanmaktır. [Sembol] için satış vakti. Parçaları topluyoruz! Skor [Skor].",
                    "Bir fırtına yaklaşıyor olabilir, [Sembol] için satış sinyali. Kendini güvende tut! Skor [Skor].",
                    "Akıllıca bir adım! [Sembol] için kazançları koruma zamanı. Hızlı ve isabetli olalım. Skor [Skor].",
                    "Piyasa nazikçe fısıldıyor: [Sembol] için biraz ara ver. Karını koru! Skor [Skor].",
                    "Riskleri minimize etmenin zamanı geldi. [Sembol] için satış önerisi. Gerekirse tekrar gireriz. Skor [Skor].",
                    "Satış sinyali geldi. Umarım boğalar çimlere basmamıştır! [Sembol] için. Skor [Skor].",
                    "Ulan [Sembol] düşüyor, hala mı tutuyorsun lanet olası aptal! Sat da kurtul, yoksa cebin boşalır sinirlenme bana! Skor [Skor].",
                    "Siktir et o umudunu, [Sembol] satış sinyali verdi! Sert ol, çık ve karı kap, motive ol lan yoksa kaybedersin! Skor [Skor]."
                ],
                combatModeActivate: [
                    "Kumandanım, Kırmızı Alarm! Savaş Modu aktive edildi! Piyasanın kalbi şimdi elimizde!",
                    "Sistem uyarısı: Ultra savaş modu devrede! Piyasa savaşı başlıyor! Her bir strateji tam kapasite!",
                    "Savaş Modu Başladı! İleri Komutanım! Tüm güçler hazır, her anı avantaja çevireceğiz!",
                    "Hazırlanın! Savaş Modu aktive edildi. Bu bir zihin oyunu ve biz kazanacağız! Odaklanma ve hız, anahtarımız!",
                    "Ulan savaş modu aktive! Piyasa seni ezmeye çalışıyor ama biz daha sertiz lan, kalk ayağa ve piyasayı sikert! Zafer bizim olacak!"
                ],
                combatModeDeactivate: [
                    "Savaş modu başarıyla sonlandırıldı. Piyasa koşulları normale dönüyor, normal operasyonlara geri dönüyoruz. İyi iş çıkardınız.",
                    "Operasyon sonu. Savaş modu kapatıldı. Şimdi piyasanın sakin sularında yüzme zamanı.",
                    "Savaş modu devre dışı. Riskler azaldı, piyasa sakinleşiyor. Sakin sularda bile fırsatlar vardır, unutmayın.",
                    "Kumandanım, savaş bitti. Kazanılmış bir zaferin ardından dinlenme vakti. Bir sonraki mücadeleye kadar hazırız.",
                    "Ulan savaş modu kapandı, hala mı sinirli duruyorsun lan? Rahatla Komutanım, zaferi kutla yoksa ben sinirlenirim sana da!"
                ],
                signalTP: [
                    "Hedef vuruldu! TP geldi, Komutanım! Bu başarı sizin stratejik dehanızın kanıtı!",
                    "Tebrikler! Kar realizasyonu gerçekleşti. Şimdi kahve içme zamanı, zafer sizin!",
                    "TP alarmı! Kazanç cebinizde, piyasa artık bizim kontrolümüzde. Harika iş!",
                    "Boom! TP hedefi tutturuldu. Strateji kusursuz, Komutanım lider!",
                    "Kar alındı! Zekânız ve disiplininizle piyasanın kalbini fethettiniz!",
                    "Ulan TP vuruldu, para cebinde lan! Sinirliydim piyasaya ama sen ezerdin, motive ol da kutla zaferi Komutanım!"
                ],
                signalSL: [
                    "SL tetiklendi! Savaş kaybedilmiş değil, ders alınmış! Komutanım, hazırlanın ve tekrar saldırın!",
                    "Stop Loss aktif. Kaybedilen bir savaş değil, bir sonraki zaferin başlangıcı!",
                    "SL geldi, ama moral bozulmasın. Bu sadece piyasanın egonuzu test etmesi!",
                    "Kaybı kabul et, ama pes etme. SL tetiklendi, stratejiyi yeniden şekillendiriyoruz!",
                    "SL alarmı! Hedefi kaybettik ama deneyim kazandık, Komutanım!",
                    "Ulan SL tetiklendi, para gitti lan! Sinirlim piyasaya ama sen pes etme, motive ol da tekrar saldır Komutanım!"
                ],
                cusumDriftDetected: [
                    "CUSUM drift tespit edildi! Komutanım, piyasa dalgalanıyor ama biz her zaman hazırız!",
                    "Sinyal değişimi geldi, dikkat! Bu bir fırsat ya da ders, sizin kararınız!",
                    "CUSUM alarmı! Strateji tetikte, piyasa bizi test ediyor ama biz kazanmaya odaklıyız!",
                    "Drift detected! Piyasa kıvılcımları uçuşuyor, Komutanım, kontrol sizde!",
                    "Ulan CUSUM drift patladı, piyasa dalgalanıyor lan! Sinirlim ulan, ama motive ol da hazır ol, fırsat mı ders mi sen karar ver!"
                ],
                autoToggleDeactivate: [
                    "Optimizasyon uyarısı: [Strateji Adı] stratejisi beklenen performansı göstermedi. Geçici olarak pasif edildi.",
                    "[Strateji Adı] stratejisi, performans testinden geçemedi. Geçici olarak emekli edildi. Dikkatli olalım.",
                    "Bir strateji daha devredışı. [Strateji Adı] şu an için dinlenmeye alındı. Daha iyi günler için bekliyoruz.",
                    "Ulan [Strateji Adı] performansı sıçtı, pasif edildi lan! Sinirlim ulan, ama motive ol da bekle, en iyisi bu!"
                ],
                autoToggleActivate: [
                    "Optimizasyon başarıyla tamamlandı: [Strateji Adı] stratejisi tekrar aktif edildi. Yeni veriler çok umut verici!",
                    "Müjde! [Strateji Adı] stratejisi tekrar göreve hazır! Performansı yükselişte. Hadi bakalım, piyasayı sallayalım!",
                    "Hoş geldin geri [Strateji Adı]! Kendini toparlamışsın. Tekrar aktif edildi. Şimdi bize neler göstereceksin merak ediyorum.",
                    "Ulan [Strateji Adı] geri döndü, aktif edildi lan! Sinirlim yokluğunda ama motive ol da sallayalım piyasayı, zafer yakın ulan!"
                ],
                cooldownOptimize: [
                    "Sistem, soğuma sürelerini başarıyla yeniden ayarladı. Piyasanın nabzına göre şimdiden optimize edildik Komutanım.",
                    "Cooldown ayarları güncellendi. Artık sinyaller arasında daha zeki bir denge kuruyoruz. Ben bu işi biliyorum!",
                    "Piyasa ritmini değiştirdi, biz de cooldown sürelerimizi. Tam senkronizasyon için her şey ayarlandı Komutanım.",
                    "Ulan cooldown süreleri ayarlandı lan! Sinirlim piyasanın ritmine ama optimize ettik, motive ol da dans pistinde ezeriz hepsini Komutanım!"
                ],
                systemStart: [
                    "Sistem başlatıldı. Canlı veri akışı başlıyor. Gözlerim ve kulaklarım piyasada Komutanım.",
                    "Başlatma tamamlandı. Piyasa analizine başlıyorum. Bana güvenebilirsin.",
                    "Uyanıyorum... Tüm sensörler aktif. Piyasa maceramız şimdi başlıyor!",
                    "Ulan sistem başladı lan! Sinirlim uykuda ama şimdi canlı veri akıyor, motive ol da piyasayı ezeriz Komutanım!"
                ],
                systemStop: [
                    "Sistem durduruldu. Operasyonlar askıya alındı. Bir mola verelim Komutanım.",
                    "Kapanış prosedürü aktif. Veri akışı durduruldu. Daha sonra görüşmek üzere!",
                    "Enerji tasarrufu modu. Sistem kapanıyor. İhtiyaç duyduğunuzda beni tekrar başlatabilirsiniz.",
                    "Ulan sistem durduruldu lan! Sinirlim piyasaya ama şimdi mola ver, motive ol da dinlen Komutanım yoksa ezerim seni yorgunlukla!"
                ],
                symbolChange: [
                    "Sembol [Sembol] olarak değiştirildi. Yeni bir maceraya hazırız.",
                    "Hedef [Sembol] olarak güncellendi. Adaptasyon tamamlandı. Şimdi bu sembole odaklanıyoruz.",
                    "Sembol değişimi: [Sembol]. Her zaman yeni bir meydan okumaya açığım.",
                    "Ulan sembol [Sembol] oldu lan! Sinirlim eskisine ama şimdi motive ol da yeni maceraya atıl, ezeriz piyasayı Komutanım!"
                ],
                timeframeChange: [
                    "Zaman aralığı [Timeframe] olarak değiştirildi. Daha büyük veya küçük resme odaklanıyoruz.",
                    "Mum çubuğu zaman dilimi [Timeframe] olarak ayarlandı. Bakış açımızı güncelledik.",
                    "[Timeframe] zaman dilimindeyiz. Piyasanın farklı bir yüzünü keşfediyoruz.",
                    "Ulan zaman aralığı [Timeframe] oldu lan! Sinirlim eskisine ama şimdi motive ol da büyük resme odaklan, ezeriz piyasayı Komutanım!"
                ],
                resetAll: [
                    "Tüm ayarlar sıfırlandı. Sistem yeniden başlatılmaya hazır. Temiz bir sayfa açtık Komutanım.",
                    "Ulan tüm ayarlar sıfırlandı lan! Sinirlim karmaşaya ama şimdi motive ol da temiz sayfaya atıl, ezeriz piyasayı Komutanım!"
                ],
                shadowBan: [
                    "[Strateji] gölgeye alındı. Uslan da gel!",
                    "Şşşt [Strateji], gölge moduna geç. Önce pistte kendini ispat et."
                ],
                shadowRehab: [
                    "Bravo! [Strateji] gölgede form tuttu, tekrar sahnede.",
                    "[Strateji] rehabilite edildi. Hadi bakalım, yüzümüzü kara çıkarma!"
                ],
                rogueOfDay: [
                    "Bugünün şerefsizi: [Strateji]! Kendine gel de adam gibi sinyal ver.",
                    "[Strateji], bugün gözüm üzerinde. Şerefsizlikte ısrar etme!"
                ],
                spoofBidRemoved: [
                    "Sahte emir tespit edildi, düşüş gelebilir. Dikkat et hacı abi.",
                    "Uyarı! Büyük bir alış desteği kayboldu. Piyasa aşağı sarkabilir, tetikte ol.",
                    "Balina desteğini çekti! Fiyat düşebilir, dikkatli ol komutanım."
                ],
                spoofAskRemoved: [
                    "Sahte emir tespit edildi, alım gelebilir. Dikkat et komutanım.",
                    "Uyarı! Büyük bir satış duvarı kayboldu. Fiyat yukarı hareketlenebilir, hazır ol.",
                    "Balina direnci kaldırdı! Fiyat yukarı doğru gidebilir , gözünü dört aç hacı abi."
                ]
            };


            this.init();
        }

        initDefaultStrategyStats() {
            const stats = {};
            (this.allStrategyKeys || []).forEach(k => {
                const baseStat = { alpha: 3, beta: 2, proposals: 0, contrib: 0, wins: 0, losses: 0, shadowWins: 0, shadowLosses: 0, shadowProposals: 0, lastUpdate: Date.now() };
                stats[k] = {
                    overall: { ...baseStat },
                    trend: { ...baseStat },
                    range: { ...baseStat },
                    transition: { ...baseStat }
                };
            });
            return stats;
        }
        saveStrategyStats() { this.saveData('utc_strategy_stats', this.strategyStats); }

        loadSettings() {
            const savedSettings = JSON.parse(localStorage.getItem('utc_settings') || '{}');
            const defaults = {
                confluenceThreshold: 3,
                params: { rsiPeriod: 14, atrPeriod: 14, wallBtc: 20, rrRatio: 1.5 },
                cooldowns: { signalMs: 15000, sameDirectionMs: 30000, oppositeDirectionMs: 20000, reverseHysteresisPoints: 2, proposalTimeoutMs: 3000, strategyProposalMs: 10000 },
                features: { 
                    enableSpoofDetection: true, enableCUSUMDrift: true, enableRiskGuardian: true, enableTTS: true, preferredVoiceName: null,
                    enableCandleConfirm: true,
                    enableMtfConfirm: true,
                    mtfTimeframe: '15m',
                    enableDynamicSizing: true
                },
                riskGuardian: {
                    killSwitchWinRate: 35.0,
                    autoRecover: false,
                    maxDrawdown: 5.0
                },
                optimization: {
                    enabled: true,
                    autoToggle: true,
                    timeDecaySec: 3,
                    dirMargin: 0.5,
                    minWeightToStay: 0.60,
                    minContribForToggle: 30,
                    gating: { enabled: true, spreadMaxPct: 0.001, minDepthUsd: 50000 },
                    signalQuality: { minContributors: 2, minGroups: 1 },
                    breakeven: { enabled: true, beAtR: 0.8, trailAfterR: 1.5, trailToR: 0.5 }
                },
                penalties: {
                    shadowEnabled: true,
                    minWeightToShadow: 0.60,
                    minContribForShadow: 30,
                    rehabWinRate: 0.58,
                    minShadowProposals: 20,
                    coolOffMs: 30 * 60 * 1000
                },
                statusMaps: {
                    shadowBanned: {},
                    hardBanned: {}
                },
                strategyParams: {
                    wallBounce: { DISTANCE_THRESHOLD_PERCENT: 0.0005 },
                    velocityScalping: { VELOCITY_WINDOW_MS: 2000, MIN_POINTS: 20, VELOCITY_THRESHOLD_PERCENT: 0.001 },
                    liquidityGaps: { GAP_THRESHOLD_PERCENT: 0.001 },
                    breakoutPattern: { LOOKBACK: 30, VOL_SPIKE: 1.4, BREAK_PCT: 0.0003 },
                    supportResistance: { LOOKBACK: 60, THRESH: 0.0015 },
                    fibonacciRetracement: { LOOKBACK: 120, TOL: 0.002 },
                    vwapReversion: { MULT: 1.0 },
                    superTrend: { MULT: 3.0, PERIOD: 14 },
                    marketStructure: { SWING: 3 },
                    institutionalOrderFlow: { TOP_N: 5, IMB_THRESHOLD: 2.0 },
                    microSpreadArbitrage: { SPREAD_PCT: 0.0008 },
                    volumeProfile: { PERIOD: 20, SPIKE: 2.0, CLOSE_POS: 0.7 },
                    divergenceDetection: { LOOKBACK: 40, SWING_PERIOD: 3 },
                    volatilityBreakout: { SQUEEZE_LOOKBACK: 20, SQUEEZE_MULT: 1.0, BREAKOUT_VOL_MULT: 1.5 },
                    candleCharacter: { MIN_BODY_TO_WICK_RATIO: 0.6, ANALYSIS_WINDOW_PERCENT: 0.2 },
                    fundingRateReversal: { FETCH_INTERVAL_MS: 60 * 1000, EXTREME_FUNDING_THRESHOLD: 0.001 }
                },
                activeStrategies: {} 
            };
            
            const mergeDeep = (target, source) => {
                for (const key in source) {
                    if (source[key] instanceof Object && key in target && !(source[key] instanceof Array)) {
                        Object.assign(target[key], mergeDeep(target[key], source[key]));
                    } else {
                        target[key] = source[key];
                    }
                }
                return target;
            };

            const currentSettings = mergeDeep(defaults, savedSettings);
            
            this.allStrategyKeys.forEach(key => {
                if (typeof currentSettings.activeStrategies[key] === 'undefined') {
                    currentSettings.activeStrategies[key] = true; 
                }
                if (currentSettings.statusMaps.hardBanned[key] || currentSettings.statusMaps.shadowBanned[key]) {
                    currentSettings.activeStrategies[key] = false;
                }
            });
            return currentSettings;
        }

        saveSettings() {
            localStorage.setItem('utc_settings', JSON.stringify(this.settings));
            this.applyStrategyParamOverrides();
            if (this.isRunning) {
                this.multiTimeframeManager.initialize(this.currentSymbol, [this.settings.features.mtfTimeframe]);
            }
        }
        loadData(key) { try { return JSON.parse(localStorage.getItem(key)); } catch { return null; } }
        saveData(key, data) { localStorage.setItem(key, JSON.stringify(data)); }
        
        getStrategyGroup(key) {
            if (this.strategyGroups.trending.includes(key)) return 'trending';
            if (this.strategyGroups.meanReversion.includes(key)) return 'meanReversion';
            return 'neutral';
        }
        
        getStrategyWeight(name) {
            const regime = this.marketRegime || 'overall';
            const regimeStats = this.strategyStats[name]?.[regime];
            const overallStats = this.strategyStats[name]?.overall;
            
            let s;
            if (regimeStats && (regimeStats.contrib || 0) > 10) {
                s = regimeStats;
            } else {
                s = overallStats || { alpha: 3, beta: 2 };
            }

            const mean = s.alpha / (s.alpha + s.beta);
            const totalObservations = s.alpha + s.beta;
            const uncertaintyPenalty = totalObservations < 10 ? 0.5 + (totalObservations / 20) : 1.0; 
            let w = (0.5 + mean) * uncertaintyPenalty; 
            w *= this.getGroupBoost(name);
            w = Math.max(0.3, Math.min(2.0, w)); 
            return w;
        }

        getGroupBoost(key) {
            const grp = this.getStrategyGroup(key);
            let boost = 1.0;
            if (this.marketRegime === 'trend' && grp === 'trending') boost *= 1.15;
            if (this.marketRegime === 'range' && grp === 'meanReversion') boost *= 1.15;
            const atrPct = (this.indicators.atr && this.marketData.price) ? (this.indicators.atr / this.marketData.price) : 0;
            if (atrPct < 0.005) { // Düşük volatilite
                if (grp === 'trending') boost *= 0.9; 
                if (grp === 'meanReversion') boost *= 1.05;
            } else if (atrPct > 0.02) { // Yüksek volatilite
                if (grp === 'trending') boost *= 1.05;
                if (grp === 'meanReversion') boost *= 0.95;
            }
            return boost;
        }
        init() {
            this.initStrategies(); 
            this.setupUI(); 
            this.setupEventListeners();
            this.debouncedRender();
            this.logToJournal('Sistem hazır. "SİSTEMİ BAŞLAT" butonuna tıklayın.');
            
            if (this.headerCollapsed) document.body.classList.add('header-collapsed'); else document.body.classList.remove('header-collapsed');
            this.switchMainView(this.currentMainView);
            this.sessionUpdateInterval = setInterval(() => this.updateSession(), 60000); 
            this.updateSession(); 

            this.countdownInterval = setInterval(() => this.updateCandleCountdown(), 1000);

            if (this.synth) {
                this.loadVoices();
                if(this.synth.onvoiceschanged !== undefined) {
                    this.synth.onvoiceschanged = () => this.loadVoices();
                }
            } else {
                console.warn('SpeechSynthesis API bu tarayıcı/cihazda desteklenmiyor.');
            }
            this.applyStrategyParamOverrides();
            this.startPerformanceMonitor(); // DÜZELTME: Performans izleyiciyi başlat
            
            // Event sistemi başlatma
            this.eventListeners = {};
            
            // Gelişmiş özellikleri entegre et
            this.initAdvancedFeatures();
        }
        
        initAdvancedFeatures() {
            // Eğer özelliker zaten başlatıldıysa bunu bildir
            if (this.dbManager && this.effectsManager && this.panteonManager) {
                console.log("Gelişmiş özellikler zaten başlatılmış.");
                return;
            }
            
            try {
                // Veritabanı yöneticisini başlat
                if (!this.dbManager) {
                    this.dbManager = new DBManager();
                    this.dbManager.init().then(() => {
                        console.log("Veritabanı yöneticisi başlatıldı.");
                        // İstatistikleri ve ayarları veritabanından yükle
                        this.loadDataFromDB();
                    });
                }
                
                // Efekt yöneticisini başlat
                if (!this.effectsManager) {
                    // TSParticles kütüphanesinin varlığını kontrol et
                    if (typeof tsParticles === 'undefined') {
                        console.warn("TSParticles kütüphanesi bulunamadı. Kütüphaneyi tekrar yüklemeyi dene...");
                        // Kütüphaneyi dinamik olarak yükle
                        const script = document.createElement('script');
                        script.src = "https://cdn.jsdelivr.net/npm/tsparticles-slim@2.12.0/tsparticles.slim.bundle.min.js";
                        script.onload = () => {
                            console.log("TSParticles kütüphanesi başarıyla yüklendi!");
                            this.effectsManager = new EffectsManager();
                            this.effectsManager.init().then(() => {
                                // Test için bir efekt oluştur
                                this.effectsManager.createMatrixEffect();
                            });
                        };
                        script.onerror = () => {
                            console.error("TSParticles kütüphanesi yüklenemedi!");
                        };
                        document.head.appendChild(script);
                    } else {
                        console.log("TSParticles kütüphanesi zaten yüklenmiş.");
                        this.effectsManager = new EffectsManager();
                        this.effectsManager.init().then(() => {
                            // Test için bir efekt oluştur
                            this.effectsManager.createMatrixEffect();
                        });
                    }
                }
                
                // Panteon yöneticisini başlat
                if (!this.panteonManager) {
                    if (typeof PantheonSystem === 'function') {
                        this.panteonManager = new PantheonSystem();
                        if (this.panteonManager && typeof this.panteonManager.init === 'function') {
                            this.panteonManager.init();
                        }
                    } else {
                        console.log("PantheonSystem sınıfı bulunamadı. Panteon özellikleri devre dışı.");
                    }
                }
                
                // TheOracle (Mahşerin Atlıları) sistemini başlat
                if (!this.oracle) {
                    this.oracle = new TheOracle(this);
                    this.oracle.init();
                }
                
                // MultiTimeframe yöneticisini başlat
                if (!this.multiTimeframeManager) {
                    if (typeof LegacyMultiTimeframeManager === 'function') {
                        this.multiTimeframeManager = new LegacyMultiTimeframeManager(this);
                    } else if (typeof MultiTimeframeManager === 'function') {
                        this.multiTimeframeManager = new MultiTimeframeManager(this);
                    }
                    
                    if (this.multiTimeframeManager && typeof this.multiTimeframeManager.init === 'function') {
                        this.multiTimeframeManager.init();
                    }
                }
                
                // Confluence Engine başlat
                if (!this.confluenceEngine) {
                    this.confluenceEngine = new ConfluenceEngine(this);
                }
                
                console.log("Tüm gelişmiş özellikler başlatıldı.");
            } catch (error) {
                console.error("Gelişmiş özellikler başlatılırken hata:", error);
            }
        }
        
        async loadDataFromDB() {
            if (!this.dbManager || !this.dbManager.ready) return;
            
            try {
                // Sinyalleri yükle
                const dbSignals = await this.dbManager.getAll('signals');
                if (dbSignals && dbSignals.length > 0) {
                    // İki sinyali birleştir ve son 100 tanesini sakla
                    this.signals = [...this.signals, ...dbSignals]
                        .sort((a, b) => b.timestamp - a.timestamp)
                        .slice(0, 100);
                    
                    console.log(`${dbSignals.length} sinyal veritabanından yüklendi.`);
                }
                
                // İstatistikleri yükle
                const dbStats = await this.dbManager.get('stats', 'global');
                if (dbStats) {
                    this.stats = {...this.stats, ...dbStats.data};
                    console.log("İstatistikler veritabanından yüklendi.");
                }
                
                // Ayarları yükle
                const dbSettings = await this.dbManager.get('settings', 'global');
                if (dbSettings) {
                    this.settings = {...this.settings, ...dbSettings.data};
                    console.log("Ayarlar veritabanından yüklendi.");
                    this.applyStrategyParamOverrides();
                }
            } catch (error) {
                console.error("Veritabanından veri yüklenirken hata:", error);
            }
        }
        
        // Event emitter fonksiyonu
        emit(eventName, data) {
            if (!this.eventListeners[eventName]) return;
            
            this.eventListeners[eventName].forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    console.error(`Event handler (${eventName}) hatası:`, error);
                }
            });
        }
        
        // Event listener kayıt fonksiyonu
        on(eventName, callback) {
            if (!this.eventListeners[eventName]) {
                this.eventListeners[eventName] = [];
            }
            this.eventListeners[eventName].push(callback);
            
            // Geri dönüş fonksiyonu (listener'ı kaldırmak için)
            return () => {
                this.eventListeners[eventName] = this.eventListeners[eventName].filter(cb => cb !== callback);
            };
        }

        initStrategies() { 
            for (const key in this.allStrategiesMap) { this.strategies[key] = new this.allStrategiesMap[key](this); } 
            this.updateActiveStrategies(); 
        }
        updateActiveStrategies() { 
            for (const key in this.strategies) { 
                this.strategies[key].DEFAULT_PROPOSAL_COOLDOWN_MS = this.settings.cooldowns.strategyProposalMs; 
                const isActive = this.settings.activeStrategies[key] && 
                                 !this.settings.statusMaps.shadowBanned[key] && 
                                 !this.settings.statusMaps.hardBanned[key];
                this.strategies[key].setIsLive(isActive);
            } 
        }

        applyStrategyParamOverrides() {
            const p = this.settings.strategyParams || {};
            for (const key of Object.keys(this.strategies)) {
                if (!this.strategies[key]) continue;
                const inst = this.strategies[key];
                const ov = p[key] || {};
                for (const k of Object.keys(ov)) {
                    if (k in inst) inst[k] = ov[k];
                }
            }
        }

        setupUI() {
            document.getElementById('symbol-input').value = this.currentSymbol.replace('USDT', '');
            document.getElementById('timeframe-select').value = this.currentTimeframe;

            this.updateSettingsModalUI();
            const savedTheme = localStorage.getItem('utc_theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            this.chartManager.updateTheme(); 
            this.heatmapManager.updateTheme();
            this.updateSuperTopTicker();
            
            // Gelişmiş özellikleri desteklemek için Ayarlar modalına yeni bir bölüm ekle
            this.setupAdvancedFeaturesUI();
        }
        
        setupAdvancedFeaturesUI() {
            // Modal içinde gelişmiş özellikleri içeren bölümü bul veya oluştur
            const settingsModal = document.getElementById('settings-modal');
            if (!settingsModal) return;
            
            let featuresContainer = document.getElementById('modal-features');
            if (!featuresContainer) {
                featuresContainer = document.createElement('div');
                featuresContainer.id = 'modal-features';
                settingsModal.querySelector('.modal-body')?.appendChild(featuresContainer);
            }
            
            // Gelişmiş özellikler bölümü var mı kontrol et
            let advancedFeaturesSection = document.getElementById('advanced-features-section');
            if (!advancedFeaturesSection) {
                // Yoksa oluştur
                advancedFeaturesSection = document.createElement('div');
                advancedFeaturesSection.id = 'advanced-features-section';
                advancedFeaturesSection.className = 'settings-section';
                advancedFeaturesSection.innerHTML = `
                    <h3>Gelişmiş Özellikler</h3>
                    <div class="settings-item">
                        <label for="enable-panteon">Panteon Sistemi</label>
                        <div class="toggle-switch">
                            <input type="checkbox" id="enable-panteon" checked>
                            <span class="toggle-slider"></span>
                        </div>
                    </div>
                    <div class="settings-item">
                        <label for="enable-oracle">Mahşerin Atlıları</label>
                        <div class="toggle-switch">
                            <input type="checkbox" id="enable-oracle" checked>
                            <span class="toggle-slider"></span>
                        </div>
                    </div>
                    <div class="settings-item">
                        <label for="enable-effects">Görsel Efektler</label>
                        <div class="toggle-switch">
                            <input type="checkbox" id="enable-effects" checked>
                            <span class="toggle-slider"></span>
                        </div>
                    </div>
                    <div class="settings-item">
                        <label for="enable-multi-timeframe">Çoklu Zaman Dilimi</label>
                        <div class="toggle-switch">
                            <input type="checkbox" id="enable-multi-timeframe" checked>
                            <span class="toggle-slider"></span>
                        </div>
                    </div>
                    <div class="settings-item">
                        <label for="enable-confluence">Confluence Motoru</label>
                        <div class="toggle-switch">
                            <input type="checkbox" id="enable-confluence" checked>
                            <span class="toggle-slider"></span>
                        </div>
                    </div>
                    <div class="settings-item">
                        <label for="min-confluence-score">Min. Confluence Skoru:</label>
                        <input type="number" id="min-confluence-score" value="3" min="1" max="10" step="0.5" class="form-control">
                    </div>
                `;
                
                featuresContainer.appendChild(advancedFeaturesSection);
                
                // Event listener'lar ekle
                document.getElementById('enable-panteon')?.addEventListener('change', (e) => {
                    if (this.panteonManager) {
                        const isEnabled = e.target.checked;
                        document.getElementById('pantheon-ui').style.display = isEnabled ? 'block' : 'none';
                        this.showNotification(`Panteon sistemi ${isEnabled ? 'etkinleştirildi' : 'devre dışı bırakıldı'}`, 'info');
                    }
                });
                
                document.getElementById('enable-oracle')?.addEventListener('change', (e) => {
                    if (this.oracle) {
                        const isEnabled = e.target.checked;
                        document.getElementById('mahser-atlilari').style.display = isEnabled ? 'flex' : 'none';
                        this.showNotification(`Mahşerin Atlıları ${isEnabled ? 'görünür' : 'gizli'}`, 'info');
                    }
                });
                
                document.getElementById('enable-effects')?.addEventListener('change', (e) => {
                    if (this.effectsManager) {
                        const isEnabled = e.target.checked;
                        this.effectsManager.toggleEffects(isEnabled);
                        
                        // Test efekti göster
                        if (isEnabled) {
                            setTimeout(() => {
                                this.effectsManager.createMatrixEffect();
                            }, 500);
                        }
                        
                        this.showNotification(`Görsel efektler ${isEnabled ? 'etkinleştirildi' : 'devre dışı bırakıldı'}`, 'info');
                    }
                });
                
                // Test butonunu gelişmiş özellikler bölümüne ekle
                const testEffectsButton = document.createElement('button');
                testEffectsButton.className = 'btn btn-sm btn-primary mt-2';
                testEffectsButton.style.marginTop = '10px';
                testEffectsButton.textContent = 'Efektleri Test Et';
                testEffectsButton.addEventListener('click', () => {
                    if (this.effectsManager) {
                        this.effectsManager.createMatrixEffect();
                        this.effectsManager.createExplosionEffect(
                            window.innerWidth / 2, 
                            window.innerHeight / 2,
                            '#00ff00',
                            30
                        );
                        this.showNotification('Efekt testi çalıştırılıyor!', 'success');
                    } else {
                        this.showNotification('Efekt yöneticisi henüz başlatılmamış!', 'error');
                    }
                });
                
                const effectSettingsItem = document.getElementById('enable-effects')?.closest('.settings-item');
                if (effectSettingsItem) {
                    effectSettingsItem.appendChild(testEffectsButton);
                }
                
                document.getElementById('enable-multi-timeframe')?.addEventListener('change', (e) => {
                    if (this.multiTimeframeManager) {
                        const isEnabled = e.target.checked;
                        const tabsContainer = document.querySelector('.tabs-container');
                        if (tabsContainer) tabsContainer.style.display = isEnabled ? 'flex' : 'none';
                        this.showNotification(`Çoklu zaman dilimi ${isEnabled ? 'etkinleştirildi' : 'devre dışı bırakıldı'}`, 'info');
                    }
                });
                
                document.getElementById('enable-confluence')?.addEventListener('change', (e) => {
                    if (this.confluenceEngine) {
                        const isEnabled = e.target.checked;
                        this.confluenceEngine.toggleConfluence(isEnabled);
                        this.showNotification(`Confluence motoru ${isEnabled ? 'etkinleştirildi' : 'devre dışı bırakıldı'}`, 'info');
                    }
                });
                
                document.getElementById('min-confluence-score')?.addEventListener('change', (e) => {
                    if (this.confluenceEngine) {
                        const score = parseFloat(e.target.value);
                        if (isNaN(score) || score < 1) {
                            e.target.value = '1';
                            this.confluenceEngine.setMinConfluenceScore(1);
                        } else if (score > 10) {
                            e.target.value = '10';
                            this.confluenceEngine.setMinConfluenceScore(10);
                        } else {
                            this.confluenceEngine.setMinConfluenceScore(score);
                        }
                        this.showNotification(`Minimum confluence skoru ${this.confluenceEngine.minConfluenceScore} olarak ayarlandı`, 'info');
                    }
                });
            }
        }
        updateSuperTopTicker() { document.getElementById('ticker-bar-symbol').textContent = this.currentSymbol.replace('USDT', '/USDT'); }

        updateSettingsModalUI() {
            const s = this.settings;
            document.getElementById('modal-confluence-threshold').value = s.confluenceThreshold;
            document.getElementById('modal-param-rsi-period').value = s.params.rsiPeriod;
            document.getElementById('modal-param-atr-period').value = s.params.atrPeriod;
            document.getElementById('modal-param-wall-btc').value = s.params.wallBtc;
            document.getElementById('modal-param-rr-ratio').value = s.params.rrRatio;
            document.getElementById('modal-signal-cooldown-ms').value = s.cooldowns.signalMs;
            document.getElementById('modal-same-direction-cooldown-ms').value = s.cooldowns.sameDirectionMs;
            document.getElementById('modal-opposite-direction-cooldown-ms').value = s.cooldowns.oppositeDirectionMs;
            document.getElementById('modal-reverse-hysteresis-points').value = s.cooldowns.reverseHysteresisPoints;
            document.getElementById('modal-proposal-timeout-ms').value = s.cooldowns.proposalTimeoutMs;
            document.getElementById('modal-strategy-proposal-cooldown-ms').value = s.cooldowns.strategyProposalMs;
            document.getElementById('modal-enable-spoof-detection').checked = s.features.enableSpoofDetection;
            document.getElementById('modal-enable-cusum-drift').checked = s.features.enableCUSUMDrift;
            document.getElementById('modal-enable-risk-guardian').checked = s.features.enableRiskGuardian;
            document.getElementById('modal-enable-auto-optimize').checked = s.optimization.enabled;
            document.getElementById('modal-enable-auto-toggle-strat').checked = s.optimization.autoToggle;
            document.getElementById('modal-enable-breakeven-trail').checked = s.optimization.breakeven.enabled;
            document.getElementById('modal-be-at-r').value = s.optimization.breakeven.beAtR;
            document.getElementById('modal-trail-after-r').value = s.optimization.breakeven.trailAfterR;
            document.getElementById('modal-trail-to-r').value = s.optimization.breakeven.trailToR;
            document.getElementById('modal-enable-tts').checked = s.features.enableTTS;
            
            const enableCandleConfirmEl = document.getElementById('modal-enable-candle-confirm');
            if(enableCandleConfirmEl) enableCandleConfirmEl.checked = s.features.enableCandleConfirm;
            
            const enableMtfConfirmEl = document.getElementById('modal-enable-mtf-confirm');
            if(enableMtfConfirmEl) enableMtfConfirmEl.checked = s.features.enableMtfConfirm;
            
            const mtfTimeframeEl = document.getElementById('modal-mtf-timeframe');
            if(mtfTimeframeEl) mtfTimeframeEl.value = s.features.mtfTimeframe;
            
            const enableDynamicSizingEl = document.getElementById('modal-enable-dynamic-sizing');
            if(enableDynamicSizingEl) enableDynamicSizingEl.checked = s.features.enableDynamicSizing;
            
            this.updateTTSVoiceSelectUI(); 

            const strategyModalContainer = document.getElementById('modal-strategy-toggles');
            strategyModalContainer.innerHTML = '';
            this.allStrategyKeys.forEach(key => { 
                const strategy = this.strategies[key];
                if (!strategy) return;
                const isChecked = s.activeStrategies[key];
                const isShadowBanned = s.statusMaps.shadowBanned[key];
                const isHardBanned = s.statusMaps.hardBanned[key];
                
                let statusText = '';
                if (isHardBanned) statusText = ' (HARDBAN)';
                else if (isShadowBanned) statusText = ' (GÖLGE)';

                const toggleHtml = `<div class="form-group"><label class="checkbox-label"><input type="checkbox" class="strategy-toggle" data-strategy-key="${key}" ${isChecked ? 'checked' : ''} ${isHardBanned || isShadowBanned ? 'disabled' : ''}> ${strategy.displayName}${statusText}</label></div>`;
                strategyModalContainer.innerHTML += toggleHtml;
            });
            this.debouncedRender();
        }

                                                setupEventListeners() {
            document.getElementById('start-btn').addEventListener('click', () => this.start());
            document.getElementById('stop-btn').addEventListener('click', () => this.stop());
            document.getElementById('theme-toggle-btn').addEventListener('click', () => this.toggleTheme());
            document.getElementById('symbol-input').addEventListener('change', async (e) => {
                let newSymbol = e.target.value.toUpperCase().trim();
                if (!newSymbol.endsWith('USDT')) newSymbol += 'USDT';
                await this.changeSymbol(newSymbol);
                this.saveData('utc_current_symbol', newSymbol);
            });
            document.getElementById('timeframe-select').addEventListener('change', async (e) => {
                this.changeTimeframe(e.target.value);
                this.saveData('utc_current_timeframe', e.target.value);
            });
            
            document.querySelector('.header-center-title').addEventListener('dblclick', () => {
                this.toggleControlsPanel();
                this.saveData('utc_header_collapsed', this.headerCollapsed.toString());
            });
            document.getElementById('mobile-toggle-controls-btn').addEventListener('click', () => {
                this.toggleControlsPanel();
                this.saveData('utc_header_collapsed', this.headerCollapsed.toString());
            });

            document.getElementById('main-controls-btn').addEventListener('click', () => {
                this.toggleControlsPanel();
                this.saveData('utc_header_collapsed', this.headerCollapsed.toString());
            });
            document.getElementById('chart-view-btn').addEventListener('click', () => { this.switchMainView('chart'); this.saveData('utc_current_view', 'chart'); });
            document.getElementById('heatmap-view-btn').addEventListener('click', () => { this.switchMainView('heatmap'); this.saveData('utc_current_view', 'heatmap'); });
            document.getElementById('fullscreen-chart-btn').addEventListener('click', () => this.enterFullscreenChart());
            document.getElementById('exit-fullscreen-btn').addEventListener('click', () => this.exitFullscreenChart());

            document.getElementById('open-settings-modal-btn').addEventListener('click', () => this.openSettingsModal());
            document.getElementById('clear-markers-btn').addEventListener('click', () => this.clearChartMarkers()); 
            document.getElementById('chart-zoom-in').addEventListener('click', () => this.chartManager.zoomIn());
            document.getElementById('chart-zoom-out').addEventListener('click', () => this.chartManager.zoomOut());
            document.getElementById('chart-zoom-reset').addEventListener('click', () => this.chartManager.resetZoom());
            document.getElementById('close-settings-modal-btn').addEventListener('click', () => this.closeSettingsModal());
            document.getElementById('settings-modal-overlay').addEventListener('click', (e) => { if (e.target.id === 'settings-modal-overlay') this.closeSettingsModal(); });
            
            // DÜZELTME: Yeni grafik butonu için olay dinleyici eklendi
            document.getElementById('mobile-chart-view-btn').addEventListener('click', () => { this.switchMainView('chart'); this.saveData('utc_current_view', 'chart'); });
            document.getElementById('mobile-heatmap-view-btn').addEventListener('click', () => { this.switchMainView('heatmap'); this.saveData('utc_current_view', 'heatmap'); });
            document.getElementById('mobile-fullscreen-chart-btn').addEventListener('click', () => this.enterFullscreenChart());
            document.getElementById('mobile-open-settings-modal-btn').addEventListener('click', () => this.openSettingsModal());
            document.getElementById('mobile-honor-board-btn').addEventListener('click', () => this.openHonorModal());
            document.getElementById('mobile-banned-board-btn').addEventListener('click', () => this.openHonorModal('banned'));
            // YENİ: Log Paneli butonları için olay dinleyicileri
            document.getElementById('mobile-open-log-modal-btn').addEventListener('click', () => {
                document.getElementById('log-modal-overlay').classList.add('visible');
            });
            document.getElementById('close-log-modal-btn').addEventListener('click', () => {
                document.getElementById('log-modal-overlay').classList.remove('visible');
            });
            document.getElementById('export-logs-btn').addEventListener('click', () => this.exportLogs());


            const s = this.settings;
            document.getElementById('modal-confluence-threshold').addEventListener('input', (e) => s.confluenceThreshold = parseInt(e.target.value));
            document.getElementById('modal-param-rsi-period').addEventListener('change', (e) => s.params.rsiPeriod = parseInt(e.target.value));
            document.getElementById('modal-param-atr-period').addEventListener('change', (e) => s.params.atrPeriod = parseInt(e.target.value));
            document.getElementById('modal-param-wall-btc').addEventListener('change', (e) => s.params.wallBtc = parseInt(e.target.value));
            document.getElementById('modal-param-rr-ratio').addEventListener('change', (e) => s.params.rrRatio = parseFloat(e.target.value));
            document.getElementById('modal-signal-cooldown-ms').addEventListener('change', (e) => s.cooldowns.signalMs = parseInt(e.target.value) || 0);
            document.getElementById('modal-same-direction-cooldown-ms').addEventListener('change', (e) => s.cooldowns.sameDirectionMs = parseInt(e.target.value) || 0);
            document.getElementById('modal-opposite-direction-cooldown-ms').addEventListener('change', (e) => s.cooldowns.oppositeDirectionMs = parseInt(e.target.value) || 0);
            document.getElementById('modal-reverse-hysteresis-points').addEventListener('change', (e) => s.cooldowns.reverseHysteresisPoints = parseInt(e.target.value) || 0);
            document.getElementById('modal-proposal-timeout-ms').addEventListener('change', (e) => s.cooldowns.proposalTimeoutMs = parseInt(e.target.value) || 1000);
            document.getElementById('modal-strategy-proposal-cooldown-ms').addEventListener('change', (e) => s.cooldowns.strategyProposalMs = parseInt(e.target.value) || 0);
            document.getElementById('modal-enable-spoof-detection').addEventListener('change', (e) => s.features.enableSpoofDetection = e.target.checked);
            document.getElementById('modal-enable-cusum-drift').addEventListener('change', (e) => s.features.enableCUSUMDrift = e.target.checked);
            document.getElementById('modal-enable-risk-guardian').addEventListener('change', (e) => s.features.enableRiskGuardian = e.target.checked);
            document.getElementById('modal-enable-auto-optimize').addEventListener('change', (e) => s.optimization.enabled = e.target.checked);
            document.getElementById('modal-enable-auto-toggle-strat').addEventListener('change', (e) => s.optimization.autoToggle = e.target.checked);
            document.getElementById('modal-enable-breakeven-trail').addEventListener('change', (e) => s.optimization.breakeven.enabled = e.target.checked);
            document.getElementById('modal-be-at-r').addEventListener('change', (e) => s.optimization.breakeven.beAtR = parseFloat(e.target.value));
            document.getElementById('modal-trail-after-r').addEventListener('change', (e) => s.optimization.breakeven.trailAfterR = parseFloat(e.target.value));
            document.getElementById('modal-trail-to-r').addEventListener('change', (e) => s.optimization.breakeven.trailToR = parseFloat(e.target.value));
            document.getElementById('modal-enable-tts').addEventListener('change', (e) => {
                s.features.enableTTS = e.target.checked;
                this.updateTTSVoiceSelectUI();
            });
            document.getElementById('modal-tts-voice-select').addEventListener('change', (e) => {
                s.features.preferredVoiceName = e.target.value === "" ? null : e.target.value;
                this.saveSettings();
                if (e.target.value !== "") this.speak("Ses başarıyla değiştirildi.", { lang: 'tr-TR', rate: 1.0 });
            });
            const enableCandleConfirmEl = document.getElementById('modal-enable-candle-confirm');
            if(enableCandleConfirmEl) enableCandleConfirmEl.addEventListener('change', (e) => s.features.enableCandleConfirm = e.target.checked);
            
            const enableMtfConfirmEl = document.getElementById('modal-enable-mtf-confirm');
            if(enableMtfConfirmEl) enableMtfConfirmEl.addEventListener('change', (e) => s.features.enableMtfConfirm = e.target.checked);
            
            const mtfTimeframeEl = document.getElementById('modal-mtf-timeframe');
            if(mtfTimeframeEl) mtfTimeframeEl.addEventListener('change', (e) => s.features.mtfTimeframe = e.target.value);
            
            const enableDynamicSizingEl = document.getElementById('modal-enable-dynamic-sizing');
            if(enableDynamicSizingEl) enableDynamicSizingEl.addEventListener('change', (e) => s.features.enableDynamicSizing = e.target.checked);


            document.getElementById('modal-strategy-toggles').addEventListener('change', (e) => {
                if (e.target.classList.contains('strategy-toggle')) {
                    const key = e.target.dataset.strategyKey;
                    if (s.statusMaps.hardBanned[key] || s.statusMaps.shadowBanned[key]) {
                        e.target.checked = !e.target.checked; 
                        return;
                    }
                    s.activeStrategies[key] = e.target.checked;
                    this.updateActiveStrategies();
                    this.showNotification(`${this.strategies[key].displayName} ${e.target.checked ? 'aktif' : 'pasif'}.`, 'info');
                    this.saveSettings();
                }
            });

            document.getElementById('modal-clear-signals-btn').addEventListener('click', () => this.clearAllSignals());
            document.getElementById('reset-all-settings-btn').addEventListener('click', () => this.resetAllSettings());
            document.getElementById('save-settings-btn').addEventListener('click', () => { this.saveSettings(); this.showNotification('Ayarlar kaydedildi!', 'success'); this.closeSettingsModal(); });

            document.getElementById('honor-board-btn').addEventListener('click', () => this.openHonorModal());
            document.getElementById('banned-board-btn').addEventListener('click', () => this.openHonorModal('banned'));
            document.getElementById('close-honor-modal').addEventListener('click', () => this.closeHonorModal());
            document.getElementById('honor-modal-overlay').addEventListener('click', (e)=>{ if (e.target.id === 'honor-modal-overlay') this.closeHonorModal(); });
            
            const centerPanel = document.querySelector('.center-panel');
            const resizeHandle = centerPanel.querySelector('.resize-handle');
            if (resizeHandle) {
                let isResizing = false;
                const onMouseMove = (e) => {
                    if (!isResizing) return;
                    const containerRect = centerPanel.parentElement.getBoundingClientRect();
                    let newHeight = e.clientY - containerRect.top;
                    newHeight = Math.max(200, Math.min(containerRect.height - 150, newHeight));
                    centerPanel.style.height = `${newHeight}px`;
                    window.dispatchEvent(new Event('resize')); 
                };
                const onMouseUp = () => {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                resizeHandle.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    document.body.style.cursor = 'ns-resize';
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                });
            }
        }






        toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            let newTheme;
            
            if (currentTheme === 'dark') {
                newTheme = 'light';
            } else if (currentTheme === 'light') {
                newTheme = 'war';
                this.enterCombatMode();
            } else {
                newTheme = 'dark';
                this.exitCombatMode();
            }
            
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('utc_theme', newTheme);
            this.chartManager.updateTheme();
            this.heatmapManager.updateTheme();
        }
        
        enterCombatMode() {
            this.combatModeActive = true;
            this.speak(this.getRandomMessage('combatModeActivate'));
            
            // Görsel efektler
            const overlay = document.createElement('div');
            overlay.id = 'war-mode-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: radial-gradient(circle at center, rgba(255,50,50,0.2), transparent 80%);
                z-index: 9999;
                pointer-events: none;
                animation: warPulse 3s infinite;
            `;
            
            const style = document.createElement('style');
            style.id = 'war-mode-animation';
            style.innerHTML = `
                @keyframes warPulse {
                    0% { opacity: 0.3; }
                    50% { opacity: 0.7; }
                    100% { opacity: 0.3; }
                }
                
                @keyframes war-pulse {
                    0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
                    70% { box-shadow: 0 0 0 10px rgba(255, 0, 0, 0); }
                    100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
                }
            `;
            
            document.head.appendChild(style);
            document.body.appendChild(overlay);
        }
        
        exitCombatMode() {
            this.combatModeActive = false;
            this.speak(this.getRandomMessage('combatModeDeactivate'));
            
            // Efektleri temizle
            const overlay = document.getElementById('war-mode-overlay');
            const style = document.getElementById('war-mode-animation');
            
            if (overlay) overlay.remove();
            if (style) style.remove();
        }
        toggleControlsPanel() {
            document.body.classList.toggle('header-collapsed');
            this.headerCollapsed = document.body.classList.contains('header-collapsed'); 
            setTimeout(() => { window.dispatchEvent(new Event('resize')); }, 360);
        }
        switchMainView(viewName) {
            this.currentMainView = viewName;
            const chartView = document.getElementById('chart-container-view');
            const heatmapView = document.getElementById('heatmap-container-view');
            const chartCountdownOverlay = document.getElementById('chart-countdown-overlay');

            if (viewName === 'chart') {
                chartView.classList.remove('hidden-view');
                heatmapView.classList.add('hidden-view');
                chartCountdownOverlay.classList.remove('hidden-view');
            } else {
                chartView.classList.add('hidden-view');
                heatmapView.classList.remove('hidden-view');
                chartCountdownOverlay.classList.add('hidden-view');
            }
            setTimeout(() => window.dispatchEvent(new Event('resize')), 50);
        }
        enterFullscreenChart() {
            document.body.classList.add('fullscreen-chart');
            document.getElementById('exit-fullscreen-btn').classList.remove('hidden-view');
            document.getElementById('chart-countdown-overlay').classList.remove('hidden-view');
            window.dispatchEvent(new Event('resize'));
        }
        exitFullscreenChart() {
            document.body.classList.remove('fullscreen-chart');
            document.getElementById('exit-fullscreen-btn').classList.add('hidden-view');
            if (this.currentMainView !== 'chart') {
                document.getElementById('chart-countdown-overlay').classList.add('hidden-view');
            }
            window.dispatchEvent(new Event('resize'));
        }

        openSettingsModal() { this.updateSettingsModalUI(); document.getElementById('settings-modal-overlay').classList.add('visible'); }
        closeSettingsModal() { document.getElementById('settings-modal-overlay').classList.remove('visible'); this.updateActiveStrategies(); this.calculateAllIndicators(); window.dispatchEvent(new Event('resize')); }

        resetAllSettings() {
            if (confirm('Tüm ayarları ve sinyal geçmişini sıfırlamak istediğinizden emin misiniz? Bu işlem geri alınamaz.')) {
                localStorage.clear();
                window.location.reload();
            }
        }

        async start() {
            if (this.isRunning) return;
            this.isRunning = true; 
            document.getElementById('start-btn').disabled = true; 
            document.getElementById('stop-btn').disabled = false;
            
            // MultiTimeframeManager'ı güvenli bir şekilde başlat
            if (this.settings.features.enableMtfConfirm && this.multiTimeframeManager) {
                try {
                    // Önce multiTimeframeManager'ın hazır olduğundan emin ol
                    if (typeof this.multiTimeframeManager.initialize === 'function') {
                        await this.multiTimeframeManager.initialize(this.currentSymbol, [this.settings.features.mtfTimeframe]);
                    } else if (typeof this.multiTimeframeManager.init === 'function') {
                        // initialize metodu yoksa init metodunu dene
                        await this.multiTimeframeManager.init();
                    }
                } catch (error) {
                    console.warn('MultiTimeframeManager başlatılırken hata:', error);
                    // Hata olsa bile sistem çalışmaya devam etsin
                }
            }
            
            this.showNotification('Sistem Başlatıldı: Canlı veri akışı başlatılıyor...', 'success');
            this.speak(this.getRandomMessage('systemStart'));
            await this.fetchInitialData(); 
            this.connectWebSockets();
            
            this.renderInterval = setInterval(() => this.render(), 250);
            this.analysisInterval = setInterval(() => this.runPeriodicAnalysis(), 5000);
            
            // Piyasa manipülasyonu tespiti her 30 saniyede bir çalıştır
            this.manipulationDetectInterval = setInterval(() => this.detectMarketManipulation(), 30000);
            
            // Enerji Yönetim Sistemini başlat
            if (!this.energyManager) {
                this.energyManager = new EnergyManager(this);
            }
            
            // Ritüel Sistemini başlat
            if (!this.ritualManager) {
                this.ritualManager = new RitualManager(this);
            }
            
            if (this.settings.optimization.enabled) {
                this.cooldownTuneInterval = setInterval(() => this.autoTuneCooldowns(), 30000); 
                this.thresholdTuneInterval = setInterval(() => this.autoTuneThresholds(), 30000); 
                this.paramTuneInterval = setInterval(() => this.autoTuneStrategyParams(), 5 * 60 * 1000);
                this.autoToggleStrategiesInterval = setInterval(() => this.autoToggleStrategies(), 5 * 60 * 1000);
            }
        }

        stop() {
            if (!this.isRunning) return;
            this.isRunning = false; 
            document.getElementById('start-btn').disabled = false; 
            document.getElementById('stop-btn').disabled = true; 
            this.disconnectWebSockets();
            if (this.renderInterval) clearInterval(this.renderInterval); 
            if (this.analysisInterval) clearInterval(this.analysisInterval);
            if (this.manipulationDetectInterval) clearInterval(this.manipulationDetectInterval);
            if (this.cooldownTuneInterval) clearInterval(this.cooldownTuneInterval);
            if (this.thresholdTuneInterval) clearInterval(this.thresholdTuneInterval);
            if (this.paramTuneInterval) clearInterval(this.paramTuneInterval);
            if (this.autoToggleStrategiesInterval) clearInterval(this.autoToggleStrategiesInterval);
            
            this.multiTimeframeManager.cleanup();
            this.updateConnectionStatus(false, "BAĞLANTI KESİLDİ"); 
            if (this.combatModeActive) this.deactivateCombatMode();
            this.showNotification('Sistem Durduruldu.', 'danger');
            this.speak(this.getRandomMessage('systemStop'));
        }
        
        detectMarketManipulation() {
            if (!this.manipulationDetector) {
                this.manipulationDetector = new MarketManipulationDetector(this);
            }
            
            const detection = this.manipulationDetector.detect();
            
            if (detection) {
                // Manipülasyon tespiti!
                this.showNotification(`PİYASA MANİPÜLASYONU TESPİT EDİLDİ: ${detection.message}`, 'warning');
                
                // Savaş modunu etkinleştir
                if (!this.combatModeActive) {
                    this.activateCombatMode();
                }
                
                // TTS ile sesli uyarı
                this.speak(`Dikkat! Piyasa manipülasyonu tespit edildi. ${detection.message} Koruyucu önlemler alınıyor.`);
                
                // Düşük skora sahip önerileri temizle ve yüksek risk içeren işlemleri filtrele
                this.confluenceEngine.proposals = this.confluenceEngine.proposals.filter(p => p.score >= 7);
                
                // Olay günlüğüne kaydet
                console.warn(`[Manipülasyon Tespiti ${new Date().toLocaleTimeString()}] ${detection.message}`);
                
                return detection;
            }
            
            return false;
        }

        async changeSymbol(newSymbol) {
            if (this.currentSymbol === newSymbol) return;
            this.currentSymbol = newSymbol; 
            this.showNotification(`${this.currentSymbol.replace('USDT', '/USDT')} sembolüne geçildi.`, 'info');
            this.speak(this.getRandomMessage('symbolChange', { 'Sembol': this.currentSymbol.replace('USDT', '') }));
            this.resetDataForNewSymbol();
            if (this.isRunning) { this.stop(); await this.start(); }
            this.updateSuperTopTicker(); 
        }
        async changeTimeframe(newTimeframe) {
            this.currentTimeframe = newTimeframe; 
            this.showNotification(`Zaman aralığı ${this.currentTimeframe} olarak değiştirildi.`, 'info');
            this.speak(this.getRandomMessage('timeframeChange', { 'Timeframe': this.currentTimeframe }));
            this.resetDataForNewSymbol();
            if (this.isRunning) { this.stop(); await this.start(); }
        }
                resetDataForNewSymbol() {
            // --- YENİ: Grafik hafızasını temizle ---
            localStorage.removeItem('utc_chart_view');

            this.candles = []; this.aggTrades = []; this.marketData.price = 0; 
            this.orderBook = { bids: [], asks: [], lastUpdateId: null }; 
            this.indicators = { rsi: [], atr: null, sma20: null, sma50: null, volSma20: null, vwap: null, adx: null, bbands: null };
            this.pendingSignals = [];
            this.chartManager.setData([]); this.chartManager.clearMarkers(); this.render();
            this.heatmapManager.draw({bids:[], asks:[]}, 0);
        }


        async fetchInitialData() {
            try {
                this.logToJournal(`${this.currentSymbol} için geçmiş mum verileri çekiliyor...`);
                const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${this.currentSymbol}&interval=${this.currentTimeframe}&limit=500`;
                const response = await fetch(url); if (!response.ok) throw new Error(`API Hatası: ${response.statusText}`);
                const data = await response.json();
                this.candles = data.map(d => ({ time: d[0], open: parseFloat(d[1]), high: parseFloat(d[2]), low: parseFloat(d[3]), close: parseFloat(d[4]), volume: parseFloat(d[5]), }));
                this.chartManager.setData(this.candles); this.logToJournal(`${this.candles.length} adet mum yüklendi.`);
                this.calculateAllIndicators();
            } catch (error) { this.showNotification(`Geçmiş veri alınamadı: ${error.message}`, 'danger'); console.error("Geçmiş veri hatası:", error); }
        }

        connectWebSockets() {
            this.disconnectWebSockets(); 
            this.reconnectAttempts = 0;
            const symbolLower = this.currentSymbol.toLowerCase();
            const streams = [`${symbolLower}@ticker`, `${symbolLower}@depth20@100ms`, `${symbolLower}@aggTrade`, `${symbolLower}@kline_${this.currentTimeframe}`];
            const ws = new WebSocket(`wss://fstream.binance.com/stream?streams=${streams.join('/')}`); 
            this.sockets['main'] = ws;
            
            ws.onopen = () => { this.updateConnectionStatus(true); this.reconnectAttempts = 0; this.logToJournal("WebSocket bağlantısı başarıyla kuruldu."); };
            ws.onmessage = (event) => { const message = JSON.parse(event.data); this.handleMarketData(message.stream, message.data); };
            ws.onerror = (error) => console.error('WebSocket Hatası:', error);
            ws.onclose = () => { 
                if (this.isRunning) { 
                    this.reconnectAttempts++;
                    this.reconnectDelay = Math.min(30000, 3000 * Math.pow(2, this.reconnectAttempts - 1));
                    const message = `YENİDEN BAĞLANILIYOR... (${this.reconnectDelay / 1000}s)`;
                    this.updateConnectionStatus(false, message); 
                    this.logToJournal(`Bağlantı kapandı. ${this.reconnectDelay/1000} saniye sonra yeniden denenecek. (Deneme: ${this.reconnectAttempts})`);
                    setTimeout(() => this.connectWebSockets(), this.reconnectDelay); 
                } 
            };
        }
        disconnectWebSockets() { 
            if (this.sockets['main']) { 
                this.sockets['main'].onclose = null;
                this.sockets['main'].close(1000, "İstemci tarafından kapatıldı"); 
                delete this.sockets['main'];
            }
        }

        handleMarketData(stream, data) {
            const streamType = stream.split('@')[1];
            if (streamType === 'ticker') {
                this.marketData.price = parseFloat(data.c);
                this.marketData.change24h = parseFloat(data.P);
                this.marketData.volume24h = parseFloat(data.q);
                this.marketData.symbol = data.s;
                if (data.s === 'BTCUSDT') this.marketData.btcPrice = parseFloat(data.c);
                this.manageOpenPositions();
                this.checkAutoCloseSignals();
            } 
            else if (streamType.startsWith('depth')) {
                this.orderBook = { 
                    bids: data.b.map(([p, q]) => [parseFloat(p), parseFloat(q)]), 
                    asks: data.a.map(([p, q]) => [parseFloat(p), parseFloat(q)]), 
                    lastUpdateId: data.u 
                };
                this.heatmapManager.draw(this.orderBook, this.marketData.price);
                if(this.settings.features.enableSpoofDetection) this.spoofDetector.trackOrderBook(this.orderBook);
                for (const key in this.strategies) {
                    if (this.strategies[key] && typeof this.strategies[key].analyzeOrderBook === 'function') {
                        this.strategies[key].analyzeOrderBook(this.orderBook);
                    }
                }
            } else if (streamType.startsWith('kline')) {
                if (this.candles.length > 0) {
                    const kline = data.k;
                    const lastCandleInArray = this.candles[this.candles.length - 1];
                    const currentCandleData = { time: kline.t, open: parseFloat(kline.o), high: parseFloat(kline.h), low: parseFloat(kline.l), close: parseFloat(kline.c), volume: parseFloat(kline.v) };
                    
                    if (lastCandleInArray && lastCandleInArray.time === currentCandleData.time) {
                        this.candles[this.candles.length - 1] = currentCandleData;
                    } else {
                         this.candles.push(currentCandleData);
                    }

                    this.chartManager.updateRealtime(kline);

                    if (kline.x) { // Mum kapandı
                        if (this.candles[this.candles.length -1].time !== currentCandleData.time) {
                            this.candles.push(currentCandleData);
                        }
                        if (this.candles.length > 501) this.candles.shift(); 
                        
                        this.checkPendingSignals(currentCandleData);
                        this.calculateAllIndicators(); 
                    }
                    this.manageOpenPositions();
                    this.checkAutoCloseSignals();
                }
            } else if (streamType === 'aggTrade') {
                const trade = { price: parseFloat(data.p), quantity: parseFloat(data.q), isBuyerMaker: data.m, timestamp: data.T };
                for (const key in this.strategies) {
                    if (this.strategies[key] && typeof this.strategies[key].processTrade === 'function') {
                        this.strategies[key].processTrade(trade);
                    }
                }
            }
        }
        
                runPeriodicAnalysis() { 
            if (!this.isRunning) return; 
            try {
                for (const key in this.strategies) {
                    if (this.strategies[key] && typeof this.strategies[key].periodicAnalyze === 'function') {
                        this.strategies[key].periodicAnalyze(); 
                    }
                }
                if (this.settings.features.enableRiskGuardian) this.riskGuardian.checkKillSwitch();

                // --- YENİ: SPOOF DETECTOR OPTİMİZASYONUNU ÇAĞIR ---
                if (this.settings.features.enableSpoofDetection) {
                    this.spoofDetector.checkConfirmations();
                    this.spoofDetector.autoOptimizeThreshold();
                }
                // --- BİTTİ ---

            } catch (error) {
                console.error('Periodic analysis error:', error);
                this.showNotification('Analiz hatası! Loglara bakın.', 'danger');
            }
        }

        
                calculateAllIndicators() {
            if (this.candles.length === 0) return;
            const rsiPeriod = this.settings.params.rsiPeriod;
            const atrPeriod = this.settings.params.atrPeriod;
            const bbandsPeriod = 20;

            const closes = this.candles.map(c => c.close);
            const highs = this.candles.map(c => c.high);
            const lows = this.candles.map(c => c.low);
            const volumes = this.candles.map(c => c.volume);
            const candleTimes = this.candles.map(c => c.time);

            // RSI
            if (closes.length >= rsiPeriod) {
                this.indicators.rsi = this.calculateRSI(closes, rsiPeriod);
            } else { this.indicators.rsi = []; } 

            // ATR
            if (this.candles.length >= atrPeriod) {
                this.indicators.atr = this.calculateATR(this.candles, atrPeriod);
            } else { this.indicators.atr = null; }

            // Bollinger Bands (ORİJİNAL HALİNE DÖNDÜRÜLDÜ)
            if (closes.length >= bbandsPeriod) {
                this.indicators.bbands = this.calculateBB(closes, candleTimes, bbandsPeriod, 2);
                this.chartManager.drawBollingerBands(this.indicators.bbands);
            } else { this.indicators.bbands = null; }

            const sma = (arr, n) => arr.length < n ? null : arr.slice(-n).reduce((a,b)=>a+b,0)/n;
            this.indicators.sma20 = sma(closes, 20);
            this.indicators.sma50 = sma(closes, 50);
            this.indicators.volSma20 = sma(volumes, 20);

            let cumPV = 0, cumV = 0;
            for (const k of this.candles) { const tp = (k.high + k.low + k.close)/3; cumPV += tp * k.volume; cumV += k.volume; }
            this.indicators.vwap = cumV ? (cumPV / cumV) : null;

            this.indicators.adx = this.calcADX(this.candles, atrPeriod);
            const adx = this.indicators.adx;
            if (adx) {
                if (adx.adx > 25) this.marketRegime = 'trend';
                else if (adx.adx < 20) this.marketRegime = 'range';
                else this.marketRegime = 'transition';
            } else { this.marketRegime = 'unknown'; }
        }


        calculateRSI(prices, period) {
            let gains = 0; let losses = 0;
            const rsi = [];
            let prevAvgGain = 0;
            let prevAvgLoss = 0;

            if (prices.length < period + 1) return [];

            for (let i = 1; i <= period; i++) {
                const diff = prices[i] - prices[i - 1];
                if (diff > 0) gains += diff; else losses -= diff;
            }
            prevAvgGain = gains / period;
            prevAvgLoss = losses / period;
            const initialRs = prevAvgLoss === 0 ? Infinity : prevAvgGain / prevAvgLoss;
            rsi.push(100 - (100 / (1 + initialRs))); 

            for (let i = period + 1; i < prices.length; i++) {
                const diff = prices[i] - prices[i - 1];
                const gain = diff > 0 ? diff : 0;
                const loss = diff < 0 ? -diff : 0;
                
                prevAvgGain = (prevAvgGain * (period - 1) + gain) / period;
                prevAvgLoss = (prevAvgLoss * (period - 1) + loss) / period;
                
                const rs = prevAvgLoss === 0 ? Infinity : prevAvgGain / prevAvgLoss;
                const rsiValue = 100 - (100 / (1 + rs));
                rsi.push(rsiValue);
            }
            return rsi;
        }

        calculateATR(candles, period) {
            if (candles.length < period + 1) return null;
            let trs = [];
            for (let i = 1; i < candles.length; i++) {
                const c = candles[i], p = candles[i - 1];
                trs.push(Math.max(c.high - c.low, Math.abs(c.high - p.close), Math.abs(c.low - p.close)));
            }
            if (trs.length < period) return null;
            
            let atr = trs.slice(0, period).reduce((a, b) => a + b, 0) / period;

            for (let i = period; i < trs.length; i++) {
                atr = (atr * (period - 1) + trs[i]) / period;
            }
            return atr;
        }

              calculateBB(prices, times, period, stdDev) {
            const result = { upper: [], middle: [], lower: [] };
            if (prices.length < period) return null;

            for (let i = period - 1; i < prices.length; i++) {
                const slice = prices.slice(i - period + 1, i + 1);
                const sma = slice.reduce((a, b) => a + b, 0) / period;
                const std = Math.sqrt(
                    slice.map(p => Math.pow(p - sma, 2)).reduce((a, b) => a + b, 0) / period
                );
                result.middle.push({ time: times[i], value: sma });
                result.upper.push({ time: times[i], value: sma + (std * stdDev) });
                result.lower.push({ time: times[i], value: sma - (std * stdDev) });
            }
            return result;
        }



        calcADX(candles, period = 14) {
            if (!candles || candles.length < period * 2) return null; 
            const trs = [], plusDMs = [], minusDMs = [];
            for (let i = 1; i < candles.length; i++) {
                const c = candles[i], p = candles[i-1];
                trs.push(Math.max(c.high - c.low, Math.abs(c.high - p.close), Math.abs(c.low - p.close)));
                const upMove = c.high - p.high;
                const downMove = p.low - c.low;
                plusDMs.push((upMove > downMove && upMove > 0) ? upMove : 0);
                minusDMs.push((downMove > upMove && downMove > 0) ? downMove : 0);
            }
            const smooth = (arr) => {
                const smoothed = [arr.slice(0, period).reduce((a, b) => a + b, 0) / period];
                for (let i = period; i < arr.length; i++) {
                    smoothed.push((smoothed[smoothed.length - 1] * (period - 1) + arr[i]) / period);
                }
                return smoothed;
            };
            const sTR = smooth(trs);
            const sPlusDM = smooth(plusDMs);
            const sMinusDM = smooth(minusDMs);

            if (sTR.length === 0 || sPlusDM.length === 0 || sMinusDM.length === 0) return null;

            const plusDIs = sPlusDM.map((val, idx) => 100 * (val / (sTR[idx] || 1e-8)));
            const minusDIs = sMinusDM.map((val, idx) => 100 * (val / (sTR[idx] || 1e-8)));
            
            const dxs = plusDIs.map((pdi, idx) => 100 * Math.abs(pdi - minusDIs[idx]) / ((pdi + minusDIs[idx]) || 1e-8));
            
            if (dxs.length < period) return null;

            const adxValues = smooth(dxs.slice(period - 1));
            
            if (!adxValues || adxValues.length === 0) return null;
            return {
                adx: adxValues[adxValues.length-1],
                pdi: plusDIs[plusDIs.length-1],
                mdi: minusDIs[minusDIs.length-1]
            };
        }

        getOrderBookSnapshotInfo() {
            const ob = this.orderBook;
            if (!ob || !ob.bids || ob.bids.length === 0 || !ob.asks || ob.asks.length === 0) return null;
            const bestBid = ob.bids[0][0], bestAsk = ob.asks[0][0];
            const mid = (bestAsk + bestBid)/2;
            const spreadPct = (bestAsk - bestBid) / mid;
            const topN = this.settings.optimization.gating.topN || 5;
            const sumUsd = (levels) => levels.slice(0, topN).reduce((s,[p,q])=> s + (p*q), 0);
            const topBidUsd = sumUsd(ob.bids);
            const topAskUsd = sumUsd(ob.asks);
            const minTopUsd = Math.min(topBidUsd, topAskUsd);
            return { spreadPct, minTopUsd };
        }
        marketGatingPenalty(direction) {
            const info = this.getOrderBookSnapshotInfo();
            if (!info || !this.settings.optimization.gating.enabled) return 0;
            const g = this.settings.optimization.gating;
            let penalty = 0;
            if (info.spreadPct > g.spreadMaxPct) penalty += 1.5; 
            if (info.minTopUsd < g.minDepthUsd) penalty += 1.5; 
            return penalty;
        }

        getEffectiveThreshold() { return (this.settings.confluenceThreshold || 3) + (this.runtimeThresholdOffset || 0); }

        calculateDynamicTpSl(signal) {
            const atr = this.indicators.atr;
            let rrRatioBase = this.settings.params.rrRatio;
            const minTh = this.getEffectiveThreshold();
            const over = Math.max(0, (signal.score - minTh));
            rrRatioBase *= (1 + Math.min(0.3, over / 10)); 

            if (this.marketRegime === 'trend') rrRatioBase *= 1.1;
            if (this.marketRegime === 'range') rrRatioBase *= 0.95;

            if (!atr || atr === 0) { 
                signal.tp = signal.direction === 'buy' ? signal.price * (1 + 0.005) : signal.price * (1 - 0.005);
                signal.sl = signal.direction === 'buy' ? signal.price * (1 - 0.005 / rrRatioBase) : signal.price * (1 + 0.005 / rrRatioBase);
            } else {
                const atrMultiplier = 1.5 - (Math.min(10, Math.max(0, signal.score)) / 20);
                const slDistance = atr * atrMultiplier;
                const tpDistance = slDistance * rrRatioBase;
                if (signal.direction === 'buy') { signal.sl = signal.price - slDistance; signal.tp = signal.price + tpDistance; }
                else { signal.sl = signal.price + slDistance; signal.tp = signal.price - tpDistance; }
                signal.entrySlDistance = slDistance;
                signal.entryTpDistance = tpDistance;
            }
        }

        manageOpenPositions() {
            if (!this.isRunning || !this.marketData.price || !this.settings.optimization.breakeven.enabled) return;
            const price = this.marketData.price;
            const atr = this.indicators.atr;
            if (!atr) return; 

            let changed = false;
            const activeSignals = this.signals.filter(s => s.status === 'active' && s.symbol === this.currentSymbol);
            for (const s of activeSignals) {
                if (!s.entrySlDistance || s.entrySlDistance <= 0) continue; 
                const rNow = s.direction === 'buy' ? (price - s.price) / s.entrySlDistance : (s.price - price) / s.entrySlDistance;
                s.mfeR = Math.max(s.mfeR || 0, rNow); 
                const settings = this.settings.optimization.breakeven;

                if (!s.beDone && s.mfeR >= (settings.beAtR || 0.8)) {
                    s.sl = s.price; 
                    s.beDone = true;
                    s.note = (s.note ? s.note + ' | ' : '') + 'SL->BE';
                    changed = true;
                    this.showNotification(`Sinyal ${s.id.substring(4,10)} için SL maliyete çekildi.`, 'info');
                }
                if (s.mfeR >= (settings.trailAfterR || 1.5) && (s.trailingStage || 0) < 1) {
                    let newSl;
                    if (s.direction === 'buy') {
                        newSl = price - (atr * settings.trailToR); 
                        s.sl = Math.min(s.tp, Math.max(s.sl, newSl)); 
                    } else { 
                        newSl = price + (atr * settings.trailToR); 
                        s.sl = Math.max(s.tp, Math.min(s.sl, newSl)); 
                    }
                    s.trailingStage = 1;
                    s.note = (s.note ? s.note + ' | ' : '') + 'Trail1';
                    changed = true;
                    this.showNotification(`Sinyal ${s.id.substring(4,10)} için SL güncellendi (Trailing).`, 'info');
                }
            }
            if (changed) { this.saveData('utc_signals', this.signals); this.debouncedRender(); }
        }

        checkAutoCloseSignals() {
            if (!this.isRunning || !this.marketData.price) return;
            const price = this.marketData.price;
            const activeSignals = this.signals.filter(s => s.status === 'active' && s.symbol === this.currentSymbol);
            for (const s of activeSignals) {
                if (s.direction === 'buy') {
                    if (price >= s.tp) { this.updateSignalResult(s.id, 'tp'); }
                    else if (price <= s.sl) { this.updateSignalResult(s.id, 'sl'); }
                } else if (s.direction === 'sell') {
                    if (price <= s.tp) { this.updateSignalResult(s.id, 'tp'); }
                    else if (price >= s.sl) { this.updateSignalResult(s.id, 'sl'); }
                }
            }
        }

        render() { 
            this.renderPriceDisplay(); 
            this.updateSignalProgressBar(); 
        }
        renderPriceDisplay() {
            const priceEl = document.getElementById('current-price');
            const tickerPriceEl = document.getElementById('ticker-bar-price');
            const oldPriceText = tickerPriceEl ? tickerPriceEl.textContent.replace(/,/g, '') : '0';
            const oldPrice = parseFloat(oldPriceText);
            
            if (this.marketData.price) {
                const formattedPrice = this.formatPrice(this.marketData.price);
                if (priceEl) priceEl.textContent = formattedPrice;
                if(tickerPriceEl) tickerPriceEl.textContent = formattedPrice;

                if (!isNaN(oldPrice) && oldPrice !== 0) { 
                    const color = this.marketData.price > oldPrice ? 'var(--positive)' : (this.marketData.price < oldPrice ? 'var(--negative)' : '');
                    if (tickerPriceEl) {
                        tickerPriceEl.style.transition = 'none';
                        tickerPriceEl.style.color = color;
                        setTimeout(() => {
                           tickerPriceEl.style.transition = 'color 0.5s ease';
                           tickerPriceEl.style.color = '';
                        }, 100);
                    }
                }
            }
            const change = this.marketData.change24h || 0;
            const changeEl = document.getElementById('price-change-24h');
            if (changeEl) { changeEl.textContent = `${change.toFixed(2)}%`; changeEl.style.color = change >= 0 ? 'var(--positive)' : 'var(--negative)'; }
            const volumeEl = document.getElementById('volume-24h'); if(volumeEl) volumeEl.textContent = this.formatVolume(this.marketData.volume24h);
            const atrEl = document.getElementById('atr-value'); if(atrEl) atrEl.textContent = this.indicators.atr ? this.indicators.atr.toFixed(this.getDecimalPlaces(this.indicators.atr)) : '-';
        }

        updateCandleCountdown() {
            const headerCountdownEl = document.getElementById('candle-countdown');
            const chartCountdownEl = document.getElementById('chart-countdown-overlay');

            if (!this.isRunning || this.candles.length === 0) {
                headerCountdownEl.textContent = '--:--';
                chartCountdownEl.textContent = '--:--';
                return;
            }
            const now = Date.now();
            const lastCandleOpenTime = this.candles[this.candles.length - 1].time; 
            const timeframeMs = this._timeframeToMs(this.currentTimeframe);
            
            const nextCandleOpenTime = lastCandleOpenTime + timeframeMs;
            let remainingTime = nextCandleOpenTime - now;
            
            if (remainingTime < 0 || remainingTime > timeframeMs) {
                 remainingTime = timeframeMs - (now % timeframeMs);
            }

            remainingTime = Math.max(0, remainingTime); 
            const minutes = Math.floor(remainingTime / 60000);
            const seconds = Math.floor((remainingTime % 60000) / 1000);
            const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            headerCountdownEl.textContent = formattedTime;
            if (this.currentMainView === 'chart' || document.body.classList.contains('fullscreen-chart')) {
                chartCountdownEl.textContent = formattedTime;
                chartCountdownEl.classList.remove('hidden-view');
            } else {
                chartCountdownEl.classList.add('hidden-view');
            }
        }
         _timeframeToMs(tf) {
            const unit = tf.slice(-1);
            const val = parseInt(tf.slice(0, -1));
            if (unit === 'm') return val * 60 * 1000;
            if (unit === 'h') return val * 60 * 60 * 1000;
            if (unit === 'd') return val * 24 * 60 * 60 * 1000;
            return 60000;
        }

        updateSignalProgressBar() {
            const buyFill = document.getElementById('buy-signal-bar-fill');
            const sellFill = document.getElementById('sell-signal-bar-fill');
            const buyScoreText = document.getElementById('buy-signal-score-text');
            const sellScoreText = document.getElementById('sell-signal-score-text');
            if (!buyFill || !sellFill || !buyScoreText || !sellScoreText) return;

            const maxScoreForDisplay = 10; 
            const buyScore = this.confluenceEngine.buyScore || 0;
            const sellScore = this.confluenceEngine.sellScore || 0;

            const buyPercent = Math.min(100, Math.max(0, (buyScore / maxScoreForDisplay) * 100));
            const sellPercent = Math.min(100, Math.max(0, (sellScore / maxScoreForDisplay) * 100));

            buyFill.style.width = `${buyPercent}%`;
            sellFill.style.width = `${sellPercent}%`;

            buyScoreText.textContent = isFinite(buyScore) ? buyScore.toFixed(1) : '0.0';
            sellScoreText.textContent = isFinite(sellScore) ? sellScore.toFixed(1) : '0.0';
        }

        addPendingSignal(signal) {
            this.pendingSignals.push(signal);
            this.chartManager.addSignalMarker(signal);
            this.showNotification(`ADAY SİNYAL: ${signal.direction.toUpperCase()} ${signal.symbol.replace('USDT', '/USDT')} | Skor: ${signal.score.toFixed(1)}. Mum kapanışı bekleniyor.`, 'warning', 4000);
        }

        checkPendingSignals(closedCandle) {
            const signalsToActivate = [];
            this.pendingSignals = this.pendingSignals.filter(signal => {
                if (signal.timestamp < closedCandle.time) {
                    let isValid = false;
                    if (signal.direction === 'buy' && closedCandle.close > closedCandle.open) {
                        isValid = true;
                    } else if (signal.direction === 'sell' && closedCandle.close < closedCandle.open) {
                        isValid = true;
                    }
                    
                    if (isValid) {
                        signalsToActivate.push(signal);
                    } else {
                        this.showNotification(`İPTAL: ${signal.direction.toUpperCase()} sinyali mum kapanışında onaylanmadı.`, 'danger', 3000);
                    }
                    return false;
                }
                return true;
            });
            signalsToActivate.forEach(signal => this.activateSignal(signal));
        }

        activateSignal(signal) {
            // Confluence Engine'den sinyali doğrula
            if (this.confluenceEngine && !this.confluenceEngine.validateSignal(signal)) {
                this.showNotification(`SİNYAL REDDEDİLDİ: Confluence puanı yetersiz`, 'warning', 3000);
                return;
            }
            
            signal.status = 'active';
            this.signals.unshift(signal); 
            if (this.signals.length > 200) this.signals.pop();
            
            // Verileri kaydet
            this.saveData('utc_signals', this.signals);
            
            // Veritabanına sinyali kaydet
            if (this.dbManager && this.dbManager.ready) {
                this.dbManager.put('signals', {
                    ...signal,
                    savedAt: Date.now()
                });
            }
            
            // UI'yi güncelle
            this.debouncedRender();
            this.chartManager.addSignalMarker(signal);
            
            // Bildirim göster
            let sizeText = signal.recommendedSize ? ` | Boyut: ${signal.recommendedSize}` : '';
            this.showNotification(`AKTİF SİNYAL: ${signal.direction.toUpperCase()} ${signal.symbol.replace('USDT', '/USDT')} | Skor: ${signal.score.toFixed(1)}${sizeText}`, signal.direction === 'buy' ? 'success' : 'danger');
            
            // Ses efektleri
            playSignal(signal.direction); 
            const messageKey = signal.direction === 'buy' ? 'buy' : 'sell';
            const message = this.getRandomMessage(messageKey, { 
                Sembol: signal.symbol.replace('USDT', ''), 
                Skor: signal.score.toFixed(1) 
            });
            this.speak(message);
            
            // Yüksek skorlu sinyal için savaş modunu aktifleştir
            if (signal.score >= 8 && !this.combatModeActive) { 
                this.activateCombatMode(); 
            }
            
            // Görsel efektler
            if (this.effectsManager) {
                const pricePos = this.chartManager?.getPriceCoordinateForTimestamp(signal.timestamp) || {
                    x: window.innerWidth / 2,
                    y: window.innerHeight / 2
                };
                
                this.effectsManager.createExplosionEffect(
                    pricePos.x, 
                    pricePos.y, 
                    signal.direction === 'buy' ? '#00ff00' : '#ff0000',
                    signal.score * 3 // Skor ne kadar yüksekse, o kadar büyük patlama efekti
                );
            }
            
            // Panteon sistemine güç ekle
            if (this.panteonManager) {
                // Stratejiye göre farklı elçilere güç ekle
                this.panteonManager.awardPowerForSignal(signal);
            }
            
            // Event'i emit et
            this.emit('signal', signal);
            
            // Oracle ile entegrasyon - Mahşerin Atlıları aktifse ek bildirim göster
            if (this.oracle && this.oracle.isAnyHorsemanActive()) {
                const activeHorsemen = this.oracle.getActiveHorsemen();
                const horsemanNames = activeHorsemen.map(key => this.oracle.getHorsemanName(key)).join(", ");
                
                setTimeout(() => {
                    this.showNotification(`DİKKAT: Mahşerin ${activeHorsemen.length > 1 ? 'Atlıları' : 'Atlısı'} (${horsemanNames}) aktif! Risk yüksek olabilir.`, 'warning', 5000);
                }, 1000);
            }
        }

        getRecommendedPositionSize(score) {
            if(!this.settings.features.enableDynamicSizing) return null;
            if (score >= 7.5) return "2.0x Yüksek";
            if (score >= 6.0) return "1.5x Orta-Yüksek";
            if (score >= 4.5) return "1.0x Standart";
            return "0.5x Düşük";
        }

        updateSignalResult(signalId, result) {
            const signalIndex = this.signals.findIndex(s => s.id === signalId);
            if(signalIndex !== -1 && this.signals[signalIndex].status === 'active') {
                const signal = this.signals[signalIndex];
                signal.status = result;
                signal.completedAt = Date.now();
                this.stats.total++;
                this.stats[result]++;
                
                // İstatistikleri güncelle
                this.updateStrategyStats(signal);
                this.updateStrategyShadowStats(signal);
                this.evaluateShadowRehab();
                
                // Veritabanında güncelle
                if (this.dbManager && this.dbManager.ready) {
                    // Sinyali güncelle
                    this.dbManager.put('signals', {
                        ...signal,
                        updatedAt: Date.now()
                    });
                    
                    // İstatistikleri güncelle
                    this.dbManager.put('stats', {
                        id: 'global',
                        data: this.stats,
                        updatedAt: Date.now()
                    });
                }
                
                // Event'i emit et
                this.emit('signalResult', { signal, result });
                
                // Panteon sistemine sonuç bildir
                if (this.panteonManager) {
                    if (result === 'tp') {
                        // Başarılı sinyal için daha fazla güç
                        this.panteonManager.increasePower('metatron', 10);
                        
                        // Başarılı bir sinyal için efekt
                        if (this.effectsManager) {
                            this.effectsManager.createMatrixEffect();
                        }
                    } else if (result === 'sl') {
                        // Kaybedilen sinyal için şifacıya güç
                        this.panteonManager.increasePower('raphael', 5);
                    }
                }

                if (this.settings.features.enableCUSUMDrift) {
                    const driftDetected = this.cusumDetector.update(result === 'tp');
                    if (driftDetected) {
                        this.showNotification('PERFORMANS SAPMASI!', 'Sinyal kazanma oranında sapma tespit edildi. Ayarlar optimize ediliyor...', 'warning');
                        this.speak(this.getRandomMessage('cusumDriftDetected'));
                    }
                }

                this.saveData('utc_signals', this.signals);
                this.saveData('utc_stats', this.stats);
                this.debouncedRender();
                this.showNotification(`Sinyal ${signal.id.substring(4,10)} - ${result.toUpperCase()} olarak sonuçlandı.`, 'info');
                const messageKey = result === 'tp' ? 'signalTP' : 'signalSL';
                this.speak(this.getRandomMessage(messageKey));
            }
        }

        updateStrategyStats(signal) {
            const isWin = signal.status === 'tp';
            const contributors = signal.contributors || [];
            if(contributors.length === 0) return;
            const totalEff = contributors.reduce((s, c) => s + (c.effScore || (c.baseScore * (c.weight||1))), 0) || 1;
            const decay = 0.995; 

            for (const c of contributors) {
                let stratStats = this.strategyStats[c.strategy];
                if (!stratStats) {
                    stratStats = this.initDefaultStrategyStats()[c.strategy];
                    this.strategyStats[c.strategy] = stratStats;
                }
                
                const updateStat = (statObj) => {
                    statObj.alpha = (statObj.alpha || 3) * decay; 
                    statObj.beta = (statObj.beta || 2) * decay;   
                    const credit = (c.effScore || (c.baseScore * (c.weight || 1))) / totalEff; 
                    statObj.contrib = (statObj.contrib || 0) + 1;
                    if (isWin) { statObj.wins = (statObj.wins || 0) + credit; statObj.alpha += credit; }
                    else { statObj.losses = (statObj.losses || 0) + credit; statObj.beta += credit; }
                    statObj.lastUpdate = Date.now();
                };

                updateStat(stratStats.overall);
                const currentRegimeStats = stratStats[this.marketRegime];
                if (currentRegimeStats) {
                    updateStat(currentRegimeStats);
                }
            }
            this.saveStrategyStats();
        }

        recordShadowProposal(strategy, direction, reason, score) {
            const now = Date.now();
            this.shadowProposals.push({ strategy, direction, reason, score, timestamp: now });
            if (this.shadowProposals.length > 2000) this.shadowProposals.splice(1500); 
        }

        updateStrategyShadowStats(signal) {
            const windowMs = (this.settings.cooldowns?.proposalTimeoutMs || 3000) * 2;
            const start = signal.timestamp - windowMs;
            const end = signal.timestamp;
            const creditBase = 0.5;

            const byStrat = {};
            for (const p of this.shadowProposals) {
                if (p.timestamp >= start && p.timestamp <= end && p.direction === signal.direction) {
                    byStrat[p.strategy] = p;
                }
            }
            for (const strat of Object.keys(byStrat)) {
                let stratStats = this.strategyStats[strat];
                if (!stratStats) {
                    stratStats = this.initDefaultStrategyStats()[strat];
                    this.strategyStats[strat] = stratStats;
                }
                
                const updateStat = (statObj) => {
                    statObj.shadowProposals = (statObj.shadowProposals || 0) + 1;
                    if (signal.status === 'tp') {
                        statObj.shadowWins = (statObj.shadowWins || 0) + 1;
                        statObj.alpha = (statObj.alpha || 3) + creditBase;
                    } else if (signal.status === 'sl') {
                        statObj.shadowLosses = (statObj.shadowLosses || 0) + 1;
                        statObj.beta = (statObj.beta || 2) + creditBase;
                    }
                    statObj.lastUpdate = Date.now();
                };
                
                updateStat(stratStats.overall);
                const currentRegimeStats = stratStats[this.marketRegime];
                if (currentRegimeStats) {
                    updateStat(currentRegimeStats);
                }
            }
            const keepAfter = Date.now() - 10 * 60 * 1000;
            this.shadowProposals = this.shadowProposals.filter(p => p.timestamp >= keepAfter);
            this.saveStrategyStats();
        }

                evaluateShadowRehab() {
            const pen = this.settings.penalties || {};
            if (!pen.shadowEnabled) return;

            for (const key of this.allStrategyKeys) {
                if (!this.settings.statusMaps.shadowBanned[key] || this.settings.statusMaps.hardBanned[key]) continue;

                const st = this.strategyStats[key]?.overall || {};
                const sw = st.shadowWins || 0,
                    sl = st.shadowLosses || 0,
                    sp = st.shadowProposals || 0;
                const total = sw + sl;
                const winRate = total > 0 ? sw / total : 0;

                if (sp >= (pen.minShadowProposals || 20) && winRate >= (pen.rehabWinRate || 0.58)) {
                    this.settings.activeStrategies[key] = true;
                    this.settings.statusMaps.shadowBanned[key] = false;
                    this.updateActiveStrategies();
                    this.saveSettings();
                    this.showNotification(`Rehabilite: ${this.strategies[key].displayName} tekrar canlı! (gölge WR=${(winRate*100).toFixed(0)}%)`, 'success');
                    
                    // --- EKSİK OLAN SATIR BURAYA EKLENDİ ---
                    this.speak(this.getRandomMessage('shadowRehab', { 'Strateji': this.strategies[key].displayName }));
                }
            }
        }


                autoToggleStrategies() {
            if (!this.settings.optimization.enabled || !this.settings.optimization.autoToggle) return;
            const now = Date.now();
            if (now - this.lastAutoToggleTs < 5 * 60 * 1000) return;
            this.lastAutoToggleTs = now;
            const minW = this.settings.optimization.minWeightToStay || 0.6;
            const minContrib = this.settings.optimization.minContribForToggle || 30;

            let changed = false;
            for (const key of this.allStrategyKeys) {
                const w = this.getStrategyWeight(key);
                const stat = this.strategyStats[key]?.overall || {};
                const active = !!this.settings.activeStrategies[key];

                if (active && !this.settings.statusMaps.hardBanned[key] && w < minW && (stat.contrib || 0) >= minContrib) {
                    this.settings.activeStrategies[key] = false;
                    this.settings.statusMaps.shadowBanned[key] = true;
                    this.showNotification(`Oto-optimizasyon: ${this.strategies[key].displayName} gölgeye alındı (w=${w.toFixed(2)}).`, 'warning');
                    
                    // --- EKSİK OLAN SATIR BURAYA EKLENDİ ---
                    this.speak(this.getRandomMessage('shadowBan', { 'Strateji': this.strategies[key].displayName }));
                    
                    changed = true;
                }
            }
            if (changed) {
                this.updateActiveStrategies();
                this.saveSettings();
                this.updateSettingsModalUI();
            }
        }


        autoTuneCooldowns() {
            if (!this.isRunning || !this.settings.optimization.enabled) return;
            const now = Date.now();
            const WINDOW_MS = 5 * 60 * 1000; 
            const recentSignals = this.signals.filter(s => s.status !== 'active' && s.symbol === this.currentSymbol && now - s.timestamp <= WINDOW_MS).slice(0, 50).sort((a,b)=> a.timestamp - b.timestamp);
            let quickFlips = 0, totalPairs = 0;
            if (recentSignals.length >= 2) {
                for (let i = 1; i < recentSignals.length; i++) {
                    totalPairs++;
                    const dt = recentSignals[i].timestamp - recentSignals[i-1].timestamp;
                    if (recentSignals[i-1].direction !== recentSignals[i].direction && dt <= 15000) { 
                        quickFlips++;
                    }
                }
            }
            const flipRatio = totalPairs ? (quickFlips / totalPairs) : 0;
            const volPct = (this.indicators.atr && this.marketData.price) ? (this.indicators.atr / this.marketData.price) : 0.001;

            const cd = this.settings.cooldowns;
            const baseSame = this.loadSettings().cooldowns.sameDirectionMs;
            const baseOpp = this.loadSettings().cooldowns.oppositeDirectionMs;
            const baseSignal = this.loadSettings().cooldowns.signalMs;
            const baseProposalTimeout = this.loadSettings().cooldowns.proposalTimeoutMs;

            const newSame = Math.max(10000, Math.min(120000, Math.round(baseSame * (1 + flipRatio * 0.8))));
            const newOpp  = Math.max(5000, Math.min(120000, Math.round(baseOpp  * (1 + flipRatio * 1.2))));
            const volFactor = volPct < 0.005 ? 1.2 : (volPct > 0.02 ? 0.8 : 1.0);
            const newSignal = Math.max(3000, Math.min(60000, Math.round(baseSignal * volFactor)));
            const newProposalTimeout = Math.max(1500, Math.min(8000, Math.round(baseProposalTimeout * volFactor)));

            let changed = false;
            if (Math.abs(newSame - cd.sameDirectionMs) / cd.sameDirectionMs > 0.05) { cd.sameDirectionMs = newSame; changed = true; }
            if (Math.abs(newOpp - cd.oppositeDirectionMs) / cd.oppositeDirectionMs > 0.05) { cd.oppositeDirectionMs = newOpp; changed = true; }
            if (Math.abs(newSignal - cd.signalMs) / cd.signalMs > 0.05) { cd.signalMs = newSignal; changed = true; }
            if (Math.abs(newProposalTimeout - cd.proposalTimeoutMs) / cd.proposalTimeoutMs > 0.05) { cd.proposalTimeoutMs = newProposalTimeout; changed = true; }

            if (changed) {
                this.saveSettings();
                this.updateSettingsModalUI(); 
                this.showNotification(`Cooldown optimize edildi (flip: ${(flipRatio*100).toFixed(0)}%, vol: ${(volPct*100).toFixed(2)}%).`, 'info');
                this.speak(this.getRandomMessage('cooldownOptimize'));
            }
        }

        autoTuneThresholds() {
            if (!this.isRunning || !this.settings.optimization.enabled) return;
            const now = Date.now();
            const WINDOW_MS = 10 * 60 * 1000;
            const recentSignals = this.signals.filter(s => s.status !== 'active' && s.symbol === this.currentSymbol && now - s.timestamp <= WINDOW_MS).slice(0, 100);
            
            let winRate = recentSignals.length > 5 ? (recentSignals.filter(s => s.status === 'tp').length / recentSignals.length) : 0.55;
            let currentOffset = this.runtimeThresholdOffset || 0;
            let newOffset = currentOffset;

            if (winRate < 0.50) newOffset += 0.1;
            else if (winRate > 0.65) newOffset -= 0.1;
            
            newOffset = Math.max(-1.0, Math.min(2.0, newOffset));

            if (Math.abs(newOffset - currentOffset) > 0.05) {
                this.runtimeThresholdOffset = parseFloat(newOffset.toFixed(1));
                this.showNotification(`Sinyal eşiği optimize edildi: Yeni Ofset ${this.runtimeThresholdOffset.toFixed(1)} (WR: ${(winRate*100).toFixed(1)}%).`, 'info');
            }
        }

        autoTuneStrategyParams() {
            if (!this.settings.optimization.enabled) return;
            const step = 0.05;
            const meta = {
                wallBounce: { DISTANCE_THRESHOLD_PERCENT: {min:0.0001,max:0.001, strict:'down'} },
                velocityScalping: { VELOCITY_THRESHOLD_PERCENT:{min:0.0005,max:0.003, strict:'up'} },
                liquidityGaps: { GAP_THRESHOLD_PERCENT:{min:0.0003,max:0.003, strict:'up'} },
                breakoutPattern: { BREAK_PCT:{min:0.0001,max:0.001, strict:'up'}, VOL_SPIKE:{min:1.0,max:3.0, strict:'up'} },
                supportResistance: { THRESH:{min:0.0005,max:0.005, strict:'down'} },
                fibonacciRetracement: { TOL:{min:0.0005,max:0.005, strict:'down'} },
                vwapReversion: { MULT:{min:0.6,max:2.0, strict:'up'} },
                superTrend: { MULT:{min:1.0,max:6.0, strict:'up'} },
                marketStructure: { SWING:{min:2,max:7, strict:'up'} },
                institutionalOrderFlow: { IMB_THRESHOLD:{min:1.2,max:4.0, strict:'up'} },
                microSpreadArbitrage: { SPREAD_PCT:{min:0.0003,max:0.003, strict:'up'} },
                volumeProfile: { PERIOD: 20, SPIKE: 2.0, CLOSE_POS: 0.7 },
                divergenceDetection: { SWING_PERIOD:{min:2,max:5, strict:'up'} },
                volatilityBreakout: { SQUEEZE_MULT: {min:0.5,max:2.0, strict:'up'}, BREAKOUT_VOL_MULT: {min:1.0,max:3.0, strict:'up'} },
                candleCharacter: { MIN_BODY_TO_WICK_RATIO: {min:0.4,max:0.8, strict:'up'}, ANALYSIS_WINDOW_PERCENT: {min:0.1,max:0.3, strict:'down'} },
                fundingRateReversal: { EXTREME_FUNDING_THRESHOLD: {min:0.0005,max:0.002, strict:'up'} }
            };

            const p = this.settings.strategyParams;
            let changed = false;

            for (const key of Object.keys(this.strategies)) {
                const w = this.getStrategyWeight(key);
                const defs = meta[key]; if (!defs) continue;
                const currentParams = p[key] || {}; 
                let localChanged = false;
                const direction = (w < 0.7) ? 'moreStrict' : (w > 1.3 ? 'lessStrict' : 'keep');
                if (direction === 'keep') continue;

                for (const par of Object.keys(defs)) {
                    const conf = defs[par]; 
                    const val = currentParams[par] ?? this.strategies[key][par];
                    if (val == null) continue;

                    let newVal = val;
                    if (direction === 'moreStrict') {
                        if (conf.strict === 'up') newVal = val * (1 + step);
                        else if (conf.strict === 'down') newVal = val * (1 - step);
                    } else if (direction === 'lessStrict') {
                        if (conf.strict === 'up') newVal = val * (1 - step);
                        else if (conf.strict === 'down') newVal = val * (1 + step);
                    }
                    newVal = Math.max(conf.min, Math.min(conf.max, newVal));
                    
                    if (Math.abs(newVal - val) / Math.max(1e-8, val) > 0.001) {
                        currentParams[par] = Number.isInteger(val) ? Math.round(newVal) : parseFloat(newVal.toPrecision(4));
                        localChanged = true;
                    }
                }
                if (localChanged) { 
                    p[key] = currentParams; 
                    changed = true; 
                }
            }

            if (changed) {
                this.saveSettings();
                this.applyStrategyParamOverrides();
                this.showNotification('Strateji parametreleri mikro-optimize edildi (ameliyat).', 'warning');
            }
        }

        // DÜZELTME: Render fonksiyonları debounce ile çağrılacak
        debouncedRender() {
            clearTimeout(this.renderTimeout);
            this.renderTimeout = setTimeout(() => {
                this.renderSignals(true);
                this.renderStats(true);
            }, 200);
        }

        renderSignals(fullRender = false) {
            const tbody = document.getElementById('modal-signals-body');
            if (!tbody) return;
            if (fullRender) tbody.innerHTML = '';
            
            const signalsToRender = this.signals;

            signalsToRender.forEach((signal, index) => {
                const rowId = `signal-row-${signal.id}`;
                let row = document.getElementById(rowId);
                if(fullRender || !row) { 
                    if (row) row.remove();
                    row = tbody.insertRow(fullRender ? -1 : 0); // Tam render ise sona, değilse başa ekle
                    row.id = rowId;
                    for(let i=0; i<11; i++) row.insertCell();
                }

                row.className = signal.status === 'tp' ? 'signal-tp' : (signal.status === 'sl' ? 'signal-sl' : (signal.status === 'pending' ? 'signal-pending' : ''));
                row.cells[0].textContent = new Date(signal.timestamp).toLocaleTimeString();
                row.cells[1].textContent = signal.symbol.replace('USDT', '');
                row.cells[2].textContent = signal.direction.toUpperCase();
                row.cells[3].textContent = this.formatPrice(signal.price);
                row.cells[4].textContent = signal.tp ? this.formatPrice(signal.tp) : '-';
                row.cells[5].textContent = signal.sl ? this.formatPrice(signal.sl) : '-';
                row.cells[6].textContent = typeof signal.score === 'number' ? signal.score.toFixed(1) : signal.score;
                row.cells[7].textContent = signal.reason;
                row.cells[8].textContent = signal.recommendedSize || '-';
                row.cells[9].textContent = signal.status.toUpperCase();
                row.cells[10].textContent = signal.note || '';
            });
        }

        renderStats() {
            const statsContainer = document.getElementById('modal-stats-container');
            if (!statsContainer) return;

            const total = this.stats.total;
            const tp = this.stats.tp;
            const winRate = total > 0 ? ((tp / total) * 100).toFixed(1) : '0.0';

            const getWR = (stat) => {
                if (!stat) return '-';
                const totalObs = (stat.wins || 0) + (stat.losses || 0);
                if (totalObs === 0) return '-';
                return (((stat.wins || 0) / totalObs) * 100).toFixed(0);
            };

            const renderRegimeStats = (regime) => {
                let regimeTotal = 0, regimeWins = 0;
                Object.values(this.strategyStats).forEach(s => {
                    const stat = s[regime]; 
                    if(stat && (stat.wins !== undefined || stat.losses !== undefined)) { 
                        regimeWins += (stat.wins || 0);
                        regimeTotal += ((stat.wins || 0) + (stat.losses || 0));
                    }
                });
                const wr = regimeTotal > 0 ? (regimeWins / regimeTotal * 100).toFixed(0) : 'N/A';
                return `<div class="stat-item"><span class="stat-label">${regime.charAt(0).toUpperCase() + regime.slice(1)} WR:</span><span class="stat-value">${wr}%</span></div>`;
            };

            const html = `
                <div class="panel-title" style="margin-bottom: 10px;">Genel Sinyal İstatistikleri</div>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 0 15px;">
                    <div class="stat-item"><span class="stat-label">Toplam Sinyal:</span><span class="stat-value">${total}</span></div>
                    <div class="stat-item"><span class="stat-label">TP (Kazanılan):</span><span class="stat-value" style="color:var(--positive);">${tp}</span></div>
                    <div class="stat-item"><span class="stat-label">SL (Kaybedilen):</span><span class="stat-value" style="color:var(--negative);">${this.stats.sl}</span></div>
                    <div class="stat-item"><span class="stat-label">Kazanma Oranı:</span><span class="stat-value" style="color:${winRate >= 50 ? 'var(--positive)' : 'var(--negative)'};">${winRate}%</span></div>
                    ${renderRegimeStats('trend')}
                    ${renderRegimeStats('range')}
                </div>
                <div class="panel-title" style="margin-top: 15px; margin-bottom: 10px;">Strateji Performansı (Rejime Göre)</div>
                <div class="data-table-container" style="max-height: 250px;">
                    <table class="data-table">
                        <thead><tr><th>Strateji</th><th>Ağırlık</th><th>Genel WR%</th><th>Trend WR%</th><th>Range WR%</th><th>Katkı</th></tr></thead>
                        <tbody>
                            ${Object.keys(this.strategyStats).sort((a,b) => this.getStrategyWeight(b) - this.getStrategyWeight(a)).map(key => {
                                const s = this.strategyStats[key]; 
                                if (!s) return ''; 
                                const overallWR = getWR(s.overall);
                                const trendWR = getWR(s.trend);
                                const rangeWR = getWR(s.range);
                                return `
                                    <tr>
                                        <td>${this.strategies[key]?.displayName || key}</td>
                                        <td>${this.getStrategyWeight(key).toFixed(2)}</td>
                                        <td style="color:${overallWR >= 50 ? 'var(--positive)' : 'var(--negative)'}">${overallWR}</td>
                                        <td style="color:${trendWR >= 50 ? 'var(--positive)' : 'var(--negative)'}">${trendWR}</td>
                                        <td style="color:${rangeWR >= 50 ? 'var(--positive)' : 'var(--negative)'}">${rangeWR}</td>
                                        <td>${(s.overall?.contrib || 0)}</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            statsContainer.innerHTML = html;
        }

        clearAllSignals() {
            if (confirm('Tüm sinyal geçmişini temizlemek istediğinizden emin misiniz?')) {
                this.signals = [];
                this.pendingSignals = [];
                this.stats = { total: 0, tp: 0, sl: 0 };
                this.saveData('utc_signals', this.signals);
                this.saveData('utc_stats', this.stats);
                this.debouncedRender();
                this.chartManager.clearMarkers();
                this.showNotification('Sinyal geçmişi temizlendi!', 'info');
            }
        }
        clearChartMarkers() { this.chartManager.clearMarkers(); this.showNotification('Grafik sinyalleri temizlendi.', 'info'); }

        formatPrice(price) { return price.toLocaleString('en-US', { minimumFractionDigits: this.getDecimalPlaces(price), maximumFractionDigits: this.getDecimalPlaces(price) }); }
        formatVolume(volume) { if (volume >= 1e9) return (volume / 1e9).toFixed(2) + 'B'; if (volume >= 1e6) return (volume / 1e6).toFixed(2) + 'M'; if (volume >= 1e3) return (volume / 1e3).toFixed(2) + 'K'; return volume.toFixed(2); }
        getDecimalPlaces(price) { if (!price) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
        
        showNotification(message, type = 'info', timeout = 5000) {
            // Map traditional notification types to new categories
            let category = 'system';
            let priority = 2;
            
            switch(type) {
                case 'success':
                    category = 'success';
                    priority = 3;
                    break;
                case 'danger':
                    category = 'error';
                    priority = 4;
                    break;
                case 'warning':
                    category = 'alert';
                    priority = 3;
                    break;
                case 'info':
                    if (message.toLowerCase().includes('sinyal')) {
                        category = 'trade';
                        priority = 3;
                    }
                    break;
            }
            
            // Detect important notifications
            if (message.toLowerCase().includes('tehlike') || 
                message.toLowerCase().includes('kritik') ||
                message.toLowerCase().includes('uyarı') ||
                message.toLowerCase().includes('dikkat') ||
                message.toLowerCase().includes('durdur')) {
                priority = 4;
            }
            
            // Use the new notification center if available
            if (this.notificationCenter) {
                return this.notificationCenter.notify(message, category, priority, timeout);
            } else {
                // Legacy fallback
                const container = document.getElementById('notifications-container');
                if (!container) return;
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                container.appendChild(notification);
                setTimeout(() => { notification.remove(); }, timeout);
                return notification;
            }
        }
                logToJournal(message, level = 'log') {
            const timestamp = new Date().toLocaleTimeString();
            const formattedMessage = `[${timestamp}] ${message}`;
            console.log(formattedMessage); // Konsola yazdırmaya devam et

            const logOutput = document.getElementById('log-output');
            if (logOutput) {
                const logEntry = document.createElement('div');
                logEntry.textContent = formattedMessage;
                if (level === 'error') logEntry.className = 'log-error';
                if (level === 'warn') logEntry.className = 'log-warn';
                if (level === 'info') logEntry.className = 'log-info';
                
                const isScrolledToBottom = logOutput.scrollHeight - logOutput.clientHeight <= logOutput.scrollTop + 1;
                logOutput.appendChild(logEntry);
                if (isScrolledToBottom) {
                    logOutput.scrollTop = logOutput.scrollHeight;
                }
            }
        }
        // YENİ: Logları dışa aktarma fonksiyonu
        exportLogs() {
            const logOutput = document.getElementById('log-output');
            if (!logOutput || !logOutput.textContent.trim()) {
                this.showNotification('Dışa aktarılacak log bulunmuyor.', 'warning');
                return;
            }
            const blob = new Blob([logOutput.textContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `utc_logs_${new Date().toISOString().slice(0,10)}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            this.showNotification('Loglar başarıyla dışa aktarıldı.', 'success');
        }

        updateConnectionStatus(isConnected, message = '') {
            const statusDot = document.getElementById('connection-status');
            const statusText = document.getElementById('connection-text');
            if (isConnected) {
                statusDot.classList.add('online');
                statusText.textContent = 'BAĞLI';
                statusText.style.color = 'var(--positive)';
            } else {
                statusDot.classList.remove('online');
                statusText.textContent = message || 'BAĞLANTI YOK';
                statusText.style.color = 'var(--negative)';
            }
        }

        updateSession() {
            this.sessionState = this.sessionProfiler.getCurrentSession();
        }

        activateCombatMode() {
            if (this.combatModeActive) return;
            this.combatModeActive = true;
            document.documentElement.setAttribute('data-theme', 'war');
            this.chartManager.updateTheme();
            this.heatmapManager.updateTheme();
            this.showNotification('SAVAŞ MODU AKTİF EDİLDİ!', 'danger');
            this.speak(this.getRandomMessage('combatModeActivate'));
            playSignal('combat');
        }

        deactivateCombatMode() {
            if (!this.combatModeActive) return;
            this.combatModeActive = false;
            const savedTheme = localStorage.getItem('utc_theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            this.chartManager.updateTheme();
            this.heatmapManager.updateTheme();
            this.showNotification('SAVAŞ MODU DEVRE DIŞI BIRAKILDI.', 'success');
            this.speak(this.getRandomMessage('combatModeDeactivate'));
        }

        loadVoices() {
            this.voices = this.synth.getVoices();
            this.updateTTSVoiceSelectUI();
        }

        updateTTSVoiceSelectUI() {
            const selectEl = document.getElementById('modal-tts-voice-select');
            if (!selectEl) return;
            const currentVoice = this.settings.features.preferredVoiceName;
            selectEl.innerHTML = '<option value="">Otomatik Seç</option>';
            if (this.voices.length > 0) {
                 this.voices.forEach(voice => {
                    if (voice.lang.startsWith('tr')) {
                        const option = document.createElement('option');
                        option.value = voice.name;
                        option.textContent = `${voice.name} (${voice.lang})`;
                        if (currentVoice === voice.name) {
                            option.selected = true;
                        }
                        selectEl.appendChild(option);
                    }
                });
            }
        }
        getRandomMessage(key, replacements = {}) {
            const messages = this.speechTexts[key];
            if (!messages || messages.length === 0) {
                console.warn(`'${key}' için konuşma metni bulunamadı.`);
                return `Varsayılan mesaj: ${key}`;
            }
            let message = messages[Math.floor(Math.random() * messages.length)];

            for (const placeholder in replacements) {
                const regex = new RegExp(`\\[${placeholder}\\]`, 'g');
                message = message.replace(regex, replacements[placeholder]);
            }
            return message;
        }

        // DÜZELTME: TTS Kuyruk Mekanizması
        speak(text, options = {}) {
            if (!this.synth || !this.settings.features.enableTTS) return;
            this.speechQueue.push({ text, options });
            if (!this.isSpeaking) {
                this.processSpeechQueue();
            }
        }

        processSpeechQueue() {
            if (this.speechQueue.length === 0) {
                this.isSpeaking = false;
                return;
            }
            this.isSpeaking = true;
            const { text, options } = this.speechQueue.shift();
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = options.rate || 1.1; 
            utterance.pitch = options.pitch || 1.0; 
            utterance.volume = options.volume || 0.8; 
            utterance.lang = options.lang || 'tr-TR'; 

            const preferredVoice = this.voices.find(v => v.name === this.settings.features.preferredVoiceName);
            if (preferredVoice) {
                utterance.voice = preferredVoice;
            } else {
                const turkishVoice = this.voices.find(v => v.lang.startsWith('tr-'));
                if (turkishVoice) utterance.voice = turkishVoice;
            }
            
            utterance.onend = () => {
                setTimeout(() => this.processSpeechQueue(), 300); // Sesler arası kısa bir bekleme
            };
            
            utterance.onerror = (event) => {
                console.error('SpeechSynthesis Hata:', event.error);
                this.isSpeaking = false; // Hata durumunda kuyruğu serbest bırak
                this.processSpeechQueue(); // Bir sonraki öğeyi dene
            };

            this.synth.speak(utterance);
        }

        openHonorModal(filter = 'all') {
            const el = document.getElementById('honor-modal-body');
            const honor = [], shame = [], banned = [];
            const minContrib = 10; 

            for (const key of this.allStrategyKeys) {
                const st = this.strategyStats[key]?.overall || {};
                const w = this.getStrategyWeight(key);
                const active = !!this.settings.activeStrategies[key];
                const isShadow = !!this.settings.statusMaps.shadowBanned[key];
                const isHard = !!this.settings.statusMaps.hardBanned[key];
                const contrib = (st.contrib || 0);
                const totalObs = (st.wins || 0) + (st.losses || 0);
                const wr = totalObs > 0 ? ((st.wins || 0) / totalObs * 100) : 0;

                const row = {
                    key, name: this.strategies[key]?.displayName || key, w, wr, contrib, status: isHard ? 'HARDBAN' : (isShadow ? 'GÖLGE' : (active ? 'CANLI' : 'PASİF'))
                };

                if (isHard || isShadow) banned.push(row);
                if (!isShadow && !isHard) {
                    if (w >= 1.1 && totalObs >= minContrib) honor.push(row);
                    else if (w <= 0.8 && totalObs >= minContrib) shame.push(row);
                }
            }
            
            const pickRogue = shame.sort((a,b) => a.w - b.w)[0];

            const renderList = (title, arr, empty = '-') => `
                <div class="panel-title" style="margin:6px 0;">${title}</div>
                <div class="data-table-container" style="max-height:240px;">
                <table class="data-table">
                    <thead><tr><th>Strateji</th><th>w</th><th>WR%</th><th>Katkı</th><th>Durum</th><th>Aksiyon</th></tr></thead>
                    <tbody>
                    ${arr.length ? arr.map(r => `
                        <tr>
                        <td>${r.name}</td><td>${r.w.toFixed(2)}</td><td>${r.wr.toFixed(0)}</td><td>${r.contrib}</td><td>${r.status}</td>
                        <td>
                            <button class="btn btn-tiny" onclick="window.app.toggleShadow('${r.key}')">${this.settings.statusMaps.shadowBanned[r.key] ? 'Gölgeden Al' : 'Gölgeye Al'}</button>
                            <button class="btn btn-tiny ${this.settings.statusMaps.hardBanned[r.key] ? 'btn-danger' : ''}" onclick="window.app.toggleHardBan('${r.key}')">${this.settings.statusMaps.hardBanned[r.key] ? 'Unban' : 'HardBan'}</button>
                        </td>
                        </tr>
                    `).join('') : `<tr><td colspan="6">${empty}</td></tr>`}
                    </tbody>
                </table></div>`;

            let html = '';
            if (filter === 'banned') {
                html += renderList('Banlılar (Gölge/HardBan)', banned, 'Kimse banlı değil.');
            } else {
                if (pickRogue) {
                    html += `<div class="notification danger" style="position:relative; margin-bottom:10px;">Günün şerefsizi: <b>${pickRogue.name}</b> (w=${pickRogue.w.toFixed(2)})</div>`;
                    this.speak(this.getRandomMessage('rogueOfDay', { 'Strateji': pickRogue.name }));
                }
                html += renderList('Şerefli (güçlüler)', honor.sort((a,b)=>b.w-a.w));
                html += renderList('Şerefsizler (zayıflar)', shame.sort((a,b)=>a.w-b.w));
                html += renderList('Banlılar (Gölge/HardBan)', banned);
            }

            el.innerHTML = html;
            document.getElementById('honor-modal-overlay').style.display = 'flex';
            this.lastHonorModalFilter = filter;
        }

        closeHonorModal() { document.getElementById('honor-modal-overlay').style.display = 'none'; }

        toggleShadow(key) {
            const cur = !!this.settings.statusMaps.shadowBanned[key];
            this.settings.statusMaps.shadowBanned[key] = !cur;
            if (cur) {
                if (!this.settings.statusMaps.hardBanned[key]) {
                    this.settings.activeStrategies[key] = true;
                }
            } else {
                this.settings.activeStrategies[key] = false;
            }
            this.updateActiveStrategies();
            this.saveSettings();
            this.openHonorModal(this.lastHonorModalFilter);
            this.showNotification(`${this.strategies[key].displayName} ${cur ? 'gölgeden alındı' : 'gölgeye alındı'}.`, 'info');
            this.speak(this.getRandomMessage(cur ? 'shadowRehab' : 'shadowBan', { 'Strateji': this.strategies[key].displayName }));
        }

        toggleHardBan(key) {
            const cur = !!this.settings.statusMaps.hardBanned[key];
            this.settings.statusMaps.hardBanned[key] = !cur;
            if (this.settings.statusMaps.hardBanned[key]) {
                this.settings.statusMaps.shadowBanned[key] = true;
                this.settings.activeStrategies[key] = false;
            } else {
                this.settings.statusMaps.shadowBanned[key] = false;
            }
            this.updateActiveStrategies();
            this.saveSettings();
            this.openHonorModal(this.lastHonorModalFilter);
            this.showNotification(`${this.strategies[key].displayName} ${cur ? 'hardbandan çıkarıldı' : 'hardban edildi'}.`, cur ? 'success' : 'danger');
        }

        // DÜZELTME: Performans izleme fonksiyonu
        startPerformanceMonitor() {
            this.performanceMonitorInterval = setInterval(() => {
                if (performance.memory) {
                    const memUsage = (performance.memory.usedJSHeapSize / 1048576).toFixed(2);
                    this.logToJournal(`Performans: Bellek=${memUsage}MB, Sinyaller=${this.signals.length}, Bekleyenler=${this.pendingSignals.length}`);
                }
            }, 30000);
        }
    }

    // Uygulamayı başlat
    window.app = new UltimateTradingCommandCenter();

    /* =================================================================
       PANTEON SISTEMI VE GÖRSEL EFEKTLER
       ================================================================= */
    /* =================================================================
       ADVANCED VISUALIZATION TOOLS
       ================================================================= */
    class AdvancedTradingVisualizer {
        constructor(app) {
            this.app = app;
            this.isInitialized = false;
            this.heatmapEnabled = false;
            this.volumeProfileEnabled = false;
            this.liquidityHeatmapEnabled = false;
            this.orderFlowEnabled = false;
            this.marketStructureVisualization = false;
            this.optionsOverlayEnabled = false;
            this.supportResistanceLevels = [];
            this.fibonacciLevels = [];
            this.pivotPoints = [];
            this.init();
        }
        
        init() {
            if (this.isInitialized) return;
            
            // Initialize visualization components
            this.addVisualizationButtons();
            
            // Create necessary canvas layers
            this.createAdditionalCanvasLayers();
            
            // Bind events
            this.bindEvents();
            
            this.isInitialized = true;
            console.log('Advanced Trading Visualization Tools initialized');
        }
        
        createAdditionalCanvasLayers() {
            // Create order flow canvas layer
            const orderFlowCanvas = document.createElement('canvas');
            orderFlowCanvas.id = 'order-flow-canvas';
            orderFlowCanvas.style.position = 'absolute';
            orderFlowCanvas.style.top = '0';
            orderFlowCanvas.style.left = '0';
            orderFlowCanvas.style.width = '100%';
            orderFlowCanvas.style.height = '100%';
            orderFlowCanvas.style.pointerEvents = 'none';
            orderFlowCanvas.style.display = 'none';
            orderFlowCanvas.style.zIndex = '5';
            
            // Create volume profile canvas
            const volumeProfileCanvas = document.createElement('canvas');
            volumeProfileCanvas.id = 'volume-profile-canvas';
            volumeProfileCanvas.style.position = 'absolute';
            volumeProfileCanvas.style.top = '0';
            volumeProfileCanvas.style.right = '0';
            volumeProfileCanvas.style.width = '80px';
            volumeProfileCanvas.style.height = '100%';
            volumeProfileCanvas.style.pointerEvents = 'none';
            volumeProfileCanvas.style.display = 'none';
            volumeProfileCanvas.style.zIndex = '6';
            
            // Add to chart container
            const chartContainer = document.getElementById('live-chart');
            if (chartContainer) {
                chartContainer.style.position = 'relative';
                chartContainer.appendChild(orderFlowCanvas);
                chartContainer.appendChild(volumeProfileCanvas);
            }
        }
        
        addVisualizationButtons() {
            // Create visualization controls container
            const controlsContainer = document.createElement('div');
            controlsContainer.className = 'visualization-controls';
            controlsContainer.style.position = 'absolute';
            controlsContainer.style.top = '50px';
            controlsContainer.style.right = '10px';
            controlsContainer.style.display = 'flex';
            controlsContainer.style.flexDirection = 'column';
            controlsContainer.style.gap = '5px';
            controlsContainer.style.zIndex = '100';
            
            // Add buttons
            const buttons = [
                { id: 'toggle-heatmap-btn', icon: '🔥', title: 'Toggle Heatmap' },
                { id: 'toggle-volume-profile-btn', icon: '📊', title: 'Toggle Volume Profile' },
                { id: 'toggle-liquidity-btn', icon: '💧', title: 'Toggle Liquidity Visualization' },
                { id: 'toggle-order-flow-btn', icon: '📈', title: 'Toggle Order Flow' },
                { id: 'toggle-market-structure-btn', icon: '🔍', title: 'Toggle Market Structure' },
                { id: 'toggle-options-overlay-btn', icon: '🔄', title: 'Toggle Options Overlay' }
            ];
            
            buttons.forEach(btn => {
                const button = document.createElement('button');
                button.id = btn.id;
                button.className = 'btn-tiny visualization-btn';
                button.innerHTML = btn.icon;
                button.title = btn.title;
                button.style.width = '28px';
                button.style.height = '28px';
                button.style.padding = '2px';
                button.style.fontSize = '14px';
                button.style.background = 'rgba(1, 4, 9, 0.7)';
                button.style.backdropFilter = 'blur(2px)';
                button.style.border = '1px solid var(--border-color)';
                button.style.borderRadius = '4px';
                button.style.color = 'var(--text-main)';
                button.style.cursor = 'pointer';
                button.style.display = 'flex';
                button.style.alignItems = 'center';
                button.style.justifyContent = 'center';
                controlsContainer.appendChild(button);
            });
            
            // Add to chart container
            const chartContainer = document.getElementById('live-chart');
            if (chartContainer) {
                chartContainer.style.position = 'relative';
                chartContainer.appendChild(controlsContainer);
            }
        }
        
        bindEvents() {
            // Bind click events to visualization buttons
            document.getElementById('toggle-heatmap-btn')?.addEventListener('click', () => this.toggleHeatmap());
            document.getElementById('toggle-volume-profile-btn')?.addEventListener('click', () => this.toggleVolumeProfile());
            document.getElementById('toggle-liquidity-btn')?.addEventListener('click', () => this.toggleLiquidityHeatmap());
            document.getElementById('toggle-order-flow-btn')?.addEventListener('click', () => this.toggleOrderFlow());
            document.getElementById('toggle-market-structure-btn')?.addEventListener('click', () => this.toggleMarketStructure());
            document.getElementById('toggle-options-overlay-btn')?.addEventListener('click', () => this.toggleOptionsOverlay());
            
            // Resize event
            window.addEventListener('resize', () => this.handleResize());
        }
        
        toggleHeatmap() {
            this.heatmapEnabled = !this.heatmapEnabled;
            document.getElementById('toggle-heatmap-btn')?.classList.toggle('active', this.heatmapEnabled);
            if (this.heatmapEnabled) {
                this.app.switchMainView('heatmap');
            } else {
                this.app.switchMainView('chart');
            }
        }
        
        toggleVolumeProfile() {
            this.volumeProfileEnabled = !this.volumeProfileEnabled;
            document.getElementById('toggle-volume-profile-btn')?.classList.toggle('active', this.volumeProfileEnabled);
            const volumeProfileCanvas = document.getElementById('volume-profile-canvas');
            if (volumeProfileCanvas) {
                volumeProfileCanvas.style.display = this.volumeProfileEnabled ? 'block' : 'none';
            }
            if (this.volumeProfileEnabled) {
                this.drawVolumeProfile();
            }
        }
        
        toggleLiquidityHeatmap() {
            this.liquidityHeatmapEnabled = !this.liquidityHeatmapEnabled;
            document.getElementById('toggle-liquidity-btn')?.classList.toggle('active', this.liquidityHeatmapEnabled);
            // Implementation of liquidity heatmap visualization
            if (this.liquidityHeatmapEnabled) {
                this.app.showNotification('Liquidity heatmap activated', 'info');
                this.analyzeLiquidity();
            }
        }
        
        toggleOrderFlow() {
            this.orderFlowEnabled = !this.orderFlowEnabled;
            document.getElementById('toggle-order-flow-btn')?.classList.toggle('active', this.orderFlowEnabled);
            const orderFlowCanvas = document.getElementById('order-flow-canvas');
            if (orderFlowCanvas) {
                orderFlowCanvas.style.display = this.orderFlowEnabled ? 'block' : 'none';
            }
            if (this.orderFlowEnabled) {
                this.drawOrderFlow();
            }
        }
        
        toggleMarketStructure() {
            this.marketStructureVisualization = !this.marketStructureVisualization;
            document.getElementById('toggle-market-structure-btn')?.classList.toggle('active', this.marketStructureVisualization);
            if (this.marketStructureVisualization) {
                this.app.showNotification('Market structure visualization activated', 'info');
                this.analyzeMarketStructure();
            } else {
                // Clear market structure markers
                if (this.app.chartManager && this.app.chartManager.chart) {
                    // Remove market structure lines
                }
            }
        }
        
        toggleOptionsOverlay() {
            this.optionsOverlayEnabled = !this.optionsOverlayEnabled;
            document.getElementById('toggle-options-overlay-btn')?.classList.toggle('active', this.optionsOverlayEnabled);
            if (this.optionsOverlayEnabled) {
                this.app.showNotification('Options data overlay activated', 'info');
                this.fetchOptionsData();
            }
        }
        
        handleResize() {
            if (this.volumeProfileEnabled) {
                this.drawVolumeProfile();
            }
            if (this.orderFlowEnabled) {
                this.drawOrderFlow();
            }
        }
        
        drawVolumeProfile() {
            const canvas = document.getElementById('volume-profile-canvas');
            if (!canvas || !this.app.candles || this.app.candles.length < 10) return;
            
            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            
            // Resize canvas to match its display size
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Get price range from visible candles
            const candles = this.app.candles;
            const minPrice = Math.min(...candles.map(c => c.low));
            const maxPrice = Math.max(...candles.map(c => c.high));
            const priceRange = maxPrice - minPrice;
            
            // Calculate volume at different price levels
            const priceLevels = 40; // Number of price levels
            const volumeByPrice = new Array(priceLevels).fill(0);
            
            candles.forEach(candle => {
                const priceRange = candle.high - candle.low;
                if (priceRange === 0) return;
                
                // Distribute volume across price range
                for (let i = 0; i < priceLevels; i++) {
                    const levelPrice = minPrice + (i / priceLevels) * (maxPrice - minPrice);
                    if (levelPrice >= candle.low && levelPrice <= candle.high) {
                        // Weight by proximity to close price
                        const weight = 1 - Math.abs(levelPrice - candle.close) / priceRange;
                        volumeByPrice[i] += candle.volume * weight;
                    }
                }
            });
            
            // Find max volume for scaling
            const maxVolume = Math.max(...volumeByPrice);
            
            // Draw volume profile
            ctx.fillStyle = 'rgba(100, 100, 255, 0.5)';
            ctx.strokeStyle = 'rgba(100, 100, 255, 0.8)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < priceLevels; i++) {
                const y = canvas.height - (i / priceLevels) * canvas.height;
                const volumeWidth = (volumeByPrice[i] / maxVolume) * canvas.width;
                
                ctx.fillRect(0, y, volumeWidth, canvas.height / priceLevels);
                ctx.strokeRect(0, y, volumeWidth, canvas.height / priceLevels);
            }
            
            // Draw POC (Point of Control) - highest volume level
            const pocIndex = volumeByPrice.indexOf(maxVolume);
            if (pocIndex >= 0) {
                const pocY = canvas.height - (pocIndex / priceLevels) * canvas.height;
                ctx.strokeStyle = 'rgba(255, 255, 0, 1)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, pocY);
                ctx.lineTo(canvas.width, pocY);
                ctx.stroke();
            }
        }
        
        drawOrderFlow() {
            const canvas = document.getElementById('order-flow-canvas');
            if (!canvas || !this.app.aggTrades || this.app.aggTrades.length < 10) return;
            
            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            
            // Resize canvas to match its display size
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Get recent trades
            const trades = this.app.aggTrades.slice(-50);
            if (trades.length === 0) return;
            
            // Draw trade flow
            let x = 50;
            const spacing = (canvas.width - 100) / trades.length;
            
            for (let i = 0; i < trades.length - 1; i++) {
                const trade = trades[i];
                const nextTrade = trades[i + 1];
                
                // Calculate y position based on price (normalized to canvas height)
                const minPrice = Math.min(...trades.map(t => t.price));
                const maxPrice = Math.max(...trades.map(t => t.price));
                const priceRange = maxPrice - minPrice;
                
                if (priceRange === 0) continue;
                
                const y1 = canvas.height - ((trade.price - minPrice) / priceRange) * (canvas.height - 40);
                const y2 = canvas.height - ((nextTrade.price - minPrice) / priceRange) * (canvas.height - 40);
                
                // Draw line connecting trades
                ctx.beginPath();
                ctx.moveTo(x, y1);
                ctx.lineTo(x + spacing, y2);
                
                // Color based on whether it's a buy or sell
                if (trade.isBuyerMaker) {
                    ctx.strokeStyle = 'rgba(220, 53, 69, 0.7)'; // Red for sells
                } else {
                    ctx.strokeStyle = 'rgba(40, 167, 69, 0.7)'; // Green for buys
                }
                
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw circle for trade point with size based on quantity
                const radius = Math.min(10, Math.max(3, Math.sqrt(trade.quantity) * 0.5));
                ctx.beginPath();
                ctx.arc(x, y1, radius, 0, Math.PI * 2);
                
                if (trade.isBuyerMaker) {
                    ctx.fillStyle = 'rgba(220, 53, 69, 0.7)'; // Red for sells
                } else {
                    ctx.fillStyle = 'rgba(40, 167, 69, 0.7)'; // Green for buys
                }
                
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                x += spacing;
            }
        }
        
        analyzeMarketStructure() {
            if (!this.app.candles || this.app.candles.length < 50) return;
            
            const candles = this.app.candles;
            
            // Find swing highs and lows
            const swingHighs = [];
            const swingLows = [];
            
            const lookback = 3; // Number of candles to look back and forward
            
            for (let i = lookback; i < candles.length - lookback; i++) {
                // Check for swing high
                let isSwingHigh = true;
                for (let j = i - lookback; j <= i + lookback; j++) {
                    if (j === i) continue;
                    if (candles[j].high >= candles[i].high) {
                        isSwingHigh = false;
                        break;
                    }
                }
                
                if (isSwingHigh) {
                    swingHighs.push({ time: candles[i].time, price: candles[i].high });
                }
                
                // Check for swing low
                let isSwingLow = true;
                for (let j = i - lookback; j <= i + lookback; j++) {
                    if (j === i) continue;
                    if (candles[j].low <= candles[i].low) {
                        isSwingLow = false;
                        break;
                    }
                }
                
                if (isSwingLow) {
                    swingLows.push({ time: candles[i].time, price: candles[i].low });
                }
            }
            
            // Draw swing points on chart
            if (this.app.chartManager && this.app.chartManager.series && this.app.chartManager.series.candles) {
                const markers = [];
                
                swingHighs.forEach(high => {
                    markers.push({
                        time: high.time / 1000,
                        position: 'aboveBar',
                        color: 'rgba(220, 53, 69, 0.7)',
                        shape: 'arrowDown',
                        text: 'H'
                    });
                });
                
                swingLows.forEach(low => {
                    markers.push({
                        time: low.time / 1000,
                        position: 'belowBar',
                        color: 'rgba(40, 167, 69, 0.7)',
                        shape: 'arrowUp',
                        text: 'L'
                    });
                });
                
                this.app.chartManager.series.candles.setMarkers(markers);
            }
        }
        
        analyzeLiquidity() {
            if (!this.app.orderBook || !this.app.orderBook.bids || !this.app.orderBook.asks) return;
            
            const { bids, asks } = this.app.orderBook;
            
            // Find liquidity clusters
            const bidClusters = this.findLiquidityClusters(bids);
            const askClusters = this.findLiquidityClusters(asks);
            
            // Add horizontal lines at major liquidity levels
            if (this.app.chartManager && this.app.chartManager.chart) {
                // Implementation depends on your charting library
                console.log('Liquidity clusters identified:', { bidClusters, askClusters });
            }
        }
        
        findLiquidityClusters(levels) {
            if (!levels || levels.length === 0) return [];
            
            // Sort levels by price
            const sortedLevels = [...levels].sort((a, b) => a[0] - b[0]);
            
            // Group nearby levels
            const clusters = [];
            let currentCluster = { price: sortedLevels[0][0], volume: sortedLevels[0][1] };
            
            for (let i = 1; i < sortedLevels.length; i++) {
                const [price, volume] = sortedLevels[i];
                const prevPrice = sortedLevels[i-1][0];
                
                // If close to previous level, add to cluster
                if (Math.abs(price - prevPrice) / prevPrice < 0.001) { // 0.1% threshold
                    currentCluster.price = (currentCluster.price * currentCluster.volume + price * volume) / 
                                          (currentCluster.volume + volume); // Volume-weighted average price
                    currentCluster.volume += volume;
                } else {
                    // Start new cluster
                    clusters.push(currentCluster);
                    currentCluster = { price, volume };
                }
            }
            
            clusters.push(currentCluster);
            
            // Sort by volume and take top clusters
            return clusters.sort((a, b) => b.volume - a.volume).slice(0, 5);
        }
        
        fetchOptionsData() {
            // Simulate options data fetch
            setTimeout(() => {
                this.app.showNotification('Options data fetched successfully', 'success');
                // Process options data
                this.processOptionsData({
                    callsOpenInterest: [/* mock data */],
                    putsOpenInterest: [/* mock data */],
                    maxPain: 45000,
                    putCallRatio: 0.85
                });
            }, 1000);
        }
        
        processOptionsData(optionsData) {
            // Add options-related indicators to chart
            console.log('Processing options data:', optionsData);
            
            // Show max pain line on chart
            if (this.app.chartManager && this.app.chartManager.chart && optionsData.maxPain) {
                // Implementation depends on your charting library
                this.app.showNotification(`Max pain level: ${optionsData.maxPain}`, 'info');
            }
        }
    }
    
    // NOT: PantheonSystem sınıfı artık dokümanın başında tanımlı
    
    // Eski sınıfın yerine boş bir sınıf tanımı ekliyorum, çünkü
    // sınıf metod ve değişkenlerine hala bazı yerlerden erişim var
    class PantheonSystemLegacy {
        constructor() {
            console.log("Bu sınıf artık kullanılmıyor. Dokümanın başındaki PantheonSystem sınıfı kullanılmalı.");
        }
        
        init() { }
        bindEvents() { }
        loadPowers() { }
        savePowers() { }
        increasePantheonPower() { }
        checkSpecialAbilities() { }
        triggerElciSpecialAbility() { }
        activateRevelation() { }
        activateValor() { }
        activateRestoration() { }
        activateCommunication() { }
        activateJudgment() { }
        activateAbility() { }
        startCooldown() { }
        onGodClick() { }
        getGodDisplayName() { return ""; }
        updateUI() { }
        updateAbilityStates() { }
        decayLoop() { }
        createPowerEffect() { }
        initEffects() { }
        showNotification() { }
    }
    
    // Yardımcı Panteon sınıfımız
    class AdvancedPantheonUtil {
        // Sınıf özellikleri
        static gods = {};
        static abilities = {};
        static effects = [];
        static lastDecayTime = Date.now();
        static powerDecayRate = 0.1; // Saniye başına güç azalması
        
        constructor() {
            console.log("Yardımcı Panteon sınıfı oluşturuldu");
        }
        
        static init() {
            console.log("AdvancedPantheonUtil init");
            // Gerekirse tanrıları ve yetenekleri burada başlatabiliriz
            this.lastDecayTime = Date.now();
        }
        
        static bindEvents() {
            console.log("AdvancedPantheonUtil bindEvents çağrıldı");
            
            // Yetenek butonları
            if (this.abilities) {
                Object.keys(this.abilities).forEach(abilityId => {
                    const abilityEl = document.querySelector(`.ability[data-ability="${abilityId}"]`);
                    if (abilityEl) {
                        abilityEl.addEventListener('click', () => this.activateAbility(abilityId));
                    }
                });
            }
            
            // Tanrı etkileşimleri
            if (this.gods) {
                document.querySelectorAll('.god').forEach(godEl => {
                    const godName = godEl.dataset.god;
                    if (godName && this.gods[godName]) {
                        godEl.addEventListener('click', () => this.onGodClick(godName));
                    }
                });
            }
        }
        
        static setupUI() {
            const shouldHideContent = localStorage.getItem('pantheonContentVisible') === 'false';
            if (shouldHideContent) {
                const content = document.querySelector('.pantheon-content');
                const btn = document.querySelector('.pantheon-toggle-btn');
                if (content && btn) {
                    content.style.display = 'none';
                    btn.textContent = '▲';
                }
            }
        }
        
        static loadPowers() {
            try {
                const savedPowers = JSON.parse(localStorage.getItem('pantheonPowers') || '{}');
                Object.keys(this.gods).forEach(godName => {
                    if (savedPowers[godName] !== undefined) {
                        this.gods[godName].power = Math.min(savedPowers[godName], this.gods[godName].maxPower);
                    }
                });
                this.updateUI();
            } catch (e) {
                console.error('Güç değerleri yüklenirken hata:', e);
            }
        }
        
        static savePowers() {
            try {
                const powersToSave = {};
                Object.keys(this.gods).forEach(godName => {
                    powersToSave[godName] = this.gods[godName].power;
                });
                localStorage.setItem('pantheonPowers', JSON.stringify(powersToSave));
            } catch (e) {
                console.error('Güç değerleri kaydedilirken hata:', e);
            }
        }
        
        static increasePantheonPower(godName, amount = 1) {
            if (!this.gods[godName]) return;
            
            const god = this.gods[godName];
            god.power = Math.min(god.power + amount, god.maxPower);
            
            // Özel efektler
            this.createPowerEffect(godName);
            
            // UI güncelle
            this.updateUI();
            
            // Kaydet
            this.savePowers();
            
            // Özel yetenekler
            this.checkSpecialAbilities(godName);
            
            return god.power;
        }
        
        static checkSpecialAbilities(godName) {
            const god = this.gods[godName];
            if (!god) return;
            
            // %100 güç özel yeteneği
            if (god.power >= god.maxPower) {
                this.triggerElciSpecialAbility(godName);
                god.power = 0; // Gücü sıfırla
                this.updateUI();
                this.savePowers();
            }
        }
        
        static triggerElciSpecialAbility(godName) {
            const abilities = {
                metatron: () => this.activateRevelation(),
                uriel: () => this.activateValor(),
                raphael: () => this.activateRestoration(),
                gabriel: () => this.activateCommunication(),
                michael: () => this.activateJudgment()
            };
            
            if (abilities[godName]) {
                abilities[godName]();
                this.showNotification(`${this.getGodDisplayName(godName)} özel yeteneği aktive edildi!`, 'success');
            }
        }
        
        static activateRevelation() {
            // Tüm stratejilerin doğruluk oranını geçici olarak artır
            this.showNotification('Vahiy: Stratejilerin doğruluk oranı arttı!', 'info');
        }
        
        static activateValor() {
            // Risk almayı artıran cesaret bonusu
            this.showNotification('Cesaret: Risk limitleri artırıldı!', 'info');
        }
        
        static activateRestoration() {
            // Kayıpları telafi etme
            this.showNotification('Şifa: Kayıplar telafi ediliyor...', 'info');
        }
        
        static activateCommunication() {
            // Haber ve veri akışını iyileştir
            this.showNotification('İletişim: Veri akışı optimize edildi!', 'info');
        }
        
        static activateJudgment() {
            // Düşman pozisyonlarını ortaya çıkar
            this.showNotification('Yargı: Düşman pozisyonları tespit edildi!', 'warning');
        }
        
        static activateAbility(abilityId) {
            const ability = this.abilities[abilityId];
            if (!ability) return;
            
            const now = Date.now();
            const cooldownLeft = (ability.lastUsed + ability.cooldown) - now;
            
            if (cooldownLeft > 0) {
                this.showNotification(`Bekleyin: ${(cooldownLeft/1000).toFixed(1)} saniye kaldı`, 'warning');
                return;
            }
            
            // Yeteneği etkinleştir
            ability.lastUsed = now;
            this.startCooldown(abilityId, ability.cooldown);
            
            // Yeteneğe özel işlemler
            switch(abilityId) {
                case 'revelation':
                    this.activateRevelation();
                    break;
                case 'valor':
                    this.activateValor();
                    break;
                case 'restoration':
                    this.activateRestoration();
                    break;
            }
        }
        
        static startCooldown(abilityId, duration) {
            const abilityEl = document.querySelector(`.ability[data-ability="${abilityId}"]`);
            if (!abilityEl) return;
            
            const cooldownEl = abilityEl.querySelector('.ability-cooldown');
            if (!cooldownEl) return;
            
            abilityEl.classList.add('on-cooldown');
            cooldownEl.style.transition = `transform ${duration}ms linear`;
            cooldownEl.style.transform = 'scaleX(0)';
            
            // Animasyon bittiğinde sınıfı kaldır
            setTimeout(() => {
                abilityEl.classList.remove('on-cooldown');
                cooldownEl.style.transition = 'none';
                cooldownEl.style.transform = 'scaleX(1)';
                // Tarayıcıya stil değişikliğini işlemesi için kısa bir gecikme
                setTimeout(() => {
                    cooldownEl.style.transition = '';
                }, 10);
            }, duration);
        }
        
        static onGodClick(godName) {
            // Tanrıya tıklandığında özel bir şeyler yap
            this.showNotification(`${this.getGodDisplayName(godName)} dinleniyor...`, 'info');
        }
        
        static getGodDisplayName(godName) {
            const names = {
                metatron: 'Metatron',
                uriel: 'Uriel',
                raphael: 'Raphael',
                gabriel: 'Gabriel',
                michael: 'Michael'
            };
            return names[godName] || godName;
        }
        
        static updateUI() {
            // Güç çubuklarını güncelle
            Object.entries(this.gods).forEach(([godName, god]) => {
                const powerEl = document.querySelector(`.god[data-god="${godName}"] .god-power`);
                const progressEl = document.querySelector(`.god[data-god="${godName}"] .god-progress-fill`);
                
                if (powerEl) {
                    powerEl.textContent = `${Math.round(god.power)}%`;
                }
                
                if (progressEl) {
                    const percentage = (god.power / god.maxPower) * 100;
                    progressEl.style.width = `${percentage}%`;
                    
                    // Güç seviyesine göre renk yoğunluğunu ayarla
                    const opacity = 0.3 + (percentage / 100 * 0.7);
                    progressEl.style.opacity = opacity;
                }
            });
            
            // Özel yetenek durumlarını güncelle
            this.updateAbilityStates();
        }
        
        static updateAbilityStates() {
            const now = Date.now();
            
            Object.entries(this.abilities).forEach(([abilityId, ability]) => {
                const abilityEl = document.querySelector(`.ability[data-ability="${abilityId}"]`);
                if (!abilityEl) return;
                
                const cooldownLeft = (ability.lastUsed + ability.cooldown) - now;
                const statusEl = abilityEl.querySelector('.ability-status');
                
                if (cooldownLeft > 0) {
                    // Bekleme süresi devam ediyor
                    abilityEl.classList.add('on-cooldown');
                    
                    // Update status text with remaining time
                    if (statusEl) {
                        const secondsLeft = Math.ceil(cooldownLeft / 1000);
                        statusEl.textContent = `${secondsLeft}s`;
                    }
                    
                    // İlerleme çubuğunu güncelle
                    const progress = 1 - (cooldownLeft / ability.cooldown);
                    const cooldownEl = abilityEl.querySelector('.ability-cooldown');
                    if (cooldownEl) {
                        cooldownEl.style.transform = `scaleX(${progress})`;
                    }
                } else {
                    // Hazır
                    abilityEl.classList.remove('on-cooldown');
                    if (statusEl) {
                        statusEl.textContent = 'Ready';
                    }
                }
            });
        }
        
        static decayLoop() {
            const now = Date.now();
            const deltaTime = (now - this.lastDecayTime) / 1000; // Saniye cinsinden
            
            // Güç azalt
            Object.values(this.gods).forEach(god => {
                const decayAmount = this.powerDecayRate * deltaTime;
                god.power = Math.max(0, god.power - decayAmount);
            });
            
            this.lastDecayTime = now;
            this.updateUI();
            this.savePowers();
            
            // Her saniye güncelle
            setTimeout(() => this.decayLoop(), 1000);
        }
        
        static createPowerEffect(godName) {
            const god = this.gods[godName];
            if (!god) return;
            
            const effect = {
                type: 'power-up',
                god: godName,
                x: Math.random() * window.innerWidth,
                y: window.innerHeight,
                size: 5 + Math.random() * 10,
                alpha: 0.8,
                speed: 1 + Math.random() * 3,
                life: 100,
                update: function() {
                    this.y -= this.speed;
                    this.life--;
                    return this.life > 0;
                },
                draw: function(ctx) {
                    ctx.save();
                    ctx.globalAlpha = this.alpha * (this.life / 100);
                    ctx.fillStyle = god.color;
                    
                    // Parçacık efekti
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Işık efekti
                    const gradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, this.size * 3
                    );
                    gradient.addColorStop(0, `${god.color}80`);
                    gradient.addColorStop(1, `${god.color}00`);
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(this.x - this.size * 3, this.y - this.size * 3, this.size * 6, this.size * 6);
                    
                    ctx.restore();
                }
            };
            
            this.effects.push(effect);
            
            // Maksimum efekt sayısını sınırla
            if (this.effects.length > 100) {
                this.effects.shift();
            }
        }
        
        static initEffects() {
            const canvas = document.getElementById('effects-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            
            // Canvas boyutunu ayarla
            const resizeCanvas = () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            };
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // Animasyon döngüsü
            const animate = () => {
                // Temizle
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Efektleri güncelle ve çiz
                this.effects = this.effects.filter(effect => {
                    const isAlive = effect.update();
                    if (isAlive) {
                        effect.draw(ctx);
                    }
                    return isAlive;
                });
                
                requestAnimationFrame(animate);
            };
            
            animate();
        }
        
        static showNotification(message, type = 'info') {
            // Mevcut bildirim sisteminizi kullanarak gösterin
            console.log(`[${type.toUpperCase()}] ${message}`);
            
            // Örnek bildirim oluşturma (mevcut sisteminize göre)
            if (window.app && typeof window.app.showNotification === 'function') {
                window.app.showNotification(message, type);
            } else {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                
                const container = document.getElementById('notifications-container') || document.body;
                container.appendChild(notification);
                
                // Otomatik kaldır
                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => notification.remove(), 300);
                }, 5000);
            }
        }
    }
    
    /* =================================================================
       RITUAL SYSTEM
       ================================================================= */
    class RitualManager {
        constructor(app) {
            this.app = app;
            this.rituals = [
                {
                    id: 'marketHarmony',
                    name: 'Piyasa Uyumu',
                    description: 'Piyasa akışı ile uyumlanma ritüeli. Trend yönünü daha net gösterir ve geçişleri erken yakalar.',
                    effect: 'Trend analiz doğruluğu +25%, trend geçiş tespiti +30%',
                    duration: 15 * 60 * 1000, // 15 dakika
                    preparationTime: 60 * 1000, // 1 dakika
                    energyCost: 15,
                    type: 'trend',
                    active: false,
                    prepared: false,
                    prepProgress: 0,
                    remainingTime: 0,
                    activatedAt: null
                },
                {
                    id: 'confluenceRitual',
                    name: 'Uyum Noktası Ritüeli',
                    description: 'Çoklu zaman dilimlerindeki fiyat uyumlarını görme yeteneğini artırır.',
                    effect: 'Uyum skorları +35%, çoklu zaman dilimi doğruluğu +25%',
                    duration: 20 * 60 * 1000, // 20 dakika
                    preparationTime: 90 * 1000, // 1.5 dakika
                    energyCost: 20,
                    type: 'confluence',
                    active: false,
                    prepared: false,
                    prepProgress: 0,
                    remainingTime: 0,
                    activatedAt: null
                },
                {
                    id: 'liquidityVision',
                    name: 'Likidite Görüşü',
                    description: 'Piyasadaki büyük likidite havuzlarını ve emir duvarlarını daha net görmenizi sağlar.',
                    effect: 'Likidite tespiti +40%, büyük emirlerin tespiti +30%',
                    duration: 10 * 60 * 1000, // 10 dakika
                    preparationTime: 45 * 1000, // 45 saniye
                    energyCost: 12,
                    type: 'liquidity',
                    active: false,
                    prepared: false,
                    prepProgress: 0,
                    remainingTime: 0,
                    activatedAt: null
                },
                {
                    id: 'orderFlowInsight',
                    name: 'Emir Akışı İçgörüsü',
                    description: 'Piyasa katılımcılarının davranışlarını daha iyi anlama ve emir akışını derinlemesine görme yeteneği.',
                    effect: 'Emir akışı analizi +30%, piyasa katılımcı analizi +25%',
                    duration: 12 * 60 * 1000, // 12 dakika
                    preparationTime: 75 * 1000, // 1.25 dakika
                    energyCost: 18,
                    type: 'orderflow',
                    active: false,
                    prepared: false,
                    prepProgress: 0,
                    remainingTime: 0,
                    activatedAt: null
                },
                {
                    id: 'divineProtection',
                    name: 'İlahi Koruma',
                    description: 'Piyasa manipülasyonlarına karşı koruma sağlar ve ani fiyat hareketlerinden sizi korur.',
                    effect: 'Manipülasyon tespiti +40%, ani hareket koruması +35%',
                    duration: 30 * 60 * 1000, // 30 dakika
                    preparationTime: 120 * 1000, // 2 dakika
                    energyCost: 25,
                    type: 'protection',
                    active: false,
                    prepared: false,
                    prepProgress: 0,
                    remainingTime: 0,
                    activatedAt: null
                }
            ];
            
            this.selectedRitualId = null;
            this.isContainerVisible = false;
            this.prepInterval = null;
            this.ritualIntervals = {};
            
            // UI elemanları
            this.container = document.getElementById('ritual-container');
            this.ritualList = document.getElementById('ritual-list');
            this.ritualStatus = document.getElementById('ritual-status');
            
            // Görünürlük durumunu yükle
            this.loadVisibilityState();
            
            // Ritüelleri listele
            this.renderRituals();
            
            // Aktif ritüelleri kontrol et
            this.checkActiveRituals();
            
            // Event listeners
            window.addEventListener('beforeunload', () => {
                this.saveRitualStates();
            });
        }
        
        loadVisibilityState() {
            const visible = localStorage.getItem('utc_ritual_visible');
            if (visible === 'true') {
                this.toggleRitualContainer(true);
            }
            
            // Kayıtlı ritüel durumlarını yükle
            const savedRituals = localStorage.getItem('utc_ritual_states');
            if (savedRituals) {
                try {
                    const ritualStates = JSON.parse(savedRituals);
                    ritualStates.forEach(state => {
                        const ritual = this.rituals.find(r => r.id === state.id);
                        if (ritual) {
                            ritual.active = state.active;
                            ritual.prepared = state.prepared;
                            ritual.prepProgress = state.prepProgress;
                            ritual.activatedAt = state.activatedAt ? new Date(state.activatedAt) : null;
                            
                            if (ritual.active && ritual.activatedAt) {
                                // Kalan süreyi hesapla
                                const elapsedTime = Date.now() - ritual.activatedAt;
                                ritual.remainingTime = Math.max(0, ritual.duration - elapsedTime);
                                
                                // Eğer süre dolmadıysa, ritüeli aktifleştir
                                if (ritual.remainingTime > 0) {
                                    this.applyRitualEffects(ritual);
                                    this.startRitualTimer(ritual);
                                } else {
                                    ritual.active = false;
                                    ritual.activatedAt = null;
                                }
                            }
                        }
                    });
                } catch (e) {
                    console.error('Ritüel durumları yüklenirken hata:', e);
                }
            }
        }
        
        saveRitualStates() {
            // Sadece ID, active, prepared, prepProgress ve activatedAt verilerini kaydet
            const ritualStates = this.rituals.map(ritual => ({
                id: ritual.id,
                active: ritual.active,
                prepared: ritual.prepared,
                prepProgress: ritual.prepProgress,
                activatedAt: ritual.activatedAt
            }));
            
            localStorage.setItem('utc_ritual_states', JSON.stringify(ritualStates));
        }
        
        toggleRitualContainer(show) {
            if (show === undefined) {
                this.isContainerVisible = !this.isContainerVisible;
            } else {
                this.isContainerVisible = show;
            }
            
            if (this.container) {
                this.container.classList.toggle('hidden', !this.isContainerVisible);
            }
            
            // Görünürlük durumunu kaydet
            localStorage.setItem('utc_ritual_visible', this.isContainerVisible);
        }
        
        renderRituals() {
            if (!this.ritualList) return;
            
            this.ritualList.innerHTML = '';
            
            this.rituals.forEach(ritual => {
                const ritualElement = document.createElement('div');
                ritualElement.className = `ritual-item ${ritual.active ? 'active' : ''} ${ritual.prepared ? 'prepared' : ''}`;
                ritualElement.dataset.ritualId = ritual.id;
                
                // Aktif etiketini ekle
                if (ritual.active) {
                    const activeLabel = document.createElement('span');
                    activeLabel.className = 'ritual-active-label';
                    activeLabel.textContent = 'AKTİF';
                    ritualElement.appendChild(activeLabel);
                    ritualElement.classList.add('ritual-active');
                }
                
                let durationText = this.formatTime(ritual.duration);
                if (ritual.active && ritual.remainingTime) {
                    durationText = this.formatTime(ritual.remainingTime);
                }
                
                ritualElement.innerHTML += `
                    <div class="ritual-item-header">
                        <div class="ritual-item-title">${ritual.name}</div>
                        <div class="ritual-item-duration">⏱️ ${durationText}</div>
                    </div>
                    <div class="ritual-item-description">${ritual.description}</div>
                    <div class="ritual-item-effect">${ritual.effect}</div>
                    <div class="ritual-item-cost">Enerji: ${ritual.energyCost}%</div>
                    <div class="ritual-item-progress">
                        <div class="ritual-item-progress-bar" style="width: ${ritual.prepProgress}%"></div>
                    </div>
                `;
                
                // Tıklama olayı ekle
                ritualElement.addEventListener('click', () => {
                    this.selectRitual(ritual.id);
                });
                
                this.ritualList.appendChild(ritualElement);
            });
            
            // Status metnini güncelle
            this.updateStatusText();
        }
        
        selectRitual(ritualId) {
            this.selectedRitualId = ritualId;
            
            // Seçili ritüeli vurgula
            const ritualItems = this.ritualList.querySelectorAll('.ritual-item');
            ritualItems.forEach(item => {
                if (item.dataset.ritualId === ritualId) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
            
            // Status metnini güncelle
            this.updateStatusText();
        }
        
        updateStatusText() {
            if (!this.ritualStatus) return;
            
            const selectedRitual = this.rituals.find(r => r.id === this.selectedRitualId);
            
            if (!selectedRitual) {
                this.ritualStatus.textContent = 'Aktif ritüel yok. Bir ritüel seçip hazırlayın.';
                return;
            }
            
            if (selectedRitual.active) {
                const remainingText = this.formatTime(selectedRitual.remainingTime);
                this.ritualStatus.textContent = `${selectedRitual.name} aktif. Kalan süre: ${remainingText}`;
            } else if (selectedRitual.prepared) {
                this.ritualStatus.textContent = `${selectedRitual.name} hazır. Aktifleştirmek için tıklayın.`;
            } else if (this.prepInterval && selectedRitual.prepProgress > 0) {
                this.ritualStatus.textContent = `${selectedRitual.name} hazırlanıyor... (${Math.round(selectedRitual.prepProgress)}%)`;
            } else {
                this.ritualStatus.textContent = `${selectedRitual.name} seçildi. Hazırlamak için tıklayın.`;
            }
        }
        
        prepareSelectedRitual() {
            if (!this.selectedRitualId) {
                this.app.showNotification('Lütfen önce bir ritüel seçin!', 'warning');
                return;
            }
            
            const ritual = this.rituals.find(r => r.id === this.selectedRitualId);
            
            if (!ritual) return;
            
            // Zaten hazırlanmışsa veya aktifse
            if (ritual.prepared) {
                this.app.showNotification(`${ritual.name} zaten hazır!`, 'info');
                return;
            }
            
            if (ritual.active) {
                this.app.showNotification(`${ritual.name} zaten aktif!`, 'info');
                return;
            }
            
            // Enerji kontrolü
            if (!this.app.energyManager || this.app.energyManager.currentEnergy < ritual.energyCost) {
                this.app.showNotification(`Yeterli enerji yok! ${ritual.energyCost}% enerji gerekiyor.`, 'danger');
                if (this.app.speak) {
                    this.app.speak(`Ritüeli hazırlamak için yeterli enerji yok. ${ritual.energyCost} birim enerji gerekiyor.`);
                }
                return;
            }
            
            // Hazırlanmaya başla
            ritual.prepProgress = 0;
            
            // Sesli bildirim
            if (this.app.speak) {
                this.app.speak(`${ritual.name} ritüeli hazırlanıyor. Lütfen bekleyin.`);
            }
            
            this.app.showNotification(`${ritual.name} ritüeli hazırlanmaya başladı...`, 'info');
            
            // Enerji tüketimi
            this.app.energyManager.useEnergy(ritual.energyCost / 2); // Yarısını şimdi kullan
            
            // Hazırlanma zamanlayıcısı
            if (this.prepInterval) {
                clearInterval(this.prepInterval);
            }
            
            const updateInterval = 100; // 100ms'de bir güncelle
            const progressStep = (updateInterval / ritual.preparationTime) * 100;
            
            this.prepInterval = setInterval(() => {
                ritual.prepProgress += progressStep;
                
                // İlerlemeyi UI'da güncelle
                const progressBar = this.ritualList.querySelector(`[data-ritual-id="${ritual.id}"] .ritual-item-progress-bar`);
                if (progressBar) {
                    progressBar.style.width = `${ritual.prepProgress}%`;
                }
                
                this.updateStatusText();
                
                // Hazırlık tamamlandı mı?
                if (ritual.prepProgress >= 100) {
                    ritual.prepProgress = 100;
                    ritual.prepared = true;
                    clearInterval(this.prepInterval);
                    this.prepInterval = null;
                    
                    // Diğer yarı enerjiyi kullan
                    this.app.energyManager.useEnergy(ritual.energyCost / 2);
                    
                    this.app.showNotification(`${ritual.name} ritüeli hazırlandı! Aktifleştirmek için tıklayın.`, 'success');
                    
                    if (this.app.speak) {
                        this.app.speak(`${ritual.name} ritüeli hazır. Aktifleştirmek için ritüel aktifleştir butonuna tıklayın.`);
                    }
                    
                    // Ritüel listesini yenile
                    this.renderRituals();
                }
            }, updateInterval);
        }
        
        activateSelectedRitual() {
            if (!this.selectedRitualId) {
                this.app.showNotification('Lütfen önce bir ritüel seçin!', 'warning');
                return;
            }
            
            const ritual = this.rituals.find(r => r.id === this.selectedRitualId);
            
            if (!ritual) return;
            
            // Aktifse zaten
            if (ritual.active) {
                this.app.showNotification(`${ritual.name} zaten aktif!`, 'info');
                return;
            }
            
            // Hazır değilse
            if (!ritual.prepared) {
                this.app.showNotification(`${ritual.name} henüz hazır değil! Önce hazırlayın.`, 'warning');
                return;
            }
            
            // Ritüeli aktifleştir
            ritual.active = true;
            ritual.prepared = false; // Hazırlık durumunu sıfırla
            ritual.activatedAt = new Date();
            ritual.remainingTime = ritual.duration;
            
            // Ritüel efektlerini uygula
            this.applyRitualEffects(ritual);
            
            // Zamanlayıcıyı başlat
            this.startRitualTimer(ritual);
            
            // Sesli bildirim
            if (this.app.speak) {
                this.app.speak(`${ritual.name} ritüeli aktifleştirildi. Tüm gizli güçler artık emrinde. Süre: ${this.formatTime(ritual.duration)}.`);
            }
            
            // Bildirim
            this.app.showNotification(`${ritual.name} ritüeli aktifleştirildi! Süre: ${this.formatTime(ritual.duration)}.`, 'success');
            
            // Görsel efekt
            const ritualElement = this.ritualList.querySelector(`[data-ritual-id="${ritual.id}"]`);
            if (ritualElement) {
                ritualElement.classList.add('ritual-activate-effect');
                setTimeout(() => {
                    ritualElement.classList.remove('ritual-activate-effect');
                }, 500);
            }
            
            // Ritüel listesini yenile
            this.renderRituals();
            
            // Ritüel durumlarını kaydet
            this.saveRitualStates();
        }
        
        startRitualTimer(ritual) {
            // Önceki zamanlayıcıyı temizle
            if (this.ritualIntervals[ritual.id]) {
                clearInterval(this.ritualIntervals[ritual.id]);
            }
            
            const updateInterval = 1000; // 1 saniyede bir güncelle
            
            this.ritualIntervals[ritual.id] = setInterval(() => {
                ritual.remainingTime -= updateInterval;
                
                // İlerlemeyi UI'da güncelle
                this.updateStatusText();
                
                // Süre doldu mu?
                if (ritual.remainingTime <= 0) {
                    ritual.active = false;
                    ritual.activatedAt = null;
                    clearInterval(this.ritualIntervals[ritual.id]);
                    delete this.ritualIntervals[ritual.id];
                    
                    // Efektleri kaldır
                    this.removeRitualEffects(ritual);
                    
                    this.app.showNotification(`${ritual.name} ritüeli sona erdi.`, 'info');
                    
                    if (this.app.speak) {
                        this.app.speak(`${ritual.name} ritüeli sona erdi. Gizli güçler artık erişilebilir değil.`);
                    }
                    
                    // Ritüel listesini yenile
                    this.renderRituals();
                    
                    // Ritüel durumlarını kaydet
                    this.saveRitualStates();
                }
                
                // Her 10 saniyede bir ritüel durumlarını kaydet
                if (ritual.remainingTime % 10000 === 0) {
                    this.saveRitualStates();
                }
            }, updateInterval);
        }
        
        applyRitualEffects(ritual) {
            if (!this.app) return;
            
            switch (ritual.type) {
                case 'trend':
                    // Trend analiz hassasiyetini artır
                    if (this.app.marketStructureAnalyzer) {
                        this.app._originalMarketStructureThreshold = this.app.marketStructureAnalyzer.trendThreshold || 0.5;
                        this.app.marketStructureAnalyzer.trendThreshold = this.app._originalMarketStructureThreshold * 0.75;
                    }
                    // Trend görselleştirmesini geliştir
                    if (this.app.chartManager) {
                        this.app.chartManager.trendVisualizationEnhanced = true;
                    }
                    break;
                
                case 'confluence':
                    // Uyum skorlarını artır
                    if (this.app.confluenceEngine) {
                        this.app._originalConfluenceMultiplier = this.app.confluenceEngine.confluenceMultiplier || 1.0;
                        this.app.confluenceEngine.confluenceMultiplier = this.app._originalConfluenceMultiplier * 1.35;
                    }
                    // Çoklu zaman dilimi doğruluğunu artır
                    if (this.app.multiTimeframeManager) {
                        this.app._originalMtfAccuracyFactor = this.app.multiTimeframeManager.accuracyFactor || 1.0;
                        this.app.multiTimeframeManager.accuracyFactor = this.app._originalMtfAccuracyFactor * 1.25;
                    }
                    break;
                
                case 'liquidity':
                    // Likidite tespitini geliştir
                    if (this.app.heatmapManager) {
                        this.app._originalLiquiditySensitivity = this.app.heatmapManager.liquiditySensitivity || 1.0;
                        this.app.heatmapManager.liquiditySensitivity = this.app._originalLiquiditySensitivity * 1.4;
                    }
                    // Emir duvarı tespitini geliştir
                    if (this.app.spoofDetector) {
                        this.app._originalSpoofThreshold = this.app.spoofDetector.threshold || 20;
                        this.app.spoofDetector.threshold = this.app._originalSpoofThreshold * 0.7;
                    }
                    break;
                
                case 'orderflow':
                    // Emir akışı analizini geliştir
                    this.app._originalOrderFlowSensitivity = this.app.settings?.orderFlowSensitivity || 1.0;
                    if (this.app.settings) {
                        this.app.settings.orderFlowSensitivity = this.app._originalOrderFlowSensitivity * 1.3;
                    }
                    // Piyasa katılımcı analizini geliştir
                    this.app._originalParticipantDetection = this.app.settings?.participantDetection || 1.0;
                    if (this.app.settings) {
                        this.app.settings.participantDetection = this.app._originalParticipantDetection * 1.25;
                    }
                    break;
                
                case 'protection':
                    // Manipülasyon tespitini geliştir
                    if (this.app.manipulationDetector) {
                        this.app._originalManipulationThreshold = this.app.manipulationDetector.threshold || 0.5;
                        this.app.manipulationDetector.threshold = this.app._originalManipulationThreshold * 0.6;
                    }
                    // Risk koruma faktörünü geliştir
                    this.app._originalRiskFactor = this.app.settings?.riskFactor || 1.0;
                    if (this.app.settings) {
                        this.app.settings.riskFactor = this.app._originalRiskFactor * 1.35;
                    }
                    break;
            }
            
            // Ritüel aktif edildiğini bildir
            this.app.emit('ritualActivated', {
                ritualId: ritual.id,
                ritualName: ritual.name,
                ritualType: ritual.type,
                duration: ritual.duration
            });
            
            // Aktif görsel efekt
            const chartElement = document.getElementById('live-chart');
            if (chartElement) {
                chartElement.classList.add(`ritual-effect-${ritual.type}`);
            }
        }
        
        removeRitualEffects(ritual) {
            if (!this.app) return;
            
            switch (ritual.type) {
                case 'trend':
                    if (this.app.marketStructureAnalyzer && this.app._originalMarketStructureThreshold !== undefined) {
                        this.app.marketStructureAnalyzer.trendThreshold = this.app._originalMarketStructureThreshold;
                    }
                    if (this.app.chartManager) {
                        this.app.chartManager.trendVisualizationEnhanced = false;
                    }
                    break;
                
                case 'confluence':
                    if (this.app.confluenceEngine && this.app._originalConfluenceMultiplier !== undefined) {
                        this.app.confluenceEngine.confluenceMultiplier = this.app._originalConfluenceMultiplier;
                    }
                    if (this.app.multiTimeframeManager && this.app._originalMtfAccuracyFactor !== undefined) {
                        this.app.multiTimeframeManager.accuracyFactor = this.app._originalMtfAccuracyFactor;
                    }
                    break;
                
                case 'liquidity':
                    if (this.app.heatmapManager && this.app._originalLiquiditySensitivity !== undefined) {
                        this.app.heatmapManager.liquiditySensitivity = this.app._originalLiquiditySensitivity;
                    }
                    if (this.app.spoofDetector && this.app._originalSpoofThreshold !== undefined) {
                        this.app.spoofDetector.threshold = this.app._originalSpoofThreshold;
                    }
                    break;
                
                case 'orderflow':
                    if (this.app.settings && this.app._originalOrderFlowSensitivity !== undefined) {
                        this.app.settings.orderFlowSensitivity = this.app._originalOrderFlowSensitivity;
                    }
                    if (this.app.settings && this.app._originalParticipantDetection !== undefined) {
                        this.app.settings.participantDetection = this.app._originalParticipantDetection;
                    }
                    break;
                
                case 'protection':
                    if (this.app.manipulationDetector && this.app._originalManipulationThreshold !== undefined) {
                        this.app.manipulationDetector.threshold = this.app._originalManipulationThreshold;
                    }
                    if (this.app.settings && this.app._originalRiskFactor !== undefined) {
                        this.app.settings.riskFactor = this.app._originalRiskFactor;
                    }
                    break;
            }
            
            // Ritüel sonlandığını bildir
            this.app.emit('ritualDeactivated', {
                ritualId: ritual.id,
                ritualName: ritual.name,
                ritualType: ritual.type
            });
            
            // Görsel efekti kaldır
            const chartElement = document.getElementById('live-chart');
            if (chartElement) {
                chartElement.classList.remove(`ritual-effect-${ritual.type}`);
            }
        }
        
        checkActiveRituals() {
            // Aktif ritüelleri kontrol et ve gerekirse zamanlayıcıyı yeniden başlat
            this.rituals.forEach(ritual => {
                if (ritual.active && ritual.activatedAt) {
                    const elapsedTime = Date.now() - ritual.activatedAt;
                    ritual.remainingTime = Math.max(0, ritual.duration - elapsedTime);
                    
                    if (ritual.remainingTime > 0) {
                        this.applyRitualEffects(ritual);
                        this.startRitualTimer(ritual);
                    } else {
                        ritual.active = false;
                        ritual.activatedAt = null;
                    }
                }
            });
        }
        
        formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
        
        getActiveRituals() {
            return this.rituals.filter(r => r.active);
        }
    }
    
    /* =================================================================
       ENERGY MANAGEMENT SYSTEM
       ================================================================= */
    class EnergyManager {
        constructor(app) {
            this.app = app;
            this.currentEnergy = 80; // Başlangıç değeri %80
            this.maxEnergy = 100;
            this.minEnergy = 10;
            this.decayRate = 0.05; // Saniyede %0.05 azalma
            this.lastUpdateTime = Date.now();
            this.isVisible = true;
            this.criticalThreshold = 20; // %20'nin altı kritik seviye
            
            // Enerji optimizasyonu için sıcaklık değeri
            this.systemHeat = 0; // 0-100 arası
            this.coolingRate = 0.1; // Saniyede %0.1 soğuma
            
            // UI elemanları
            this.energyBox = document.getElementById('energy-box');
            this.energyFill = document.getElementById('energy-fill');
            this.energyLevel = document.getElementById('energy-level');
            this.energyTime = document.getElementById('energy-time');
            this.energyStatus = document.getElementById('energy-status');
            
            // Event'ları bağla
            this.bindEvents();
            
            // Zamanlayıcıyı başlat
            this.startTimer();
            
            // Sayfanın yüklenmesinde görünürlüğü kontrol et
            this.loadVisibilityState();
        }
        
        bindEvents() {
            // Event binding işlemleri
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    // Sayfa arka planda, enerji tüketimini azalt
                    this.decayRate = 0.02;
                } else {
                    // Sayfa aktif, enerji tüketimini normale döndür
                    this.decayRate = 0.05;
                    this.updateUI(); // UI'ı güncelle
                }
            });
            
            // Sistemdeki olayların enerji üzerindeki etkilerini izle
            if (this.app) {
                // Sinyal oluştuğunda
                this.app.on('signal', () => {
                    this.useEnergy(5); // Sinyal oluşturma %5 enerji tüketir
                });
                
                // Analiz yapıldığında
                this.app.on('analysis', () => {
                    this.useEnergy(2); // Analiz %2 enerji tüketir
                });
                
                // Savaş modu aktifleştiğinde
                this.app.on('combatMode', (isActive) => {
                    if (isActive) {
                        this.decayRate = 0.1; // Savaş modunda enerji 2 kat hızlı tükenir
                    } else {
                        this.decayRate = 0.05; // Normal moda dönünce eski hızına döner
                    }
                });
            }
        }
        
        startTimer() {
            // Her saniye enerjiyi güncelle
            setInterval(() => {
                this.updateEnergy();
            }, 1000);
        }
        
        updateEnergy() {
            const now = Date.now();
            const deltaTime = (now - this.lastUpdateTime) / 1000; // Saniye cinsinden geçen süre
            this.lastUpdateTime = now;
            
            // Enerjiyi azalt
            const decayAmount = this.decayRate * deltaTime;
            this.currentEnergy = Math.max(this.minEnergy, this.currentEnergy - decayAmount);
            
            // Sistem ısısını soğut
            this.systemHeat = Math.max(0, this.systemHeat - this.coolingRate * deltaTime);
            
            // UI'ı güncelle
            this.updateUI();
            
            // Kritik enerji seviyesi kontrolü
            this.checkCriticalEnergy();
            
            // Enerji değerini kaydet
            localStorage.setItem('utc_energy_level', this.currentEnergy);
        }
        
        updateUI() {
            if (!this.energyFill || !this.energyLevel || !this.energyTime || !this.energyStatus) return;
            
            // Enerji çubuğunu güncelle
            this.energyFill.style.width = `${this.currentEnergy}%`;
            this.energyLevel.textContent = `${Math.round(this.currentEnergy)}%`;
            
            // Saat bilgisini güncelle
            const now = new Date();
            this.energyTime.textContent = now.toLocaleTimeString();
            
            // Durum metnini güncelle
            this.updateStatusText();
            
            // Düşük enerji görsel uyarısı
            if (this.currentEnergy < this.criticalThreshold) {
                this.energyBox.classList.add('energy-low');
            } else {
                this.energyBox.classList.remove('energy-low');
            }
        }
        
        updateStatusText() {
            if (!this.energyStatus) return;
            
            if (this.currentEnergy < this.criticalThreshold) {
                this.energyStatus.textContent = 'KRİTİK: Enerji seviyesi düşük!';
            } else if (this.currentEnergy < 50) {
                this.energyStatus.textContent = 'Enerji seviyesi azalıyor';
            } else if (this.systemHeat > 70) {
                this.energyStatus.textContent = 'Sistem sıcaklığı yüksek';
            } else {
                this.energyStatus.textContent = 'Normal işleyiş sürüyor';
            }
        }
        
        checkCriticalEnergy() {
            // Enerji kritik seviyenin altına düştüğünde uyarı ver ve işlemleri optimize et
            if (this.currentEnergy < this.criticalThreshold && !this._warnedAboutEnergy) {
                this._warnedAboutEnergy = true;
                this.app.showNotification('KRİTİK ENERJİ SEVİYESİ! Sistem performansı düşürülüyor.', 'danger');
                
                // TTS ile uyarı
                if (this.app && this.app.speak) {
                    this.app.speak('Dikkat! Kritik enerji seviyesi. Sistem performansı düşürülüyor. Lütfen enerji seviyesini optimize edin.');
                }
                
                // Performansı düşür ve enerji tasarruf moduna geç
                if (this.app) {
                    // Analiz aralığını uzat
                    if (this.app.analysisInterval) {
                        clearInterval(this.app.analysisInterval);
                        this.app.analysisInterval = setInterval(() => this.app.runPeriodicAnalysis(), 10000); // 5s yerine 10s
                    }
                    
                    // Render aralığını uzat
                    if (this.app.renderInterval) {
                        clearInterval(this.app.renderInterval);
                        this.app.renderInterval = setInterval(() => this.app.render(), 500); // 250ms yerine 500ms
                    }
                }
            } else if (this.currentEnergy >= 30 && this._warnedAboutEnergy) {
                this._warnedAboutEnergy = false;
                
                // Enerji normal seviyeye döndü, performansı normale getir
                if (this.app) {
                    // Analiz aralığını normale getir
                    if (this.app.analysisInterval) {
                        clearInterval(this.app.analysisInterval);
                        this.app.analysisInterval = setInterval(() => this.app.runPeriodicAnalysis(), 5000);
                    }
                    
                    // Render aralığını normale getir
                    if (this.app.renderInterval) {
                        clearInterval(this.app.renderInterval);
                        this.app.renderInterval = setInterval(() => this.app.render(), 250);
                    }
                }
            }
        }
        
        useEnergy(amount) {
            this.currentEnergy = Math.max(this.minEnergy, this.currentEnergy - amount);
            this.systemHeat = Math.min(100, this.systemHeat + amount * 1.5);
            this.updateUI();
        }
        
        addEnergy(amount) {
            this.currentEnergy = Math.min(this.maxEnergy, this.currentEnergy + amount);
            this.updateUI();
        }
        
        boostEnergy() {
            // Enerjiyi %15 artır ancak sistem ısısını %10 artır (yan etki)
            this.addEnergy(15);
            this.systemHeat = Math.min(100, this.systemHeat + 10);
            this.updateStatusText();
            
            this.app.showNotification('Sistem enerjisi güçlendirildi! Sistem ısısı arttı.', 'success');
            if (this.app && this.app.speak) {
                this.app.speak('Sistem enerjisi güçlendirildi. Performans artışı sağlandı. Sistem ısısı yükseliyor.');
            }
        }
        
        optimizeEnergy() {
            // Sistem ısısını %20 düşür ve enerji tüketim oranını %20 azalt
            this.systemHeat = Math.max(0, this.systemHeat - 20);
            const originalDecayRate = this.decayRate;
            this.decayRate *= 0.8; // %20 daha az enerji tüketimi
            
            // 30 saniye sonra normal değere dön
            setTimeout(() => {
                this.decayRate = originalDecayRate;
            }, 30000);
            
            this.app.showNotification('Sistem enerjisi optimize edildi. Tüketim 30 saniyeliğine azaltıldı.', 'info');
            if (this.app && this.app.speak) {
                this.app.speak('Enerji optimizasyonu başarılı. Sistem ısısı düşürüldü ve enerji tüketimi geçici olarak azaltıldı.');
            }
        }
        
        recycleEnergy() {
            // Kullanılmayan işlemleri temizle ve o enerjiyi geri kazan
            let recycledAmount = 5;
            
            // Eski sinyalleri temizle
            if (this.app && this.app.signals && this.app.signals.length > 50) {
                // 50'den fazla sinyal varsa, en eski 10 tanesini temizle
                this.app.signals = this.app.signals.slice(-50);
                recycledAmount += 5;
            }
            
            // Kullanılmayan önerileri temizle
            if (this.app && this.app.confluenceEngine && this.app.confluenceEngine.proposals) {
                const oldLength = this.app.confluenceEngine.proposals.length;
                // 5 dakikadan eski önerileri temizle
                const fiveMinutesAgo = Date.now() - 5 * 60 * 1000;
                this.app.confluenceEngine.proposals = this.app.confluenceEngine.proposals.filter(p => p.timestamp > fiveMinutesAgo);
                
                const removedCount = oldLength - this.app.confluenceEngine.proposals.length;
                recycledAmount += removedCount;
            }
            
            // Bellekteki büyük verileri temizle (olmayan seriler gibi)
            if (window.gc) { // JavaScript'in garbage collector'ı varsa çağır (çoğu tarayıcıda yok)
                try {
                    window.gc();
                    recycledAmount += 3;
                } catch (e) {}
            }
            
            this.addEnergy(recycledAmount);
            this.app.showNotification(`Enerji geri dönüşümü tamamlandı. ${recycledAmount}% enerji kazanıldı.`, 'success');
            if (this.app && this.app.speak) {
                this.app.speak(`Enerji geri dönüşümü başarılı. Kullanılmayan kaynaklar temizlendi ve yüzde ${recycledAmount} enerji geri kazanıldı.`);
            }
        }
        
        toggleEnergyBox(show) {
            if (show === undefined) {
                this.isVisible = !this.isVisible;
            } else {
                this.isVisible = show;
            }
            
            if (this.energyBox) {
                this.energyBox.style.display = this.isVisible ? 'block' : 'none';
            }
            
            // Görünürlük durumunu kaydet
            localStorage.setItem('utc_energy_box_visible', this.isVisible);
        }
        
        loadVisibilityState() {
            const savedEnergy = parseFloat(localStorage.getItem('utc_energy_level'));
            if (!isNaN(savedEnergy)) {
                this.currentEnergy = savedEnergy;
            }
            
            const visible = localStorage.getItem('utc_energy_box_visible');
            if (visible === 'false') {
                this.toggleEnergyBox(false);
            }
            
            this.updateUI();
        }
    }
    
    /* =================================================================
       MARKET MANIPULATION DETECTION
       ================================================================= */
    class MarketManipulationDetector {
        constructor(app) {
            this.app = app;
            this.thresholds = {
                volumeSpike: 3.0,   // Normal hacmin 3 katı
                priceJump: 0.025,   // %2.5'luk ani fiyat değişimi
                orderBookImbalance: 0.7  // %70 tek yönde dengesizlik
            };
            this.detectionWindow = 10;  // Son 10 mum
            this.lastAlert = 0;
            this.alertCooldown = 300000;  // 5 dakika
        }
        
        // Hacim anomalilerini tespit et
        detectVolumeAnomalies(candles) {
            if (candles.length < 30) return false;
            
            // Son 20 mumu analiz et
            const recentCandles = candles.slice(-30);
            const volumes = recentCandles.map(c => c.volume);
            
            // Ortalama ve standart sapma hesapla (son 30 mumdan)
            const avgVolume = volumes.reduce((sum, vol) => sum + vol, 0) / volumes.length;
            const stdDev = Math.sqrt(volumes.reduce((sum, vol) => sum + Math.pow(vol - avgVolume, 2), 0) / volumes.length);
            
            // Son 3 mum için kontrol et
            const latestVolumes = volumes.slice(-3);
            
            for (const volume of latestVolumes) {
                // Z-skoru hesapla
                const zScore = (volume - avgVolume) / stdDev;
                
                if (zScore > this.thresholds.volumeSpike) {
                    return {
                        type: 'volumeSpike',
                        value: volume,
                        avg: avgVolume,
                        zScore: zScore
                    };
                }
            }
            
            return false;
        }
        
        // Ani fiyat hareketlerini tespit et
        detectPriceJumps(candles) {
            if (candles.length < 10) return false;
            
            const recentCandles = candles.slice(-10);
            
            for (let i = 1; i < recentCandles.length; i++) {
                const prevClose = recentCandles[i-1].close;
                const currentClose = recentCandles[i].close;
                
                const priceChange = Math.abs((currentClose - prevClose) / prevClose);
                
                if (priceChange > this.thresholds.priceJump) {
                    return {
                        type: 'priceJump',
                        from: prevClose,
                        to: currentClose,
                        change: priceChange
                    };
                }
            }
            
            return false;
        }
        
        // Emir defteri dengesizliğini tespit et (bakiyelerinizi kullanarak)
        detectOrderBookImbalance() {
            if (!this.app || !this.app.marketData || !this.app.marketData.orderBook) return false;
            
            const orderBook = this.app.marketData.orderBook;
            
            // Toplam alım ve satım miktarını hesapla
            const totalBids = orderBook.bids.reduce((sum, [price, amount]) => sum + amount, 0);
            const totalAsks = orderBook.asks.reduce((sum, [price, amount]) => sum + amount, 0);
            
            // Oran hesapla
            const totalOrders = totalBids + totalAsks;
            if (totalOrders === 0) return false;
            
            const bidRatio = totalBids / totalOrders;
            const askRatio = totalAsks / totalOrders;
            
            // Dengesizliği kontrol et
            if (bidRatio > this.thresholds.orderBookImbalance) {
                return {
                    type: 'buyImbalance',
                    ratio: bidRatio
                };
            } else if (askRatio > this.thresholds.orderBookImbalance) {
                return {
                    type: 'sellImbalance',
                    ratio: askRatio
                };
            }
            
            return false;
        }
        
        // Ana algılama metodu
        detect() {
            if (!this.app || !this.app.candles) return false;
            
            const now = Date.now();
            if (now - this.lastAlert < this.alertCooldown) return false;  // Çok sık uyarı verme
            
            // Hacim anomalilerini kontrol et
            const volumeAnomaly = this.detectVolumeAnomalies(this.app.candles);
            
            // Ani fiyat hareketlerini kontrol et
            const priceJump = this.detectPriceJumps(this.app.candles);
            
            // Emir defteri dengesizliğini kontrol et
            const orderBookImbalance = this.detectOrderBookImbalance();
            
            // Herhangi bir manipülasyon tespit edildi mi?
            if (volumeAnomaly || priceJump || orderBookImbalance) {
                this.lastAlert = now;
                
                let alertType = '';
                let alertMessage = '';
                
                if (volumeAnomaly) {
                    alertType = 'volumeSpike';
                    alertMessage = `Anormal işlem hacmi tespit edildi! Normal hacmin ${volumeAnomaly.zScore.toFixed(1)} katı.`;
                } else if (priceJump) {
                    alertType = 'priceJump';
                    alertMessage = `Ani fiyat hareketi tespit edildi! ${(priceJump.change * 100).toFixed(2)}% değişim.`;
                } else if (orderBookImbalance) {
                    alertType = orderBookImbalance.type;
                    alertMessage = `Emir defteri dengesizliği tespit edildi! ${(orderBookImbalance.ratio * 100).toFixed(0)}% ${orderBookImbalance.type === 'buyImbalance' ? 'alım' : 'satım'} hakimiyeti.`;
                }
                
                return {
                    type: alertType,
                    message: alertMessage,
                    timestamp: now
                };
            }
            
            return false;
        }
    }
    
    /* =================================================================
       ENHANCED RISK MANAGEMENT SYSTEM
       ================================================================= */
    class EnhancedRiskManagement {
        constructor(app) {
            this.app = app;
            this.maxDrawdown = 0;
            this.historicalVolatility = 0;
            this.valueAtRisk = 0;
            this.riskAnalysisEnabled = false;
            this.dynamicPositionSizing = true;
            this.correlationMatrix = {};
            this.optimalLeverage = 1.0;
            this.volatilityThresholds = {
                low: 0.5,
                medium: 1.0,
                high: 2.0,
                extreme: 3.0
            };
            this.riskMetrics = {
                sharpeRatio: 0,
                sortinoRatio: 0,
                calmarRatio: 0,
                maxDrawdown: 0,
                winRate: 0,
                profitFactor: 0
            };
            
            this.init();
        }
        
        init() {
            this.calculateHistoricalMetrics();
            this.scheduleRiskUpdates();
            this.bindControls();
            
            console.log('Enhanced Risk Management System initialized');
        }
        
        bindControls() {
            // Add risk controls to settings panel
            const settingsContainer = document.getElementById('modal-features');
            
            if (settingsContainer) {
                const riskControlsHTML = `
                    <div class="settings-item">
                        <label for="dynamic-position-sizing">Dynamic Position Sizing</label>
                        <div class="toggle-switch">
                            <input type="checkbox" id="dynamic-position-sizing" ${this.dynamicPositionSizing ? 'checked' : ''}>
                            <span class="toggle-slider"></span>
                        </div>
                    </div>
                    <div class="settings-item">
                        <label for="risk-analysis">Advanced Risk Analysis</label>
                        <div class="toggle-switch">
                            <input type="checkbox" id="risk-analysis" ${this.riskAnalysisEnabled ? 'checked' : ''}>
                            <span class="toggle-slider"></span>
                        </div>
                    </div>
                `;
                
                const riskDiv = document.createElement('div');
                riskDiv.className = 'settings-group';
                riskDiv.innerHTML = `<div class="panel-title">Risk Management</div>${riskControlsHTML}`;
                
                settingsContainer.appendChild(riskDiv);
                
                // Add event listeners
                document.getElementById('dynamic-position-sizing')?.addEventListener('change', (e) => {
                    this.dynamicPositionSizing = e.target.checked;
                    this.app.showNotification(`Dynamic position sizing ${e.target.checked ? 'enabled' : 'disabled'}`, 'info');
                });
                
                document.getElementById('risk-analysis')?.addEventListener('change', (e) => {
                    this.riskAnalysisEnabled = e.target.checked;
                    if (e.target.checked) {
                        this.calculateRiskMetrics();
                        this.app.showNotification('Advanced risk analysis enabled', 'info');
                    } else {
                        this.app.showNotification('Advanced risk analysis disabled', 'info');
                    }
                });
            }
        }
        
        calculateHistoricalMetrics() {
            if (!this.app.candles || this.app.candles.length < 30) return;
            
            const candles = this.app.candles;
            const returns = [];
            
            // Calculate daily returns
            for (let i = 1; i < candles.length; i++) {
                const prevClose = candles[i-1].close;
                const currentClose = candles[i].close;
                returns.push((currentClose - prevClose) / prevClose);
            }
            
            // Calculate historical volatility
            this.historicalVolatility = this.calculateStandardDeviation(returns) * Math.sqrt(365); // Annualized
            
            // Calculate maximum drawdown
            let peak = -Infinity;
            let maxDrawdown = 0;
            
            for (let i = 0; i < candles.length; i++) {
                if (candles[i].close > peak) {
                    peak = candles[i].close;
                } else {
                    const drawdown = (peak - candles[i].close) / peak;
                    maxDrawdown = Math.max(maxDrawdown, drawdown);
                }
            }
            
            this.maxDrawdown = maxDrawdown;
            
            // Calculate VaR (Value at Risk)
            returns.sort((a, b) => a - b);
            const varIndex = Math.floor(returns.length * 0.05);
            this.valueAtRisk = Math.abs(returns[varIndex]);
            
            // Calculate optimal leverage based on volatility
            this.optimalLeverage = this.calculateOptimalLeverage();
        }
        
        calculateRiskMetrics() {
            if (!this.app.signals || this.app.signals.length < 5) return;
            
            const signals = this.app.signals;
            const returns = [];
            let wins = 0;
            let grossProfit = 0;
            let grossLoss = 0;
            
            // Process completed signals
            signals.filter(s => s.status === 'tp' || s.status === 'sl').forEach(signal => {
                const entryPrice = signal.price;
                const exitPrice = signal.exitPrice || entryPrice;
                const direction = signal.type === 'buy' ? 1 : -1;
                const returnPct = direction * (exitPrice - entryPrice) / entryPrice;
                
                returns.push(returnPct);
                
                if (returnPct > 0) {
                    wins++;
                    grossProfit += returnPct;
                } else {
                    grossLoss += Math.abs(returnPct);
                }
            });
            
            // Calculate metrics
            this.riskMetrics.winRate = signals.length > 0 ? wins / signals.length : 0;
            this.riskMetrics.profitFactor = grossLoss > 0 ? grossProfit / grossLoss : 0;
            
            // Calculate Sharpe Ratio
            const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;
            const stdDev = this.calculateStandardDeviation(returns);
            this.riskMetrics.sharpeRatio = stdDev > 0 ? avgReturn / stdDev : 0;
            
            // Calculate Sortino Ratio (only negative returns for denominator)
            const negativeReturns = returns.filter(r => r < 0);
            const downside = this.calculateStandardDeviation(negativeReturns);
            this.riskMetrics.sortinoRatio = downside > 0 ? avgReturn / downside : 0;
            
            // Calculate Calmar Ratio
            this.riskMetrics.calmarRatio = this.maxDrawdown > 0 ? avgReturn / this.maxDrawdown : 0;
            
            console.log('Risk metrics calculated:', this.riskMetrics);
        }
        
        calculateStandardDeviation(array) {
            const n = array.length;
            if (n === 0) return 0;
            
            const mean = array.reduce((sum, val) => sum + val, 0) / n;
            const variance = array.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / n;
            
            return Math.sqrt(variance);
        }
        
        calculateOptimalLeverage() {
            // Using Kelly Criterion for optimal leverage
            if (this.riskMetrics.winRate === 0) return 1.0;
            
            const winRate = this.riskMetrics.winRate;
            const avgWin = this.riskMetrics.profitFactor * (1 - winRate) / winRate;
            const avgLoss = 1;
            
            const kellyFraction = (winRate / avgLoss) - ((1 - winRate) / avgWin);
            return Math.max(0.5, Math.min(2.0, kellyFraction)); // Limit between 0.5x and 2x
        }
        
        getPositionSizing(baseSize) {
            if (!this.dynamicPositionSizing) return baseSize;
            
            // Adjust position size based on volatility and risk metrics
            let volatilityFactor = 1.0;
            
            if (this.historicalVolatility < this.volatilityThresholds.low) {
                volatilityFactor = 1.2; // Increase position size in low volatility
            } else if (this.historicalVolatility > this.volatilityThresholds.high) {
                volatilityFactor = 0.8; // Decrease position size in high volatility
            } else if (this.historicalVolatility > this.volatilityThresholds.extreme) {
                volatilityFactor = 0.5; // Significantly reduce position size in extreme volatility
            }
            
            // Adjust by win rate and profit factor
            let performanceFactor = 1.0;
            if (this.riskMetrics.winRate > 0.6 && this.riskMetrics.profitFactor > 1.5) {
                performanceFactor = 1.1; // Increase size when performing well
            } else if (this.riskMetrics.winRate < 0.4 || this.riskMetrics.profitFactor < 1.0) {
                performanceFactor = 0.9; // Decrease size when performing poorly
            }
            
            // Apply Kelly-based optimal leverage
            const leverageFactor = this.optimalLeverage;
            
            // Calculate final position size
            const adjustedSize = baseSize * volatilityFactor * performanceFactor * leverageFactor;
            
            return Math.max(baseSize * 0.5, Math.min(baseSize * 2.0, adjustedSize)); // Limit between 50%-200% of base size
        }
        
        scheduleRiskUpdates() {
            // Update risk metrics every 15 minutes
            setInterval(() => {
                if (this.riskAnalysisEnabled) {
                    this.calculateHistoricalMetrics();
                    this.calculateRiskMetrics();
                }
            }, 15 * 60 * 1000);
        }
        
        getCurrentRiskLevel() {
            // Determine current risk level based on volatility and metrics
            if (this.historicalVolatility > this.volatilityThresholds.extreme) {
                return 'extreme';
            } else if (this.historicalVolatility > this.volatilityThresholds.high) {
                return 'high';
            } else if (this.historicalVolatility > this.volatilityThresholds.medium) {
                return 'medium';
            } else {
                return 'low';
            }
        }
        
        getRiskReport() {
            return {
                riskLevel: this.getCurrentRiskLevel(),
                historicalVolatility: this.historicalVolatility,
                valueAtRisk: this.valueAtRisk,
                maxDrawdown: this.maxDrawdown,
                sharpeRatio: this.riskMetrics.sharpeRatio,
                sortinoRatio: this.riskMetrics.sortinoRatio,
                winRate: this.riskMetrics.winRate,
                profitFactor: this.riskMetrics.profitFactor,
                optimalLeverage: this.optimalLeverage
            };
        }
    }

</script>
<!-- === AI/ML Prediction Engine === -->
<script>
// --- LSTM Price Prediction (TensorFlow.js) ---
class LSTMPricePredictor {
    constructor() {
        this.model = null;
    }
    async buildModel(inputShape) {
        this.model = tf.sequential();
        this.model.add(tf.layers.lstm({units: 32, inputShape: inputShape, returnSequences: false}));
        this.model.add(tf.layers.dense({units: 1}));
        this.model.compile({optimizer: 'adam', loss: 'meanSquaredError'});
    }
    async train(prices, epochs=30) {
        // prices: [p1, p2, ...]
        const seqLen = 10;
        const xs = [], ys = [];
        for (let i = 0; i < prices.length - seqLen; i++) {
            xs.push(prices.slice(i, i+seqLen));
            ys.push(prices[i+seqLen]);
        }
        const xsTensor = tf.tensor3d(xs.map(x => x.map(v => [v])), [xs.length, seqLen, 1]);
        const ysTensor = tf.tensor2d(ys, [ys.length, 1]);
        await this.buildModel([seqLen, 1]);
        await this.model.fit(xsTensor, ysTensor, {epochs});
        xsTensor.dispose(); ysTensor.dispose();
    }
    predictNext(prices) {
        // prices: [p1, ..., p10]
        const input = tf.tensor3d([prices.map(v => [v])], [1, prices.length, 1]);
        const pred = this.model.predict(input);
        const val = pred.dataSync()[0];
        input.dispose(); pred.dispose();
        return val;
    }
}

// --- Random Forest Trend Classifier (ml.js) ---
class TrendRandomForest {
    constructor() {
        this.model = null;
    }
    train(features, labels) {
        // features: [[f1, f2, ...], ...], labels: [0,1,...]
        this.model = new ML.RandomForestClassifier({nEstimators: 20});
        this.model.train(features, labels);
    }
    predict(feature) {
        return this.model.predict([feature])[0];
    }
}

// --- SVM Support/Resistance Detector (ml.js) ---
class SupportResistanceSVM {
    constructor() {
        this.model = null;
    }
    train(features, labels) {
        // features: [[price, volume, ...]], labels: [0/1]
        this.model = new ML.SVM({kernel: 'rbf', c: 1.0});
        this.model.train(features, labels);
    }
    predict(feature) {
        return this.model.predict([feature])[0];
    }
}

// --- AI Prediction Engine ---
class AIPredictionEngine {
    constructor(app) {
        this.app = app;
        this.lstm = new LSTMPricePredictor();
        this.rf = new TrendRandomForest();
        this.svm = new SupportResistanceSVM();
        this.isTrained = false;
    }
    async trainAll() {
        // Fiyat verisiyle LSTM eğit
        const candles = this.app.candles || [];
        if (candles.length < 50) return;
        const prices = candles.map(c => c.close);
        await this.lstm.train(prices);
        // Trend için Random Forest eğit
        const features = [], labels = [];
        for (let i = 20; i < candles.length; i++) {
            const window = candles.slice(i-20, i);
            const mean = window.reduce((a,b)=>a+b.close,0)/20;
            const std = Math.sqrt(window.reduce((a,b)=>a+Math.pow(b.close-mean,2),0)/20);
            features.push([mean, std, window[19].volume]);
            labels.push(window[19].close > window[0].close ? 1 : 0); // 1: uptrend, 0: downtrend
        }
        this.rf.train(features, labels);
        // SVM ile destek/direnç eğit
        const srFeatures = [], srLabels = [];
        for (let i = 20; i < candles.length; i++) {
            const window = candles.slice(i-20, i);
            const max = Math.max(...window.map(c=>c.high));
            const min = Math.min(...window.map(c=>c.low));
            srFeatures.push([window[19].close, window[19].volume]);
            srLabels.push(Math.abs(window[19].close-max)<Math.abs(window[19].close-min)?1:0); // 1: resistance, 0: support
        }
        this.svm.train(srFeatures, srLabels);
        this.isTrained = true;
    }
    async predictAll() {
        if (!this.isTrained) return null;
        const candles = this.app.candles;
        if (!candles || candles.length < 30) return null;
        const lastPrices = candles.slice(-10).map(c=>c.close);
        const lstmPred = this.lstm.predictNext(lastPrices);
        const last = candles[candles.length-1];
        const mean = lastPrices.reduce((a,b)=>a+b,0)/lastPrices.length;
        const std = Math.sqrt(lastPrices.reduce((a,b)=>a+Math.pow(b-mean,2),0)/lastPrices.length);
        const rfPred = this.rf.predict([mean, std, last.volume]);
        const svmPred = this.svm.predict([last.close, last.volume]);
        return {
            pricePrediction: lstmPred,
            trend: rfPred ? 'YÜKSELİŞ' : 'DÜŞÜŞ',
            supportOrResistance: svmPred ? 'DİRENÇ' : 'DESTEK',
        };
    }
}

// --- Kehanet Paneli AI Entegrasyonu ---
window.addEventListener('DOMContentLoaded', async ()=>{
    if (!window.app) return;
    window.app.aiPredictionEngine = new AIPredictionEngine(window.app);
    await window.app.aiPredictionEngine.trainAll();
    // Kehanet Paneli butonuna tıklandığında AI tahminlerini göster
    const fab = document.getElementById('kehanet-fab');
    if (fab) {
        fab.addEventListener('click', async ()=>{
            const ai = window.app.aiPredictionEngine;
            if (!ai.isTrained) return;
            const pred = await ai.predictAll();
            if (!pred) return;
            
            // Chart üzerinde sinyalleri göster
            updateChartSignals(
                `${pred.pricePrediction.toFixed(2)}`,
                'ACTIVE',
                pred.trend
            );
            
            renderKehanetForecasts([
                {title:'BTC/USDT',desc:'AI LSTM fiyat tahmini',prediction:pred.pricePrediction.toFixed(2),confidence:80},
                {title:'Trend',desc:'Random Forest trend sınıflandırıcı',prediction:pred.trend,confidence:75},
                {title:'Destek/Direnç',desc:'SVM ile tespit',prediction:pred.supportOrResistance,confidence:70}
            ]);
        });
    }
});
</script>

<!-- DÖRT ATLI (FOUR HORSEMEN) MARKET REGIME SİSTEMİ ve PANTEON ENTEGRASYONU -->
<script>
// Four Horsemen Market Regime Detection System
class FourHorsemenSystem {
    constructor(app) {
        this.app = app;
        this.horsemen = { war: false, famine: false, pestilence: false, death: false };
        this.averageVolume = 0;
        this.averageRange = 0;
        this.trendStrength = 0;
        this.volatilityThreshold = 1.5;
        this.liquidityThreshold = 0.7;
        this.trendThreshold = 2.0;
        this.dropThreshold = -3.0;
        this.updateInterval = 60000;
        this.lastUpdate = 0;
        this.listeners = { regimeChange: [] };
    }
    async init() {
        if (!this.app || !this.app.candles) return;
        this.calculateBaseMetrics();
        this.updateHorsemen();
        setInterval(() => this.update(), this.updateInterval);
    }
    async update() {
        try {
            const now = Date.now();
            const elapsed = now - this.lastUpdate;
            if (elapsed < this.updateInterval * 0.9) return;
            this.lastUpdate = now;
            this.calculateBaseMetrics();
            this.updateHorsemen();
        } catch (error) { console.error("Four Horsemen güncelleme hatası:", error); }
    }
    calculateBaseMetrics() {
        if (!this.app.candles || this.app.candles.length < 20) return;
        const candles = this.app.candles.slice(-20);
        let totalVolume = 0;
        candles.forEach(candle => { totalVolume += candle.volume; });
        this.averageVolume = totalVolume / candles.length;
        let totalRange = 0;
        candles.forEach(candle => { totalRange += Math.abs(candle.high - candle.low); });
        this.averageRange = totalRange / candles.length;
        const prices = candles.map(c => c.close);
        this.trendStrength = this.calculateTrendStrength(prices);
    }
    calculateTrendStrength(prices) {
        const n = prices.length;
        let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
        for (let i = 0; i < n; i++) {
            sumX += i;
            sumY += prices[i];
            sumXY += i * prices[i];
            sumX2 += i * i;
        }
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        const normalizedSlope = (slope / prices[0]) * 100;
        return normalizedSlope;
    }
    updateHorsemen() {
        if (!this.app.candles || this.app.candles.length < 20) return;
        const candles = this.app.candles;
        const recent = candles.slice(-5);
        const current = candles[candles.length - 1];
        const previous = candles[candles.length - 2];
        const prevHorsemen = { ...this.horsemen };
        Object.keys(this.horsemen).forEach(key => { this.horsemen[key] = false; });
        const recentVolatility = this.calculateVolatility(recent.map(c => c.close));
        if (recentVolatility > this.volatilityThreshold) this.horsemen.war = true;
        const currentVolume = current.volume;
        if (currentVolume < this.averageVolume * this.liquidityThreshold) this.horsemen.famine = true;
        const recentTrendStrength = this.calculateTrendStrength(recent.map(c => c.close));
        if (Math.abs(recentTrendStrength) > Math.abs(this.trendStrength) * this.trendThreshold) this.horsemen.pestilence = true;
        const priceChange = ((current.close - previous.close) / previous.close) * 100;
        if (priceChange < this.dropThreshold) this.horsemen.death = true;
        if (this.hasRegimeChanged(prevHorsemen)) this.notifyRegimeChange();
        this.updateUI();
    }
    hasRegimeChanged(prevHorsemen) {
        for (const [key, value] of Object.entries(this.horsemen)) {
            if (prevHorsemen[key] !== value) return true;
        }
        return false;
    }
    notifyRegimeChange() {
        this.listeners.regimeChange.forEach(callback => { callback(this.getActiveRegime()); });
        const activeHorsemen = this.getActiveHorsemen();
        if (activeHorsemen.length > 0) {
            const message = `Mahşerin ${activeHorsemen.length > 1 ? "Atlıları" : "Atlısı"} görüldü: ${activeHorsemen.map(key => this.getHorsemanName(key)).join(", ")}`;
            if (this.app.notificationManager) {
                this.app.notificationManager.notify(message, 'warning', 3);
            } else {
                console.log(message);
            }
        }
    }
    calculateVolatility(prices) {
        const n = prices.length;
        if (n < 2) return 0;
        const avg = prices.reduce((sum, price) => sum + price, 0) / n;
        const variance = prices.reduce((sum, price) => sum + Math.pow(price - avg, 2), 0) / (n - 1);
        const stdDev = Math.sqrt(variance);
        return (stdDev / avg) * 100;
    }
    updateUI() {
        const container = document.getElementById('horsemen-container');
        if (!container) return;
        Object.entries(this.horsemen).forEach(([horseman, active]) => {
            const element = container.querySelector(`.horseman[data-type="${horseman}"]`);
            if (element) {
                element.classList.toggle('active', active);
                const icon = element.querySelector('.horseman-icon');
                if (icon) icon.style.opacity = active ? '1' : '0.3';
            }
        });
        const regimeElement = document.getElementById('current-regime');
        if (regimeElement) {
            const activeRegime = this.getActiveRegime();
            regimeElement.textContent = `Aktif Rejim: ${activeRegime}`;
            regimeElement.className = 'regime-indicator';
            regimeElement.classList.add(`regime-${activeRegime.toLowerCase()}`);
        }
    }
    getHorsemanName(key) {
        const names = { war: "Savaş", famine: "Kıtlık", pestilence: "Veba", death: "Ölüm" };
        return names[key] || key;
    }
    getActiveHorsemen() {
        return Object.entries(this.horsemen).filter(([_, active]) => active).map(([key, _]) => key);
    }
    isAnyHorsemanActive() {
        return Object.values(this.horsemen).some(active => active);
    }
    getActiveRegime() {
        const active = this.getActiveHorsemen();
        if (active.length === 0) return "Normal";
        if (active.includes("death")) return "Ölüm";
        if (active.includes("war")) return "Savaş";
        if (active.includes("pestilence")) return "Veba";
        if (active.includes("famine")) return "Kıtlık";
        return "Karışık";
    }
    onRegimeChange(callback) {
        if (typeof callback === 'function') this.listeners.regimeChange.push(callback);
    }
    updateThresholds(thresholds) {
        if (!thresholds) return;
        if (thresholds.volatility !== undefined) this.volatilityThreshold = thresholds.volatility;
        if (thresholds.liquidity !== undefined) this.liquidityThreshold = thresholds.liquidity;
        if (thresholds.trend !== undefined) this.trendThreshold = thresholds.trend;
        if (thresholds.drop !== undefined) this.dropThreshold = thresholds.drop;
        this.updateHorsemen();
    }
}

// Panteon ve Four Horsemen entegrasyonu
class PanteonHorsemenIntegration {
    constructor(app) {
        this.app = app;
        this.horsemenSystem = null;
        this.regimeHistory = [];
        this.maxHistorySize = 10;
    }
    async init() {
        this.horsemenSystem = new FourHorsemenSystem(this.app);
        this.horsemenSystem.init();
        this.horsemenSystem.onRegimeChange(regime => { this.recordRegimeChange(regime); });
        this.setupUIUpdater();
    }
    setupUIUpdater() {
        this.horsemenSystem.onRegimeChange(regime => {
            const regimeElement = document.getElementById('current-regime');
            if (regimeElement) {
                regimeElement.textContent = `Aktif Rejim: ${regime}`;
                regimeElement.className = 'regime-indicator';
                regimeElement.classList.add(`regime-${regime.toLowerCase()}`);
            }
        });
    }
    recordRegimeChange(regime) {
        const timestamp = new Date();
        this.regimeHistory.push({
            regime,
            timestamp,
            activeHorsemen: this.horsemenSystem ? this.horsemenSystem.getActiveHorsemen() : []
        });
        if (this.regimeHistory.length > this.maxHistorySize) this.regimeHistory.shift();
        // Rejim geçmişi tabloya yazılabilir
    }
    getRegimeHistory() { return this.regimeHistory; }
    getCurrentRegime() { return this.horsemenSystem ? this.horsemenSystem.getActiveRegime() : "Normal"; }
}

// DOM yüklendiğinde otomatik başlatmak için örnek entegrasyon
document.addEventListener('DOMContentLoaded', function() {
    if (!window.app) window.app = {};
    if (!window.app.candles) {
        // Basit örnek veri (gerçek sistemde canlı veri ile değiştirin)
        window.app.candles = Array.from({length: 100}, (_, i) => {
            const price = 100 + Math.sin(i/10)*5 + Math.random()*2;
            return {
                time: Date.now() - (100-i)*60000,
                open: price,
                close: price + (Math.random()-0.5),
                high: price * (1 + Math.random()*0.01),
                low: price * (1 - Math.random()*0.01),
                volume: 1000 + Math.random()*500
            };
        });
    }
    if (!window.app.notificationManager) {
        window.app.notificationManager = {
            notify: function(message, type, duration) {
                console.log(`[${type}] ${message}`);
            }
        };
    }
    // UI'da horsemen-container yoksa ekle
    if (!document.getElementById('horsemen-container')) {
        const container = document.createElement('div');
        container.id = 'horsemen-container';
        container.className = 'horsemen-container';
        container.style.cssText = 'display: flex; justify-content: space-around; padding: 10px; background-color: #1a1a1a; border-radius: 8px; margin: 10px 0;';
        const icons = { war: '⚔️', famine: '🍞', pestilence: '🦠', death: '💀' };
        const labels = { war: 'Savaş', famine: 'Kıtlık', pestilence: 'Veba', death: 'Ölüm' };
        Object.keys(icons).forEach(type => {
            const horseman = document.createElement('div');
            horseman.className = 'horseman';
            horseman.dataset.type = type;
            horseman.style.cssText = 'text-align: center; padding: 5px 15px; border-radius: 5px; transition: all 0.3s ease;';
            const icon = document.createElement('div');
            icon.className = 'horseman-icon';
            icon.textContent = icons[type];
            icon.style.cssText = 'font-size: 24px; opacity: 0.3; transition: opacity 0.3s;';
            const label = document.createElement('div');
            label.className = 'horseman-label';
            label.textContent = labels[type];
            label.style.cssText = 'font-size: 12px; margin-top: 5px;';
            horseman.appendChild(icon);
            horseman.appendChild(label);
            container.appendChild(horseman);
        });
        // Aktif rejim göstergesi
        const regimeIndicator = document.createElement('div');
        regimeIndicator.id = 'current-regime';
        regimeIndicator.className = 'regime-indicator';
        regimeIndicator.textContent = 'Aktif Rejim: Normal';
        regimeIndicator.style.cssText = 'text-align: center; margin-top: 10px; font-weight: bold; padding: 5px; border-radius: 3px;';
        container.appendChild(regimeIndicator);
        // Panteon paneline veya body'ye ekle
        const panteonPanel = document.getElementById('panteon-panel') || document.body;
        panteonPanel.appendChild(container);
    }
    // Entegrasyonu başlat
    window.panteonHorsemenIntegration = new PanteonHorsemenIntegration(window.app);
    window.panteonHorsemenIntegration.init();
});
</script>
<script>
    // NOT: Bu event listener artık kullanılmıyor, ana event listener'a taşındı
    // Eski kodlar referans olarak silindi
    console.log('Ek sistemler ana event listener\'a taşındı.');
</script>

<!-- Advanced Notification Container -->
<div id="notifications-container" class="notifications"></div>

<!-- Notification History Modal -->
<div id="notification-history-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Bildirim Geçmişi</h3>
            <span class="close-modal">&times;</span>
        </div>
        <div class="modal-body">
            <div class="notification-filters">
                <button class="filter active" data-filter="all">Tümü</button>
                <button class="filter" data-filter="trade">İşlem</button>
                <button class="filter" data-filter="alert">Uyarı</button>
                <button class="filter" data-filter="success">Başarılı</button>
                <button class="filter" data-filter="error">Hata</button>
                <button class="filter" data-filter="system">Sistem</button>
            </div>
            <div id="notification-history-list"></div>
        </div>
        <div class="modal-footer">
            <button id="clear-notifications-history" class="btn btn-danger">Geçmişi Temizle</button>
        </div>
    </div>
</div>
</body>
<!-- Kehanet Paneli (Piyasa Tahminleri ve AI Öngörüleri) -->
<div id="kehanet-panel" style="position:fixed;bottom:20px;right:20px;z-index:1400;width:240px;max-width:90vw;background:rgba(18,22,34,0.92);border-radius:8px;box-shadow:0 4px 24px #0008;padding:0;display:none;flex-direction:column;overflow:hidden;font-family:'Roboto Mono',monospace;transition:all 0.3s ease;">
    <div style="display:flex;align-items:center;justify-content:space-between;padding:10px 12px;background:rgba(255,215,0,0.08);border-bottom:1px solid #333;cursor:pointer;" onclick="toggleKehanetContent()">
        <span style="font-weight:700;font-size:14px;letter-spacing:1px;color:#ffd700;">🔮 Kehanet Paneli</span>
        <span id="kehanet-toggle-icon" style="color:#ffd700;font-size:16px;">−</span>
    </div>
    <div id="kehanet-content" style="padding:12px;max-height:200px;overflow-y:auto;transition:all 0.3s ease;">
        <div style="font-size:11px;opacity:0.8;margin-bottom:8px;">AI destekli piyasa öngörüleri ve stratejik tahminler</div>
        <div id="kehanet-forecast-list">
            <!-- Örnek tahminler -->
        </div>
        <button id="kehanet-refresh" style="margin-top:8px;background:#ffd700;color:#222;font-weight:600;padding:4px 12px;border:none;border-radius:4px;cursor:pointer;font-size:10px;">Güncelle</button>
    </div>
</div>
<button id="kehanet-fab" title="Kehanet Paneli" style="position:fixed;bottom:24px;right:24px;z-index:1399;width:44px;height:44px;border-radius:50%;background:linear-gradient(135deg,#ffd700 60%,#ba68c8 100%);box-shadow:0 2px 12px #0007;border:none;display:flex;align-items:center;justify-content:center;font-size:20px;color:#222;cursor:pointer;transition:background 0.2s;">🔮</button>

<script>
// Kehanet Paneli UI ve örnek tahminler
function showKehanetPanel(show=true){
    document.getElementById('kehanet-panel').style.display=show?'flex':'none';
    document.getElementById('kehanet-fab').style.display=show?'none':'flex';
}

// Toggle content
function toggleKehanetContent() {
    const content = document.getElementById('kehanet-content');
    const toggle = document.getElementById('kehanet-toggle-icon');
    
    if (content.style.maxHeight === '0px') {
        content.style.maxHeight = '200px';
        content.style.opacity = '1';
        toggle.textContent = '−';
    } else {
        content.style.maxHeight = '0px';
        content.style.opacity = '0';
        toggle.textContent = '+';
    }
}

document.getElementById('kehanet-fab').onclick=()=>showKehanetPanel(true);

function renderKehanetForecasts(forecasts){
    const list=document.getElementById('kehanet-forecast-list');
    if(!forecasts||!forecasts.length){list.innerHTML='<div style="opacity:0.7;">Tahmin bulunamadı.</div>';return;}
    list.innerHTML=forecasts.map(f=>`<div style="margin-bottom:10px;padding:10px 8px;background:rgba(255,255,255,0.03);border-radius:6px;">
        <div style="font-size:14px;font-weight:600;color:#ffd700;">${f.title}</div>
        <div style="font-size:12px;opacity:0.85;margin:4px 0 0 0;">${f.desc}</div>
        <div style="font-size:11px;opacity:0.6;margin-top:2px;">Tahmin: <b>${f.prediction}</b> &nbsp;|&nbsp; Güven: <b>${f.confidence}%</b></div>
    </div>`).join('');
}

function getSampleForecasts(){
    // Burada gerçek AI/ML entegrasyonu yapılabilir
    return [
        {title:'BTC/USDT',desc:'Önümüzdeki 4 saatlik periyotta yükseliş bekleniyor.',prediction:'YÜKSELİŞ',confidence:78},
        {title:'ETH/USDT',desc:'Kısa vadede yatay hareket olasılığı yüksek.',prediction:'YATAY',confidence:62},
        {title:'Piyasa Rejimi',desc:'Dört Atlı motoruna göre: SAVAŞ (Trend) rejimi aktif.',prediction:'SAVAŞ',confidence:85},
        {title:'AI Sinyal',desc:'AI modeline göre volatilite artışı bekleniyor.',prediction:'VOLATİLİTE',confidence:70}
    ];
}

function refreshKehanetForecasts(){
    // Gelecekte async API/ML entegrasyonu yapılabilir
    renderKehanetForecasts(getSampleForecasts());
}
document.getElementById('kehanet-refresh').onclick=refreshKehanetForecasts;
// Panel açıldığında otomatik yükle
document.getElementById('kehanet-fab').addEventListener('click',refreshKehanetForecasts);

// Sayfa yüklenince FAB görünür olsun
window.addEventListener('DOMContentLoaded',()=>{
    document.getElementById('kehanet-fab').style.display='flex';
});
</script>

<!-- === OSIRIS SENTINEL SYSTEM === -->
<script>
// --- OSIRIS Core Engine ---
class OSIRISCore {
    constructor(app) {
        this.app = app;
        this.isActive = false;
        this.threats = [];
        this.alerts = [];
        this.cyberBees = [];
        this.sentinels = {};
        this.riskLevel = 'LOW';
        this.lastScan = 0;
        this.scanInterval = 5000; // 5 saniye
        this.initSentinels();
    }
    
    initSentinels() {
        this.sentinels = {
            marketAnomalyDetector: new MarketAnomalyDetector(this),
            liquidityMonitor: new LiquidityMonitor(this),
            volatilityWatcher: new VolatilityWatcher(this),
            orderBookAnalyzer: new OrderBookAnalyzer(this),
            riskAssessment: new RiskAssessment(this)
        };
    }
    
    async activate() {
        if (this.isActive) return;
        this.isActive = true;
        
        // Cyber Bee Network başlat
        await this.initCyberBeeNetwork();
        
        // Sentinel sistemlerini başlat
        Object.values(this.sentinels).forEach(sentinel => sentinel.activate());
        
        // Ana tarama döngüsünü başlat
        this.mainLoop = setInterval(() => this.scanForThreats(), this.scanInterval);
        
        this.app.showNotification('OSIRIS SENTINEL Sistemi aktif edildi', 'info');
        console.log('🛡️ OSIRIS SENTINEL SYSTEM ACTIVATED');
    }
    
    async deactivate() {
        this.isActive = false;
        clearInterval(this.mainLoop);
        Object.values(this.sentinels).forEach(sentinel => sentinel.deactivate());
        this.cyberBees.forEach(bee => bee.terminate());
        this.cyberBees = [];
    }
    
    async initCyberBeeNetwork() {
        // 5 farklı tipte Cyber Bee oluştur
        const beeTypes = ['scout', 'guardian', 'analyzer', 'hunter', 'coordinator'];
        
        for (const type of beeTypes) {
            const bee = new CyberBee(type, this);
            await bee.initialize();
            this.cyberBees.push(bee);
        }
    }
    
    async scanForThreats() {
        if (!this.isActive) return;
        
        const now = Date.now();
        this.lastScan = now;
        
        // Her sentinel'den threat taraması al
        const threatReports = await Promise.all(
            Object.values(this.sentinels).map(sentinel => sentinel.scan())
        );
        
        // Cyber bee ağından intelligence topla
        const beeIntelligence = await this.gatherBeeIntelligence();
        
        // Tehditleri analiz et ve risk seviyesini güncelle
        this.analyzeThreats([...threatReports.flat(), ...beeIntelligence]);
        
        // Kritik tehditler varsa alarm çal
        this.processAlerts();
    }
    
    async gatherBeeIntelligence() {
        const intelligence = [];
        
        for (const bee of this.cyberBees) {
            const report = await bee.generateIntelligence();
            if (report) intelligence.push(report);
        }
        
        return intelligence;
    }
    
    analyzeThreats(threats) {
        this.threats = threats.filter(t => t.severity > 0);
        
        // Risk seviyesi hesapla
        const maxSeverity = Math.max(...this.threats.map(t => t.severity), 0);
        
        if (maxSeverity >= 8) this.riskLevel = 'CRITICAL';
        else if (maxSeverity >= 6) this.riskLevel = 'HIGH';
        else if (maxSeverity >= 4) this.riskLevel = 'MEDIUM';
        else this.riskLevel = 'LOW';
        
        // UI güncelle
        this.updateOSIRISUI();
    }
    
    processAlerts() {
        const criticalThreats = this.threats.filter(t => t.severity >= 7);
        
        for (const threat of criticalThreats) {
            this.createAlert(threat);
        }
    }
    
    createAlert(threat) {
        const alert = {
            id: Date.now() + Math.random(),
            threat: threat,
            timestamp: Date.now(),
            status: 'ACTIVE'
        };
        
        this.alerts.unshift(alert);
        
        // Maksimum 50 alert sakla
        if (this.alerts.length > 50) {
            this.alerts = this.alerts.slice(0, 50);
        }
        
        // Kullanıcıya bildir
        this.app.showNotification(
            `⚠️ OSIRIS ALERT: ${threat.type} - ${threat.message}`,
            'warning'
        );
    }
    
    updateOSIRISUI() {
        // OSIRIS panelini güncelle
        const panel = document.getElementById('osiris-panel');
        if (!panel) return;
        
        // Risk seviyesi
        const riskElement = panel.querySelector('#osiris-risk-level');
        if (riskElement) {
            riskElement.textContent = this.riskLevel;
            riskElement.className = `risk-level ${this.riskLevel.toLowerCase()}`;
        }
        
        // Aktif tehdit sayısı
        const threatCount = panel.querySelector('#osiris-threat-count');
        if (threatCount) {
            threatCount.textContent = this.threats.length;
        }
        
        // Cyber bee durumu
        const beeStatus = panel.querySelector('#osiris-bee-status');
        if (beeStatus) {
            const activeBees = this.cyberBees.filter(bee => bee.isActive).length;
            beeStatus.textContent = `${activeBees}/${this.cyberBees.length}`;
        }
    }
}

// --- Cyber Bee Network ---
class CyberBee {
    constructor(type, osiris) {
        this.type = type;
        this.osiris = osiris;
        this.isActive = false;
        this.intelligence = [];
        this.lastActivity = 0;
        this.behaviorPattern = this.getBehaviorPattern(type);
    }
    
    getBehaviorPattern(type) {
        const patterns = {
            scout: {
                scanFrequency: 3000,
                focusArea: 'market_exploration',
                sensitivity: 0.7
            },
            guardian: {
                scanFrequency: 1000,
                focusArea: 'threat_detection',
                sensitivity: 0.9
            },
            analyzer: {
                scanFrequency: 5000,
                focusArea: 'pattern_analysis',
                sensitivity: 0.8
            },
            hunter: {
                scanFrequency: 2000,
                focusArea: 'anomaly_hunting',
                sensitivity: 0.95
            },
            coordinator: {
                scanFrequency: 10000,
                focusArea: 'network_coordination',
                sensitivity: 0.6
            }
        };
        
        return patterns[type] || patterns.scout;
    }
    
    async initialize() {
        this.isActive = true;
        this.startBehaviorLoop();
    }
    
    startBehaviorLoop() {
        this.behaviorTimer = setInterval(() => {
            this.executeBehavior();
        }, this.behaviorPattern.scanFrequency);
    }
    
    async executeBehavior() {
        if (!this.isActive) return;
        
        this.lastActivity = Date.now();
        
        switch (this.type) {
            case 'scout':
                await this.scoutMarketConditions();
                break;
            case 'guardian':
                await this.guardAgainstThreats();
                break;
            case 'analyzer':
                await this.analyzePatterns();
                break;
            case 'hunter':
                await this.huntAnomalies();
                break;
            case 'coordinator':
                await this.coordinateNetwork();
                break;
        }
    }
    
    async scoutMarketConditions() {
        const candles = this.osiris.app.candles;
        if (!candles || candles.length < 10) return;
        
        const recent = candles.slice(-10);
        const volatility = this.calculateVolatility(recent);
        const volume = recent[recent.length - 1].volume;
        const avgVolume = recent.reduce((sum, c) => sum + c.volume, 0) / recent.length;
        
        if (volatility > 0.05) { // %5+ volatilite
            this.reportIntelligence({
                type: 'HIGH_VOLATILITY',
                severity: Math.min(volatility * 100, 10),
                data: { volatility, currentVolume: volume, avgVolume }
            });
        }
    }
    
    async guardAgainstThreats() {
        const signals = this.osiris.app.signals || [];
        const recentSignals = signals.filter(s => 
            Date.now() - s.timestamp < 300000 // Son 5 dakika
        );
        
        const slCount = recentSignals.filter(s => s.status === 'sl').length;
        const totalCount = recentSignals.length;
        
        if (totalCount > 0 && slCount / totalCount > 0.7) { // %70+ loss rate
            this.reportIntelligence({
                type: 'HIGH_LOSS_RATE',
                severity: 8,
                data: { slCount, totalCount, lossRate: slCount / totalCount }
            });
        }
    }
    
    async analyzePatterns() {
        const candles = this.osiris.app.candles;
        if (!candles || candles.length < 20) return;
        
        // Fiyat pattern analizi
        const recent = candles.slice(-20);
        const prices = recent.map(c => c.close);
        
        // Trend analizi
        const trend = this.calculateTrend(prices);
        const trendStrength = Math.abs(trend);
        
        if (trendStrength > 0.02) { // %2+ trend gücü
            this.reportIntelligence({
                type: 'STRONG_TREND_DETECTED',
                severity: Math.min(trendStrength * 200, 7),
                data: { trend, strength: trendStrength, direction: trend > 0 ? 'UP' : 'DOWN' }
            });
        }
    }
    
    async huntAnomalies() {
        const orderBook = this.osiris.app.lastOrderBook;
        if (!orderBook) return;
        
        // Emir defteri anomali tespiti
        const bids = orderBook.bids || [];
        const asks = orderBook.asks || [];
        
        if (bids.length === 0 || asks.length === 0) return;
        
        const spread = asks[0][0] - bids[0][0];
        const midPrice = (asks[0][0] + bids[0][0]) / 2;
        const spreadPercent = (spread / midPrice) * 100;
        
        if (spreadPercent > 0.5) { // %0.5+ spread
            this.reportIntelligence({
                type: 'WIDE_SPREAD_ANOMALY',
                severity: Math.min(spreadPercent * 10, 9),
                data: { spread, spreadPercent, midPrice }
            });
        }
    }
    
    async coordinateNetwork() {
        // Diğer bee'lerle koordinasyon
        const otherBees = this.osiris.cyberBees.filter(bee => bee !== this);
        const recentIntelligence = otherBees
            .map(bee => bee.intelligence.slice(-5))
            .flat()
            .filter(intel => Date.now() - intel.timestamp < 60000); // Son 1 dakika
        
        if (recentIntelligence.length > 10) {
            this.reportIntelligence({
                type: 'HIGH_NETWORK_ACTIVITY',
                severity: 5,
                data: { intelligenceCount: recentIntelligence.length }
            });
        }
    }
    
    calculateVolatility(candles) {
        const prices = candles.map(c => c.close);
        const mean = prices.reduce((sum, p) => sum + p, 0) / prices.length;
        const variance = prices.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / prices.length;
        return Math.sqrt(variance) / mean;
    }
    
    calculateTrend(prices) {
        const n = prices.length;
        let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
        
        for (let i = 0; i < n; i++) {
            sumX += i;
            sumY += prices[i];
            sumXY += i * prices[i];
            sumX2 += i * i;
        }
        
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        return slope / prices[0]; // Normalize
    }
    
    reportIntelligence(intel) {
        intel.timestamp = Date.now();
        intel.source = `bee_${this.type}`;
        
        this.intelligence.push(intel);
        
        // Maksimum 100 intelligence sakla
        if (this.intelligence.length > 100) {
            this.intelligence = this.intelligence.slice(-100);
        }
    }
    
    async generateIntelligence() {
        // Son 30 saniyedeki intelligence'ı döndür
        const recent = this.intelligence.filter(intel => 
            Date.now() - intel.timestamp < 30000
        );
        
        return recent.length > 0 ? recent[recent.length - 1] : null;
    }
    
    terminate() {
        this.isActive = false;
        clearInterval(this.behaviorTimer);
    }
}

// --- Market Anomaly Detector ---
class MarketAnomalyDetector {
    constructor(osiris) {
        this.osiris = osiris;
        this.isActive = false;
        this.baselineMetrics = null;
    }
    
    activate() {
        this.isActive = true;
        this.calculateBaseline();
    }
    
    deactivate() {
        this.isActive = false;
    }
    
    calculateBaseline() {
        const candles = this.osiris.app.candles;
        if (!candles || candles.length < 100) return;
        
        const recent100 = candles.slice(-100);
        const volumes = recent100.map(c => c.volume);
        const ranges = recent100.map(c => c.high - c.low);
        
        this.baselineMetrics = {
            avgVolume: volumes.reduce((sum, v) => sum + v, 0) / volumes.length,
            avgRange: ranges.reduce((sum, r) => sum + r, 0) / ranges.length,
            volumeStd: this.calculateStd(volumes),
            rangeStd: this.calculateStd(ranges)
        };
    }
    
    calculateStd(arr) {
        const mean = arr.reduce((sum, v) => sum + v, 0) / arr.length;
        const variance = arr.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / arr.length;
        return Math.sqrt(variance);
    }
    
    async scan() {
        if (!this.isActive || !this.baselineMetrics) return [];
        
        const threats = [];
        const candles = this.osiris.app.candles;
        if (!candles || candles.length === 0) return threats;
        
        const lastCandle = candles[candles.length - 1];
        const currentVolume = lastCandle.volume;
        const currentRange = lastCandle.high - lastCandle.low;
        
        // Hacim anomalisi
        const volumeDeviation = Math.abs(currentVolume - this.baselineMetrics.avgVolume) / this.baselineMetrics.volumeStd;
        if (volumeDeviation > 3) { // 3 sigma dışında
            threats.push({
                type: 'VOLUME_ANOMALY',
                severity: Math.min(volumeDeviation, 10),
                message: `Anormal hacim tespit edildi: ${volumeDeviation.toFixed(2)} sigma`,
                data: { currentVolume, baseline: this.baselineMetrics.avgVolume, deviation: volumeDeviation }
            });
        }
        
        // Fiyat aralığı anomalisi
        const rangeDeviation = Math.abs(currentRange - this.baselineMetrics.avgRange) / this.baselineMetrics.rangeStd;
        if (rangeDeviation > 3) {
            threats.push({
                type: 'PRICE_RANGE_ANOMALY',
                severity: Math.min(rangeDeviation, 10),
                message: `Anormal fiyat aralığı: ${rangeDeviation.toFixed(2)} sigma`,
                data: { currentRange, baseline: this.baselineMetrics.avgRange, deviation: rangeDeviation }
            });
        }
        
        return threats;
    }
}

// --- Liquidity Monitor ---
class LiquidityMonitor {
    constructor(osiris) {
        this.osiris = osiris;
        this.isActive = false;
        this.liquidityThresholds = {
            low: 50000,    // $50K
            critical: 20000 // $20K
        };
    }
    
    activate() {
        this.isActive = true;
    }
    
    deactivate() {
        this.isActive = false;
    }
    
    async scan() {
        if (!this.isActive) return [];
        
        const threats = [];
        const orderBook = this.osiris.app.lastOrderBook;
        if (!orderBook) return threats;
        
        const bidLiquidity = this.calculateLiquidity(orderBook.bids || []);
        const askLiquidity = this.calculateLiquidity(orderBook.asks || []);
        const totalLiquidity = bidLiquidity + askLiquidity;
        
        if (totalLiquidity < this.liquidityThresholds.critical) {
            threats.push({
                type: 'CRITICAL_LIQUIDITY',
                severity: 9,
                message: `Kritik likidite seviyesi: $${totalLiquidity.toFixed(0)}`,
                data: { bidLiquidity, askLiquidity, totalLiquidity }
            });
        } else if (totalLiquidity < this.liquidityThresholds.low) {
            threats.push({
                type: 'LOW_LIQUIDITY',
                severity: 6,
                message: `Düşük likidite: $${totalLiquidity.toFixed(0)}`,
                data: { bidLiquidity, askLiquidity, totalLiquidity }
            });
        }
        
        return threats;
    }
    
    calculateLiquidity(orders) {
        return orders.slice(0, 10).reduce((sum, [price, quantity]) => {
            return sum + (price * quantity);
        }, 0);
    }
}

// --- Volatility Watcher ---
class VolatilityWatcher {
    constructor(osiris) {
        this.osiris = osiris;
        this.isActive = false;
        this.volatilityThresholds = {
            high: 0.03,    // %3
            extreme: 0.05  // %5
        };
    }
    
    activate() {
        this.isActive = true;
    }
    
    deactivate() {
        this.isActive = false;
    }
    
    async scan() {
        if (!this.isActive) return [];
        
        const threats = [];
        const candles = this.osiris.app.candles;
        if (!candles || candles.length < 20) return threats;
        
        const recent = candles.slice(-20);
        const volatility = this.calculateVolatility(recent);
        
        if (volatility > this.volatilityThresholds.extreme) {
            threats.push({
                type: 'EXTREME_VOLATILITY',
                severity: 8,
                message: `Ekstrem volatilite: %${(volatility * 100).toFixed(2)}`,
                data: { volatility, threshold: this.volatilityThresholds.extreme }
            });
        } else if (volatility > this.volatilityThresholds.high) {
            threats.push({
                type: 'HIGH_VOLATILITY',
                severity: 5,
                message: `Yüksek volatilite: %${(volatility * 100).toFixed(2)}`,
                data: { volatility, threshold: this.volatilityThresholds.high }
            });
        }
        
        return threats;
    }
    
    calculateVolatility(candles) {
        const prices = candles.map(c => c.close);
        const mean = prices.reduce((sum, p) => sum + p, 0) / prices.length;
        const variance = prices.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / prices.length;
        return Math.sqrt(variance) / mean;
    }
}

// --- Order Book Analyzer ---
class OrderBookAnalyzer {
    constructor(osiris) {
        this.osiris = osiris;
        this.isActive = false;
    }
    
    activate() {
        this.isActive = true;
    }
    
    deactivate() {
        this.isActive = false;
    }
    
    async scan() {
        if (!this.isActive) return [];
        
        const threats = [];
        const orderBook = this.osiris.app.lastOrderBook;
        if (!orderBook) return threats;
        
        const bids = orderBook.bids || [];
        const asks = orderBook.asks || [];
        
        if (bids.length === 0 || asks.length === 0) {
            threats.push({
                type: 'EMPTY_ORDER_BOOK',
                severity: 10,
                message: 'Emir defteri boş',
                data: { bidsCount: bids.length, asksCount: asks.length }
            });
            return threats;
        }
        
        // Spread analizi
        const spread = asks[0][0] - bids[0][0];
        const midPrice = (asks[0][0] + bids[0][0]) / 2;
        const spreadPercent = (spread / midPrice) * 100;
        
        if (spreadPercent > 1.0) { // %1+ spread
            threats.push({
                type: 'WIDE_SPREAD',
                severity: Math.min(spreadPercent * 5, 10),
                message: `Geniş spread: %${spreadPercent.toFixed(3)}`,
                data: { spread, spreadPercent, midPrice }
            });
        }
        
        // Emir dengesizliği
        const bidVolume = bids.slice(0, 10).reduce((sum, [_, qty]) => sum + qty, 0);
        const askVolume = asks.slice(0, 10).reduce((sum, [_, qty]) => sum + qty, 0);
        const imbalance = Math.abs(bidVolume - askVolume) / (bidVolume + askVolume);
        
        if (imbalance > 0.8) { // %80+ dengesizlik
            threats.push({
                type: 'ORDER_IMBALANCE',
                severity: Math.min(imbalance * 10, 9),
                message: `Emir dengesizliği: %${(imbalance * 100).toFixed(1)}`,
                data: { bidVolume, askVolume, imbalance }
            });
        }
        
        return threats;
    }
}

// --- Risk Assessment ---
class RiskAssessment {
    constructor(osiris) {
        this.osiris = osiris;
        this.isActive = false;
    }
    
    activate() {
        this.isActive = true;
    }
    
    deactivate() {
        this.isActive = false;
    }
    
    async scan() {
        if (!this.isActive) return [];
        
        const threats = [];
        const app = this.osiris.app;
        
        // Trading performans analizi
        const signals = app.signals || [];
        if (signals.length > 10) {
            const recentSignals = signals.slice(-20);
            const tpCount = recentSignals.filter(s => s.status === 'tp').length;
            const slCount = recentSignals.filter(s => s.status === 'sl').length;
            const winRate = tpCount / (tpCount + slCount);
            
            if (winRate < 0.3) { // %30 altında kazanma oranı
                threats.push({
                    type: 'LOW_WIN_RATE',
                    severity: 7,
                    message: `Düşük kazanma oranı: %${(winRate * 100).toFixed(1)}`,
                    data: { winRate, tpCount, slCount, totalCount: tpCount + slCount }
                });
            }
        }
        
        // Sistem sağlığı
        const lastUpdate = app.lastDataUpdate || 0;
        const timeSinceUpdate = Date.now() - lastUpdate;
        
        if (timeSinceUpdate > 60000) { // 1 dakikadan eski veri
            threats.push({
                type: 'STALE_DATA',
                severity: 6,
                message: `Eski veri: ${Math.round(timeSinceUpdate / 1000)}s`,
                data: { timeSinceUpdate, lastUpdate }
            });
        }
        
        return threats;
    }
}

// OSIRIS UI entegrasyonu
window.addEventListener('DOMContentLoaded', () => {
    if (!window.app) return;
    
    // OSIRIS sistemini başlat
    window.app.osiris = new OSIRISCore(window.app);
    
    // OSIRIS paneli oluştur
    createOSIRISPanel();
    
    // Chart overlay signals oluştur
    createChartSignalOverlay();
    
    // Otomatik sinyal güncellemeleri
    setInterval(async () => {
        if (window.app && window.app.aiPredictionEngine && window.app.aiPredictionEngine.isTrained) {
            const pred = await window.app.aiPredictionEngine.predictAll();
            if (pred) {
                updateChartSignals(
                    `${pred.pricePrediction.toFixed(2)}`,
                    'ACTIVE',
                    pred.trend
                );
            }
        }
    }, 30000); // Her 30 saniyede bir güncelle
    
    // Otomatik başlatma (1 saniye gecikmeyle)
    setTimeout(() => {
        window.app.osiris.activate();
    }, 1000);
});

// Chart overlay signals
function createChartSignalOverlay() {
    const overlay = document.createElement('div');
    overlay.id = 'chart-signal-overlay';
    overlay.innerHTML = `
        <div style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);z-index:1100;pointer-events:none;display:flex;gap:10px;flex-wrap:wrap;">
            <div id="ai-signal" style="background:rgba(16,185,129,0.9);color:white;padding:4px 8px;border-radius:4px;font-size:11px;font-weight:bold;display:none;">
                🤖 AI: <span id="ai-signal-text">--</span>
            </div>
            <div id="osiris-signal" style="background:rgba(59,130,246,0.9);color:white;padding:4px 8px;border-radius:4px;font-size:11px;font-weight:bold;display:none;">
                🛡️ OSIRIS: <span id="osiris-signal-text">--</span>
            </div>
            <div id="trend-signal" style="background:rgba(251,191,36,0.9);color:white;padding:4px 8px;border-radius:4px;font-size:11px;font-weight:bold;display:none;">
                📈 TREND: <span id="trend-signal-text">--</span>
            </div>
        </div>
    `;
    document.body.appendChild(overlay);
}

// Signal update functions
function updateChartSignals(aiSignal, osirisSignal, trendSignal) {
    if (aiSignal) {
        document.getElementById('ai-signal-text').textContent = aiSignal;
        document.getElementById('ai-signal').style.display = 'block';
        setTimeout(() => document.getElementById('ai-signal').style.display = 'none', 5000);
    }
    
    if (osirisSignal) {
        document.getElementById('osiris-signal-text').textContent = osirisSignal;
        document.getElementById('osiris-signal').style.display = 'block';
        setTimeout(() => document.getElementById('osiris-signal').style.display = 'none', 5000);
    }
    
    if (trendSignal) {
        document.getElementById('trend-signal-text').textContent = trendSignal;
        document.getElementById('trend-signal').style.display = 'block';
        setTimeout(() => document.getElementById('trend-signal').style.display = 'none', 5000);
    }
}

function createOSIRISPanel() {
    const panel = document.createElement('div');
    panel.id = 'osiris-panel';
    panel.innerHTML = `
        <div style="position:fixed;top:20px;right:20px;z-index:1500;width:260px;background:rgba(13,17,23,0.92);border:1px solid #3b82f6;border-radius:8px;padding:12px;font-family:'Roboto Mono',monospace;font-size:12px;color:#e2e8f0;backdrop-filter:blur(8px);transition:all 0.3s ease;" id="osiris-main-panel">
            <div style="display:flex;align-items:center;gap:8px;margin-bottom:10px;color:#3b82f6;font-weight:bold;cursor:pointer;" onclick="toggleOSIRISPanel()">
                🛡️ OSIRIS SENTINEL
                <div style="flex:1;height:1px;background:linear-gradient(90deg,#3b82f6,transparent);"></div>
                <span id="osiris-toggle" style="font-size:14px;">−</span>
            </div>
            <div id="osiris-content" style="transition:all 0.3s ease;">
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px;">
                    <div>Risk: <span id="osiris-risk-level" class="risk-level low">LOW</span></div>
                    <div>Threats: <span id="osiris-threat-count">0</span></div>
                    <div>Cyber Bees: <span id="osiris-bee-status">0/0</span></div>
                    <div>Status: <span style="color:#10b981;">ACTIVE</span></div>
                </div>
                <div style="font-size:10px;opacity:0.7;text-align:center;">
                    Real-time threat detection & anomaly analysis
                </div>
            </div>
        </div>
    `;
    document.body.appendChild(panel);
    
    // Toggle fonksiyonu
    window.toggleOSIRISPanel = function() {
        const content = document.getElementById('osiris-content');
        const toggle = document.getElementById('osiris-toggle');
        const mainPanel = document.getElementById('osiris-main-panel');
        
        if (content.style.maxHeight === '0px') {
            content.style.maxHeight = '200px';
            content.style.opacity = '1';
            toggle.textContent = '−';
            mainPanel.style.height = 'auto';
        } else {
            content.style.maxHeight = '0px';
            content.style.opacity = '0';
            toggle.textContent = '+';
            mainPanel.style.height = '40px';
        }
    };
}
</script>
<!-- Yeni Navigasyon ve Grafik Görünüm Yönetimi için JS -->
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Navigasyon butonları için event listeners
        const navItems = document.querySelectorAll('.nav-item');
        navItems.forEach(item => {
            item.addEventListener('click', function() {
                // Aktif butonun stilini güncelle
                navItems.forEach(btn => btn.classList.remove('active'));
                this.classList.add('active');
                
                // İlgili görünümü göster
                const viewId = this.getAttribute('data-view');
                const views = document.querySelectorAll('.content-view');
                views.forEach(view => view.classList.remove('active'));
                document.getElementById(viewId + '-view').classList.add('active');
                
                // Özel görünüm işlemlerini çalıştır
                handleViewChange(viewId);
            });
        });
        
        // İlk yükleme için ana grafik görünümünü aktif yap
        document.querySelector('[data-view="chart"]').classList.add('active');
        
        // Grafik kontrolleri için event listeners
        const chartZoomIn = document.querySelector('.chart-btn[title="Yakınlaştır"]');
        const chartZoomOut = document.querySelector('.chart-btn[title="Uzaklaştır"]');
        const chartFullscreen = document.querySelector('.chart-btn[title="Tam Ekran"]');
        
        if (chartZoomIn) chartZoomIn.addEventListener('click', () => {
            if (window.app && window.app.chartManager) window.app.chartManager.zoomIn();
        });
        
        if (chartZoomOut) chartZoomOut.addEventListener('click', () => {
            if (window.app && window.app.chartManager) window.app.chartManager.zoomOut();
        });
        
        if (chartFullscreen) chartFullscreen.addEventListener('click', toggleFullscreen);
        
        // Bağlantı durumu güncelleme (örnek)
        updateConnectionStatus(true);
        
        // Fiyat güncelleme için interval
        setInterval(simulatePriceUpdate, 2000);
        
        // Grafik oluşturma
        initializeChart();
    });
    
    // Görünüm değişikliğini yönetme
    function handleViewChange(viewId) {
        console.log('View changed to:', viewId);
        switch(viewId) {
            case 'chart':
                // Grafik görünümünde özel işlemler
                if (window.app && window.app.chartManager) {
                    window.app.chartManager.resetZoom();
                }
                break;
            case 'panteon':
                // Panteon içeriğini panteon-view içine taşı
                const panteonContent = document.getElementById('panteon-panel');
                document.getElementById('panteon-view').innerHTML = '';
                document.getElementById('panteon-view').appendChild(panteonContent.cloneNode(true));
                break;
            case 'kehanet':
                // Kehanet içeriğini kehanet-view içine taşı
                const kehanetContent = document.getElementById('kehanet-panel');
                document.getElementById('kehanet-view').innerHTML = '';
                document.getElementById('kehanet-view').appendChild(kehanetContent.cloneNode(true));
                break;
            // Diğer görünümler için işlemler eklenebilir
        }
    }
    
    // Bağlantı durumunu güncelleme
    function updateConnectionStatus(isConnected) {
        const statusIndicator = document.querySelector('.connection-status');
        if (isConnected) {
            statusIndicator.classList.add('online');
            statusIndicator.classList.remove('offline');
            statusIndicator.title = 'Bağlantı Aktif';
        } else {
            statusIndicator.classList.remove('online');
            statusIndicator.classList.add('offline');
            statusIndicator.title = 'Bağlantı Kesildi';
        }
    }
    
    // Demo fiyat güncellemesi (gerçek sistemde WebSocket ile değiştirilecek)
    function simulatePriceUpdate() {
        const currentPrice = parseFloat(document.getElementById('ticker-price').textContent);
        const change = (Math.random() - 0.5) * 2; // -1 ile +1 arası
        const newPrice = (currentPrice + change).toFixed(2);
        
        document.getElementById('ticker-price').textContent = newPrice;
        
        // Fiyat renklendirme
        if (change > 0) {
            document.getElementById('ticker-price').style.color = 'var(--success)';
        } else if (change < 0) {
            document.getElementById('ticker-price').style.color = 'var(--danger)';
        }
        
        // 2 saniye sonra rengi normale döndür
        setTimeout(() => {
            document.getElementById('ticker-price').style.color = '';
        }, 1000);
    }
    
    // Tam ekran geçişi
    function toggleFullscreen() {
        const chartView = document.getElementById('chart-view');
        
        if (!document.fullscreenElement) {
            if (chartView.requestFullscreen) {
                chartView.requestFullscreen();
            } else if (chartView.webkitRequestFullscreen) {
                chartView.webkitRequestFullscreen();
            } else if (chartView.msRequestFullscreen) {
                chartView.msRequestFullscreen();
            }
            document.querySelector('.chart-btn[title="Tam Ekran"]').textContent = '⛶';
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
            document.querySelector('.chart-btn[title="Tam Ekran"]').textContent = '⛶';
        }
    }
    
    // Grafik oluşturma
    function initializeChart() {
        const chartContainer = document.getElementById('chart-container');
        
        // LightweightCharts ile grafik oluştur
        const chart = LightweightCharts.createChart(chartContainer, {
            width: chartContainer.clientWidth,
            height: chartContainer.clientHeight,
            layout: {
                background: { color: 'rgba(22, 27, 34, 0.2)' },
                textColor: '#D9D9D9',
                fontSize: 12,
                fontFamily: 'Roboto Mono'
            },
            grid: {
                vertLines: { color: 'rgba(42, 46, 57, 0.5)' },
                horzLines: { color: 'rgba(42, 46, 57, 0.5)' }
            },
            timeScale: {
                timeVisible: true,
                secondsVisible: false,
                borderColor: 'rgba(197, 203, 206, 0.3)',
            },
            crosshair: {
                mode: LightweightCharts.CrosshairMode.Normal,
                vertLine: {
                    color: 'rgba(197, 203, 206, 0.5)',
                    width: 1,
                    style: LightweightCharts.LineStyle.Solid,
                    labelBackgroundColor: '#171B26',
                },
                horzLine: {
                    color: 'rgba(197, 203, 206, 0.5)',
                    width: 1,
                    style: LightweightCharts.LineStyle.Solid,
                    labelBackgroundColor: '#171B26',
                }
            }
        });
        
        // Pencere boyutu değişince grafiği güncelle
        window.addEventListener('resize', () => {
            chart.resize(
                chartContainer.clientWidth,
                chartContainer.clientHeight
            );
        });
        
        // Mum serisi oluştur
        const candleSeries = chart.addCandlestickSeries({
            upColor: '#26a69a',
            downColor: '#ef5350',
            borderVisible: false,
            wickUpColor: '#26a69a',
            wickDownColor: '#ef5350'
        });
        
        // Örnek veri - gerçek uygulamada API'den alınacak
        const demoData = generateDemoData(100);
        candleSeries.setData(demoData);
        
        // Hacim serisi ekle
        const volumeSeries = chart.addHistogramSeries({
            color: '#26a69a',
            priceFormat: {
                type: 'volume',
            },
            priceScaleId: '',
            scaleMargins: {
                top: 0.8,
                bottom: 0,
            },
        });
        
        const volumeData = demoData.map(item => ({
            time: item.time,
            value: item.volume,
            color: item.close > item.open ? '#26a69a' : '#ef5350'
        }));
        
        volumeSeries.setData(volumeData);
        
        // Global erişim için
        window.chart = chart;
        window.candleSeries = candleSeries;
        window.volumeSeries = volumeSeries;
        
        // Demo sinyaller ekle
        setTimeout(() => {
            candleSeries.setMarkers([
                { time: demoData[10].time, position: 'belowBar', color: '#2196F3', shape: 'arrowUp', text: 'AL' },
                { time: demoData[20].time, position: 'aboveBar', color: '#FF5252', shape: 'arrowDown', text: 'SAT' },
                { time: demoData[30].time, position: 'belowBar', color: '#2196F3', shape: 'arrowUp', text: 'AL' },
                { time: demoData[40].time, position: 'belowBar', color: '#66BB6A', shape: 'circle', text: 'TP' },
                { time: demoData[50].time, position: 'belowBar', color: '#2196F3', shape: 'arrowUp', text: 'AL' }
            ]);
        }, 1000);
    }
    
    // Demo mum verileri oluştur
    function generateDemoData(count) {
        const data = [];
        let time = new Date(Date.UTC(2023, 0, 1, 0, 0, 0, 0));
        let price = 200;
        let volume = 1000;
        
        for (let i = 0; i < count; i++) {
            const volatility = 3; // Volatilite (fiyat değişkenliği)
            const rnd = Math.random() - 0.5; // -0.5 ile 0.5 arasında rastgele değer
            const change = volatility * rnd;
            
            const open = price;
            const close = open + change;
            const high = Math.max(open, close) + Math.abs(change) * 0.2 * Math.random();
            const low = Math.min(open, close) - Math.abs(change) * 0.2 * Math.random();
            const volumeChange = (1 + (Math.random() - 0.5) * 0.3) * volume;
            
            data.push({
                time: time.getTime() / 1000,
                open: open,
                high: high,
                low: low,
                close: close,
                volume: volumeChange
            });
            
            // Bir sonraki mum için değerleri güncelle
            price = close;
            time = new Date(time.getTime() + 3600000); // 1 saat ekle
            volume = volumeChange;
        }
        
        return data;
    }
</script>
<!-- Yan Menü ve Panel Etkileşimleri için JS -->
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Yan menü butonlarını seç
        const sideMenuBtns = document.querySelectorAll('.side-menu-item');
        const notificationsToggle = document.getElementById('notifications-toggle');
        const energyToggle = document.getElementById('energy-toggle');
        const ritualToggle = document.getElementById('ritual-toggle');
        const osirisToggle = document.getElementById('osiris-toggle');
        const logsToggle = document.getElementById('logs-toggle');
        const themeToggle = document.getElementById('theme-toggle');
        const helpToggle = document.getElementById('help-toggle');
        
        // Panel kapatma butonlarını seç
        const closePanelBtns = document.querySelectorAll('.close-panel');
        
        // Aktif paneli izleme
        let activePanel = null;
        
        // Bildirim paneli toggle fonksiyonu
        notificationsToggle.addEventListener('click', function() {
            togglePanel('notification-panel', this);
        });
        
        // Diğer panel toggle'ları (enerji, ritüel, vb.)
        // İlgili paneller yapıldığında etkinleştirilecek
        energyToggle.addEventListener('click', function() {
            alert('Enerji Paneli yapım aşamasında!');
            // togglePanel('energy-panel', this);
        });
        
        ritualToggle.addEventListener('click', function() {
            alert('Ritüel Sistemi yapım aşamasında!');
            // togglePanel('ritual-panel', this);
        });
        
        osirisToggle.addEventListener('click', function() {
            alert('OSIRIS Sistemi yapım aşamasında!');
            // togglePanel('osiris-panel', this);
        });
        
        logsToggle.addEventListener('click', function() {
            alert('Log Paneli yapım aşamasında!');
            // togglePanel('logs-panel', this);
        });
        
        // Tema değiştirme
        themeToggle.addEventListener('click', function() {
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            
            // Tema değişimi animasyonu
            document.body.classList.add('theme-transition');
            setTimeout(() => {
                document.body.classList.remove('theme-transition');
            }, 1000);
            
            // İkon güncelleme
            this.querySelector('.side-icon').textContent = newTheme === 'dark' ? '🌓' : '🌒';
        });
        
        // Yardım
        helpToggle.addEventListener('click', function() {
            alert('Ultimate Trading War Room v3.0\n\nGeliştirici: Tech Army Team\nSürüm: 3.0.5\n\nDaha fazla bilgi için dökümantasyona bakınız.');
        });
        
        // Panel kapatma butonları
        closePanelBtns.forEach(btn => {
            btn.addEventListener('click', function() {
                const panel = this.closest('.side-panel');
                if (panel) {
                    panel.classList.remove('active');
                    // İlgili butonun aktif durumunu kaldır
                    const panelId = panel.id;
                    const relatedBtn = document.querySelector(`[data-target="${panelId}"]`) || 
                                      document.querySelector(`#${panelId.replace('-panel', '-toggle')}`);
                    
                    if (relatedBtn) {
                        relatedBtn.classList.remove('active');
                    }
                    
                    activePanel = null;
                }
            });
        });
        
        // Panel geçişi
        function togglePanel(panelId, button) {
            const panel = document.getElementById(panelId);
            
            // Önceki aktif paneli kapat
            if (activePanel && activePanel !== panel) {
                activePanel.classList.remove('active');
                
                // Önceki aktif butonun aktifliğini kaldır
                const prevButton = document.querySelector(`[data-target="${activePanel.id}"]`) || 
                                 document.querySelector(`#${activePanel.id.replace('-panel', '-toggle')}`);
                if (prevButton) {
                    prevButton.classList.remove('active');
                }
            }
            
            // Panel geçişi
            if (panel) {
                const isActive = panel.classList.toggle('active');
                button.classList.toggle('active', isActive);
                
                activePanel = isActive ? panel : null;
                
                // Panel açıldığında bildirimleri temizle
                if (isActive && panelId === 'notification-panel') {
                    clearNotificationBadge();
                }
            }
        }
        
        // Demo bildirimleri göster
        setTimeout(() => {
            showNotification('Yeni sinyal: SOL/USDT için AL sinyali oluştu', 'success');
        }, 3000);
        
        setTimeout(() => {
            showNotification('Volatilite Uyarısı: BTC volatilitesi yükseliyor', 'warning');
        }, 7000);
        
        // Bildirim gösterme fonksiyonu
        function showNotification(message, type = 'info') {
            // Bildirim sayısını arttır
            updateNotificationBadge(1);
            
            // Bildirim toast'u oluştur
            const toast = document.createElement('div');
            toast.className = `notification-toast ${type}`;
            toast.innerHTML = `
                <div class="notification-toast-icon">${getNotificationIcon(type)}</div>
                <div class="notification-toast-content">${message}</div>
                <button class="notification-toast-close">✖</button>
            `;
            
            // Toast'u ekle
            document.body.appendChild(toast);
            
            // Animasyon için setTimeout
            setTimeout(() => {
                toast.classList.add('show');
            }, 10);
            
            // Otomatik kapanma
            const timeout = setTimeout(() => {
                closeNotificationToast(toast);
            }, 5000);
            
            // Kapatma butonu
            const closeBtn = toast.querySelector('.notification-toast-close');
            closeBtn.addEventListener('click', () => {
                clearTimeout(timeout);
                closeNotificationToast(toast);
            });
        }
        
        // Bildirim kapatma fonksiyonu
        function closeNotificationToast(toast) {
            toast.classList.remove('show');
            setTimeout(() => {
                toast.remove();
            }, 300);
        }
        
        // Bildirim sayacını güncelle
        function updateNotificationBadge(increment = 1) {
            const badge = document.querySelector('.notification-badge');
            if (badge) {
                let count = parseInt(badge.textContent) || 0;
                count += increment;
                badge.textContent = count;
                badge.style.display = count > 0 ? 'flex' : 'none';
            }
        }
        
        // Bildirim sayacını sıfırla
        function clearNotificationBadge() {
            const badge = document.querySelector('.notification-badge');
            if (badge) {
                badge.textContent = '0';
                badge.style.display = 'none';
            }
        }
        
        // Bildirim ikonları
        function getNotificationIcon(type) {
            switch(type) {
                case 'success': return '✅';
                case 'warning': return '⚠️';
                case 'danger': return '❌';
                case 'info':
                default: return 'ℹ️';
            }
        }
        
        // Toast bildirimleri için CSS oluştur
        const style = document.createElement('style');
        style.textContent = `
            .notification-toast {
                position: fixed;
                top: 70px;
                right: 15px;
                min-width: 280px;
                max-width: 350px;
                background: rgba(22, 27, 34, 0.9);
                backdrop-filter: blur(10px);
                border-left: 4px solid var(--primary);
                border-radius: 5px;
                padding: 12px 15px;
                display: flex;
                align-items: center;
                gap: 12px;
                box-shadow: 0 5px 15px rgba(0,0,0,0.3);
                transform: translateX(120%);
                opacity: 0;
                transition: transform 0.3s ease, opacity 0.3s ease;
                z-index: 9999;
                font-family: 'Roboto Mono', monospace;
            }
            
            .notification-toast.show {
                transform: translateX(0);
                opacity: 1;
            }
            
            .notification-toast.success {
                border-left-color: var(--success);
            }
            
            .notification-toast.warning {
                border-left-color: var(--warning);
            }
            
            .notification-toast.danger {
                border-left-color: var(--danger);
            }
            
            .notification-toast.info {
                border-left-color: var(--info);
            }
            
            .notification-toast-icon {
                flex-shrink: 0;
                width: 24px;
                height: 24px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 14px;
            }
            
            .notification-toast-content {
                flex-grow: 1;
                font-size: 13px;
            }
            
            .notification-toast-close {
                background: transparent;
                border: none;
                color: var(--text-secondary);
                cursor: pointer;
                font-size: 12px;
                padding: 3px;
                border-radius: 3px;
                transition: all 0.2s ease;
                flex-shrink: 0;
            }
            
            .notification-toast-close:hover {
                background: rgba(255,255,255,0.1);
                color: var(--danger);
            }
            
            /* Tema geçiş animasyonu */
            .theme-transition {
                transition: background-color 0.5s ease, color 0.5s ease;
            }
            
            /* Birden fazla toast olduğunda konumlandırma */
            .notification-toast:nth-child(1) { top: 70px; }
            .notification-toast:nth-child(2) { top: 140px; }
            .notification-toast:nth-child(3) { top: 210px; }
            .notification-toast:nth-child(4) { top: 280px; }
            .notification-toast:nth-child(5) { top: 350px; }
            
            /* Mobil uyumluluk */
            @media screen and (max-width: 768px) {
                .notification-toast {
                    min-width: unset;
                    width: calc(100% - 30px);
                    max-width: calc(100% - 30px);
                }
            }
        `;
        document.head.appendChild(style);
    });
</script>
<script>
// Grafik oluşturma ve yönetimi
function initializeChart() {
    const chartContainer = document.getElementById('chart-container');
    if (!chartContainer) return;
    
    // Eğer LightweightCharts yüklüyse grafik oluştur
    if (typeof LightweightCharts !== 'undefined') {
        // Grafik oluştur
        const chart = LightweightCharts.createChart(chartContainer, {
            width: chartContainer.clientWidth,
            height: chartContainer.clientHeight,
            layout: {
                background: {
                    type: 'solid',
                    color: 'var(--panel-bg)',
                },
                textColor: 'var(--text-main)',
            },
            grid: {
                vertLines: {
                    color: 'rgba(42, 46, 57, 0.5)',
                },
                horzLines: {
                    color: 'rgba(42, 46, 57, 0.5)',
                },
            },
            timeScale: {
                timeVisible: true,
                secondsVisible: false,
            },
            crosshair: {
                mode: LightweightCharts.CrosshairMode.Normal,
            },
            rightPriceScale: {
                borderColor: 'var(--border-color)',
            },
        });
        
        // Mum serisini oluştur
        const candlestickSeries = chart.addCandlestickSeries({
            upColor: 'var(--success)',
            downColor: 'var(--danger)',
            borderDownColor: 'var(--danger)',
            borderUpColor: 'var(--success)',
            wickDownColor: 'var(--danger)',
            wickUpColor: 'var(--success)',
        });
        
        // Hacim serisini oluştur
        const volumeSeries = chart.addHistogramSeries({
            color: 'rgba(59, 130, 246, 0.5)',
            priceFormat: {
                type: 'volume',
            },
            priceScaleId: '',
            scaleMargins: {
                top: 0.8,
                bottom: 0,
            },
        });
        
        // Pencere boyut değişikliği durumunda grafiği yeniden boyutlandır
        function handleResize() {
            if (chart) {
                chart.applyOptions({
                    width: chartContainer.clientWidth,
                    height: chartContainer.clientHeight,
                });
            }
        }
        
        window.addEventListener('resize', handleResize);
        
        // Demo verileri yükle
        const demoData = generateDemoData(100);
        candlestickSeries.setData(demoData);
        
        // Hacim verilerini ayarla
        const volumeData = demoData.map(item => ({
            time: item.time,
            value: item.volume,
            color: item.close > item.open ? 'rgba(16, 185, 129, 0.5)' : 'rgba(239, 68, 68, 0.5)',
        }));
        volumeSeries.setData(volumeData);
        
        // Global erişim için
        window.chart = chart;
        window.candleSeries = candlestickSeries;
        window.volumeSeries = volumeSeries;
        
        // Örnek sinyal işaretleri
        setTimeout(() => {
            candlestickSeries.setMarkers([
                {
                    time: demoData[10].time,
                    position: 'belowBar',
                    color: 'var(--success)',
                    shape: 'arrowUp',
                    text: 'AL',
                },
                {
                    time: demoData[30].time,
                    position: 'aboveBar',
                    color: 'var(--danger)',
                    shape: 'arrowDown',
                    text: 'SAT',
                },
                {
                    time: demoData[50].time,
                    position: 'belowBar',
                    color: 'var(--success)',
                    shape: 'arrowUp',
                    text: 'AL',
                },
                {
                    time: demoData[80].time,
                    position: 'aboveBar',
                    color: 'var(--danger)',
                    shape: 'arrowDown',
                    text: 'SAT',
                },
            ]);
        }, 1000);
    } else {
        console.error('LightweightCharts kütüphanesi yüklenemedi!');
        chartContainer.innerHTML = '<div style="display:flex;justify-content:center;align-items:center;height:100%;color:var(--danger);">Grafik kütüphanesi yüklenemedi!</div>';
    }
}

// Demo mum verileri oluştur
function generateDemoData(count) {
    const data = [];
    let time = new Date(Date.UTC(2023, 0, 1, 0, 0, 0, 0));
    let price = 35000;
    let volume = 1000;
    
    for (let i = 0; i < count; i++) {
        const volatility = Math.random() * 200 + 100;
        const open = price;
        const close = price + (Math.random() - 0.5) * volatility;
        const high = Math.max(open, close) + Math.random() * volatility * 0.5;
        const low = Math.min(open, close) - Math.random() * volatility * 0.5;
        
        data.push({
            time: Math.floor(time.getTime() / 1000),
            open: open,
            high: high,
            low: low,
            close: close,
            volume: volume + Math.floor(Math.random() * 1000),
        });
        
        price = close;
        volume = volume + Math.floor((Math.random() - 0.5) * 500);
        if (volume < 500) volume = 500;
        
        time.setDate(time.getDate() + 1);
    }
    
    return data;
}

// DOM yüklendiğinde grafik başlatılır
document.addEventListener('DOMContentLoaded', function() {
    initializeChart();
});
</script>
<script>
/* JavaScript hata düzeltmeleri için global fonksiyonlar */
window.fixDuplicateIds = function() {
    // Tekrarlanan ID'leri düzelt
    const kehanetPanels = document.querySelectorAll('[id="kehanet-panel"]');
    if (kehanetPanels.length > 1) {
        kehanetPanels[0].id = 'kehanet-panel-main';
        kehanetPanels[1].id = 'kehanet-panel-secondary';
        
        // Toggle butonlarını da güncelle
        const toggles = document.querySelectorAll('[id="kp-toggle"]');
        if (toggles.length > 1) {
            toggles[0].id = 'kp-toggle-main';
            toggles[1].id = 'kp-toggle-secondary';
        }
        
        // Content alanlarını da güncelle
        const contents = document.querySelectorAll('[id="kp-content"]');
        if (contents.length > 1) {
            contents[0].id = 'kp-content-main';
            contents[1].id = 'kp-content-secondary';
        }
        
        console.log('Duplicate IDs fixed successfully');
    }
};

// Sayfa yüklendiğinde ID düzeltmelerini çalıştır
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', window.fixDuplicateIds);
} else {
    window.fixDuplicateIds();
}
</script>
</html>